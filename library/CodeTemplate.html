<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>CodeTemplate for Competitive Programming</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<H1>Contents</H1>
<OL>
  <LI><A HREF="#file1">About.cpp</A>
  <LI><A HREF="#file2">DefaultCode.cpp</A>
  <LI><A HREF="#file3">Note.cpp</A>
  <LI><A HREF="#file4">algorithms/Hungarian.cpp</A>
  <LI><A HREF="#file5">algorithms/IntervalSet.cpp</A>
  <LI><A HREF="#file6">algorithms/Jumper.cpp</A>
  <LI><A HREF="#file7">algorithms/MaxRecUnderHistogram.cpp</A>
  <LI><A HREF="#file8">algorithms/RangeMinimumQuery.cpp</A>
  <LI><A HREF="#file9">data_structure/CentroidDecomposition.cpp</A>
  <LI><A HREF="#file10">data_structure/FenwickTree.cpp</A>
  <LI><A HREF="#file11">data_structure/HeavyLightDecomposition.cpp</A>
  <LI><A HREF="#file12">data_structure/LazySegmentTree.cpp</A>
  <LI><A HREF="#file13">data_structure/PersistentTree.cpp</A>
  <LI><A HREF="#file14">data_structure/SegmentTree.cpp</A>
  <LI><A HREF="#file15">data_structure/SplayTree.cpp</A>
  <LI><A HREF="#file16">data_structure/Treap.cpp</A>
  <LI><A HREF="#file17">data_structure/Trie.cpp</A>
  <LI><A HREF="#file18">dp/ConvexHullOptimization.cpp</A>
  <LI><A HREF="#file19">geometry/ClosestPair.cpp</A>
  <LI><A HREF="#file20">geometry/EarthCoordinates.cpp</A>
  <LI><A HREF="#file21">geometry/Line.cpp</A>
  <LI><A HREF="#file22">geometry/Util.cpp</A>
  <LI><A HREF="#file23">graph/BiconnectedComponent.cpp</A>
  <LI><A HREF="#file24">graph/Dinic.cpp</A>
  <LI><A HREF="#file25">graph/EulerCircuit.cpp</A>
  <LI><A HREF="#file26">graph/EulerPathDirectedGraph.cpp</A>
  <LI><A HREF="#file27">graph/FordFulkerson.cpp</A>
  <LI><A HREF="#file28">graph/GlobalMinCut.cpp</A>
  <LI><A HREF="#file29">graph/LCA.cpp</A>
  <LI><A HREF="#file30">graph/MaximumBipartiteMatching.cpp</A>
  <LI><A HREF="#file31">graph/MinCostMaxFlow.cpp</A>
  <LI><A HREF="#file32">graph/MinimumPathCoverDAG.cpp</A>
  <LI><A HREF="#file33">graph/MinimumSpanningTree.cpp</A>
  <LI><A HREF="#file34">graph/ShortestPath.cpp</A>
  <LI><A HREF="#file35">graph/StronglyConnectedComponent.cpp</A>
  <LI><A HREF="#file36">number/FFT.cpp</A>
  <LI><A HREF="#file37">number/LinearAlgebra.cpp</A>
  <LI><A HREF="#file38">number/Matrix.cpp</A>
  <LI><A HREF="#file39">number/ModInt.cpp</A>
  <LI><A HREF="#file40">number/Rational.cpp</A>
  <LI><A HREF="#file41">string/AhoCorasickAlgorithm.cpp</A>
  <LI><A HREF="#file42">string/ManacherAlgorithm.cpp</A>
  <LI><A HREF="#file43">string/StringMatching.cpp</A>
  <LI><A HREF="#file44">string/SuffixArray.cpp</A>
  <LI><A HREF="#file45">string/SuffixArray_nlgn.cpp</A>
  <LI><A HREF="#file46">string/SuffixTree.cpp</A>
</OL>
<HR>
<A NAME="file1">
<H1>About.cpp 1/46</H1>
[<A HREF="#top">top</A>][prev][<A HREF="#file2">next</A>]
<PRE>
<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Code Templates for Programming Contests
</FONT></I><I><FONT COLOR="#B22222">//    by Siwakorn Srisakaokul - ping128
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  The codes are from what I coded during programming contests 
</FONT></I><I><FONT COLOR="#B22222">//  and practice. Some codes are from Stanford University ACM Team 
</FONT></I><I><FONT COLOR="#B22222">//  Notebook (2011-12) (http://www.stanford.edu/~liszt90/acm/notebook.pdf) 
</FONT></I><I><FONT COLOR="#B22222">//  and http://e-maxx.ru/algo/
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  (gen command: enscript -tCodeTemplate\ for\ Competitive\ Programming -E
</FONT></I><I><FONT COLOR="#B22222">//                --color -whtml --toc -pCodeTemplate.html *.cpp */*.cpp)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////////
</FONT></I></PRE>
<HR>
<A NAME="file2">
<H1>DefaultCode.cpp 2/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file1">prev</A>][<A HREF="#file3">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)(x).size())
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PB</FONT></B>(x) push_back(x)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MEMSET</FONT></B>(x,v) memset(x,v,sizeof(x))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (0x3f3f3f3f)

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; P2;
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> A, <B><FONT COLOR="#228B22">class</FONT></B> B&gt; <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> mina(A &amp;x, B y) {<B><FONT COLOR="#A020F0">return</FONT></B> (x &gt; y)?(x=y,1):0;}
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> A, <B><FONT COLOR="#228B22">class</FONT></B> B&gt; <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> maxa(A &amp;x, B y) {<B><FONT COLOR="#A020F0">return</FONT></B> (x &lt; y)?(x=y,1):0;}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {


    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file3">
<H1>Note.cpp 3/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file2">prev</A>][<A HREF="#file4">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  C++ Syntax
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Note:
</FONT></I><I><FONT COLOR="#B22222">//    alias g++=&quot;g++ -O2 -std=gnu++0x -Wall -Wshadow&quot;
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<I><FONT COLOR="#B22222">// Set Compare Function Example
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> shape_st {
    PII points[4];
    shape_st(){}
    shape_st(PII in[4]){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 4; i++ )
            points[i] = in[i];
        sort(points, points + 4);
    }

}Shape;

<B><FONT COLOR="#228B22">struct</FONT></B> ShapeCompare{
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>() (<B><FONT COLOR="#228B22">const</FONT></B> Shape s1, <B><FONT COLOR="#228B22">const</FONT></B> Shape s2) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 4; i++ ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(s1.points[i] != s2.points[i])
                <B><FONT COLOR="#A020F0">return</FONT></B> s1.points[i] &lt; s2.points[i];
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
};

set&lt;Shape, ShapeCompare&gt; setShape;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">char</FONT></B> temp[100];
    string temp2;
    <I><FONT COLOR="#B22222">// scan until reaching \n
</FONT></I>    scanf(<B><FONT COLOR="#BC8F8F">&quot;%[^\n]&quot;</FONT></B>, temp);
    <I><FONT COLOR="#B22222">// scan until reaching :
</FONT></I>    scanf(<B><FONT COLOR="#BC8F8F">&quot;%[^:]&quot;</FONT></B>, temp);
    <I><FONT COLOR="#B22222">// get a line for string
</FONT></I>    getline(cin, temp2);
    <I><FONT COLOR="#B22222">// int to string
</FONT></I>    cout &lt;&lt; to_string(1) &lt;&lt; endl;
    <I><FONT COLOR="#B22222">// string to int, stod, stol, stold, stoll
</FONT></I>    <I><FONT COLOR="#B22222">// int stoi (const string&amp;  str, size_t* idx = 0, int base = 10);
</FONT></I>    cout &lt;&lt; stoi(<B><FONT COLOR="#BC8F8F">&quot;1&quot;</FONT></B>) &lt;&lt; endl;
    <I><FONT COLOR="#B22222">// 1000 (base 2) -&gt; 8
</FONT></I>    cout &lt;&lt; stoi(<B><FONT COLOR="#BC8F8F">&quot;1000&quot;</FONT></B>, NULL, 2) &lt;&lt; endl;
    <I><FONT COLOR="#B22222">// string to char[]
</FONT></I>    string s = <B><FONT COLOR="#BC8F8F">&quot;123&quot;</FONT></B>;
    strcpy(temp, s.c_str());
    cout &lt;&lt; temp &lt;&lt; endl;
    <I><FONT COLOR="#B22222">// char[] to string
</FONT></I>    <B><FONT COLOR="#228B22">char</FONT></B> t[100] = <B><FONT COLOR="#BC8F8F">&quot;123&quot;</FONT></B>;
    cout &lt;&lt; string(t) &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file4">
<H1>algorithms/Hungarian.cpp 4/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file3">prev</A>][<A HREF="#file5">next</A>]
<PRE>
<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Hungarian Algorithm
</FONT></I><I><FONT COLOR="#B22222">//  Adopted from http://e-maxx.ru/algo/assignment_hungary
</FONT></I><I><FONT COLOR="#B22222">//      -- Minimizing the cost of assign m tasks to n people
</FONT></I><I><FONT COLOR="#B22222">//  O(n^2 m)
</FONT></I><I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> Hungarian {
<B><FONT COLOR="#228B22">public</FONT></B>:
    T min_cost;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; assignments;
    Hungarian() {}
    Hungarian(vector&lt;vector&lt;T&gt;&gt; cost, T inf = 1e9) { <I><FONT COLOR="#B22222">// zero-based index
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> n = cost.size();
        <B><FONT COLOR="#228B22">int</FONT></B> m = cost[0].size();
        assignments.resize(n);
        vector&lt;T&gt; u(n+1), v(m+1), p(m+1), way(m+1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++) {
            p[0] = i;
            <B><FONT COLOR="#228B22">int</FONT></B> j0 = 0;
            vector&lt;T&gt; minv (m+1, inf);
            vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; used (m+1, false);
            <B><FONT COLOR="#A020F0">do</FONT></B> {
                used[j0] = true;
                <B><FONT COLOR="#228B22">int</FONT></B> i0 = p[j0], j1 = 0;
                T delta = inf;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= m; j++) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (!used[j]) {
                        <B><FONT COLOR="#228B22">int</FONT></B> cur = cost[i0 - 1][j - 1] - u[i0] - v[j];
                        <B><FONT COLOR="#A020F0">if</FONT></B> (cur &lt; minv[j]) minv[j] = cur, way[j] = j0;
                        <B><FONT COLOR="#A020F0">if</FONT></B> (minv[j] &lt; delta) delta = minv[j], j1 = j;
                    }
                }
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt;= m; j++) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (used[j]) u[p[j]] += delta, v[j] -= delta;
                    <B><FONT COLOR="#A020F0">else</FONT></B> minv[j] -= delta;
                }
                j0 = j1;
            } <B><FONT COLOR="#A020F0">while</FONT></B> (p[j0] != 0);
            <B><FONT COLOR="#A020F0">do</FONT></B> {
                <B><FONT COLOR="#228B22">int</FONT></B> j1 = way[j0]; p[j0] = p[j1]; j0 = j1;
            } <B><FONT COLOR="#A020F0">while</FONT></B> (j0);
        }
        min_cost = -v[0];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= m; j++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (p[j]) assignments[p[j] - 1] = j - 1;
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> a[3][3] = {{10, 2, 3}, {5, 4, 3}, {5, 0, 2}};
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt;&gt; costs;
    REP(i, 3) costs.push_back(vector&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt;(a[i], a[i] + 3));
    Hungarian&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt; solver(costs);
    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Min cost: &quot;</FONT></B> &lt;&lt; solver.min_cost &lt;&lt; endl;
    REP(i, 3) cout &lt;&lt; solver.assignments[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cout &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file5">
<H1>algorithms/IntervalSet.cpp 5/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file4">prev</A>][<A HREF="#file6">next</A>]
<PRE>
<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Interval Set
</FONT></I><I><FONT COLOR="#B22222">//  All intervals are [a, b)
</FONT></I><I><FONT COLOR="#B22222">//  For Double type, use EPS to deal with precision error
</FONT></I><I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;set&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> IntervalSet {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;T, T&gt; Inter;

    set&lt;Inter&gt; S;
    IntervalSet () {}
    IntervalSet (vector&lt;Inter&gt; &amp;v) { <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : v) { assert(e.x &lt; e.y); S.insert(e); } }
    Inter get_intersection() {
        assert(SZ(S) &gt; 0);
        Inter ret = *S.begin();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : S) { ret.x = max(ret.x, e.x); ret.y = min(ret.y, e.y); }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> length() {
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ret = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : S) ret += e.y - e.x;
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> union_intervals() {
        <B><FONT COLOR="#A020F0">if</FONT></B> (SZ(S) == 0) <B><FONT COLOR="#A020F0">return</FONT></B> ;
        vector&lt;pair&lt;T, <B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; events;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : S) { events.push_back(make_pair(e.x, -1)); events.push_back(make_pair(e.y, 1)); }
        S.clear();
        sort(events.begin(), events.end());
        <B><FONT COLOR="#228B22">int</FONT></B> open_interval = 1;
        T last_open = events[0].x;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; SZ(events); i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (!open_interval) last_open = events[i].x;
            open_interval -= events[i].y;
            <B><FONT COLOR="#A020F0">if</FONT></B> (!open_interval) S.insert(Inter(last_open, events[i].x));
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> add(T a, T b) {
        assert(a &lt; b);
        Inter inter = Inter(a, b);
        <B><FONT COLOR="#A020F0">if</FONT></B> (!S.empty()) {
            <B><FONT COLOR="#228B22">auto</FONT></B> it1 = S.lower_bound(Inter(inter.x, inter.x));
             <B><FONT COLOR="#A020F0">if</FONT></B> (it1 != S.begin()) {
                <B><FONT COLOR="#228B22">auto</FONT></B> it2 = it1; it2--;
                <B><FONT COLOR="#A020F0">if</FONT></B> (it2-&gt;y &gt;= inter.x) { inter = union_overlap(inter, *it2); S.erase(it2); }
            }
            <B><FONT COLOR="#A020F0">while</FONT></B> (it1 != S.end()) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (inter.y &lt; it1-&gt;x) <B><FONT COLOR="#A020F0">break</FONT></B>;
                inter = union_overlap(inter, *it1);
                <B><FONT COLOR="#228B22">auto</FONT></B> temp = it1; temp++; S.erase(it1); it1 = temp;
            }
        }
        S.insert(inter);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> print() {
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;{&quot;</FONT></B>; <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : S) cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; (&quot;</FONT></B> &lt;&lt; e.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B> &lt;&lt; e.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>; cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; }&quot;</FONT></B> &lt;&lt; endl;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    Inter union_overlap(Inter a, Inter b) { <B><FONT COLOR="#A020F0">return</FONT></B> Inter(min(a.x, b.x), max(a.y, b.y)); }
};

<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B> () {
    IntervalSet&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; myset;
    myset.add(1, 2); myset.print();

    myset.add(2, 5); myset.print();
    myset.add(1, 2); myset.print();
    myset.add(5, 6); myset.print();

    myset.add(10, 12); myset.print();
    myset.add(7, 10); myset.print();
    myset.add(0, 20); myset.print();
    myset.add(20, 22); myset.print();
    cout &lt;&lt; myset.length() &lt;&lt; endl;

    vector&lt;PII&gt; v{PII(1, 2), PII(3, 5), PII(5, 7), PII(12, 15), PII(10, 13), PII(5, 8)};
    IntervalSet&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; myset2 (v);
    myset2.union_intervals();
    myset2.print();
    cout &lt;&lt; myset2.length() &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file6">
<H1>algorithms/Jumper.cpp 6/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file5">prev</A>][<A HREF="#file7">next</A>]
<PRE>
<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Jumper
</FONT></I><I><FONT COLOR="#B22222">//  Computes the jumper table
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://codeforces.com/contest/500/problem/E
</FONT></I><I><FONT COLOR="#B22222">//        http://codeforces.com/contest/500/submission/9440685
</FONT></I><I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (0x3f3f3f3f)

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PB</FONT></B>(x) push_back(x)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MEMSET</FONT></B>(x,v) memset(x,v,sizeof(x))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII; <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;PII, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII2;

<B><FONT COLOR="#228B22">class</FONT></B> Jumper {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N, H;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; P;
    Jumper (<B><FONT COLOR="#228B22">int</FONT></B> n, <B><FONT COLOR="#228B22">int</FONT></B> *parent) { <I><FONT COLOR="#B22222">// zero-based index
</FONT></I>        N = n;
        H = log2(N) + 2;
        P.resize(N, vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(H));
        REP(i, N) REP(j, H) P[i][j] = -1;
        REP(i, N) {
            assert(parent[i] &lt; N);
            P[i][0] = parent[i];
        }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> h = 1; h &lt; H; h++)
            REP(i, N)
                <B><FONT COLOR="#A020F0">if</FONT></B> (P[i][h - 1] != -1) {
                    P[i][h] = P[P[i][h - 1]][h - 1];
                    <I><FONT COLOR="#B22222">// Note for a value updating
</FONT></I>                    <I><FONT COLOR="#B22222">// V[i][h] = V[i][h - 1] + V[P[i][h - 1]][h - 1];
</FONT></I>                }
    }
};
</PRE>
<HR>
<A NAME="file7">
<H1>algorithms/MaxRecUnderHistogram.cpp 7/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file6">prev</A>][<A HREF="#file8">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">// Maximum Rectangle Under Histogram
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// # #    # # 
</FONT></I><I><FONT COLOR="#B22222">// ### -&gt; MMM -&gt; ans: 3
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stack&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> Value_t&gt;
<B><FONT COLOR="#228B22">class</FONT></B> MaxRecUnderHistogram {
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;Value_t, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PVI;
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">public</FONT></B>:
    Value_t get_max(vector&lt;Value_t&gt; &amp;h) {
        <B><FONT COLOR="#228B22">int</FONT></B> N = SZ(h); VI left(N), right(N);
        stack&lt;PVI&gt; l_sk;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> x = i;
            <B><FONT COLOR="#A020F0">while</FONT></B> (!l_sk.empty()) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (l_sk.top().x &gt;= h[i]) { x = l_sk.top().y; l_sk.pop(); }
                <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
            left[i] = x; l_sk.push(PVI(h[i], x));
        }
        stack&lt;PVI&gt; r_sk;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = N - 1; i &gt;= 0; i--) {
            <B><FONT COLOR="#228B22">int</FONT></B> x = i;
            <B><FONT COLOR="#A020F0">while</FONT></B> (!r_sk.empty()) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (r_sk.top().x &gt;= h[i]) { x = r_sk.top().y; r_sk.pop(); }
                <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
            right[i] = x; r_sk.push(PVI(h[i], x));
        }
        Value_t ret = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            ret = max(ret, h[i] * (right[i] - left[i] + 1));
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
};


<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    MaxRecUnderHistogram&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; max_his;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;({2, 1, 2});
    assert(max_his.get_max(v) == 3);

    v = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;({4, 2, 1, 2, 1, 4, 2, 3, 2, 2, 1, 9});
    assert(max_his.get_max(v) == 12);

    v = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;({4, 2, 1, 2, 0, 4, 2, 3, 2, 2, 1, 9});
    assert(max_his.get_max(v) == 10);

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file8">
<H1>algorithms/RangeMinimumQuery.cpp 8/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file7">prev</A>][<A HREF="#file9">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Range Minimum Query
</FONT></I><I><FONT COLOR="#B22222">//  &lt;O(N lg N, lg N or O(1)&gt;
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> RangeMinimumQuery {
<B><FONT COLOR="#228B22">public</FONT></B>:
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; M;
    vector&lt;T&gt; A;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    RangeMinimumQuery(T in[], <B><FONT COLOR="#228B22">int</FONT></B> n) {
        N = n;
        M = vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt;(N + 5);
        A = vector&lt;T&gt; (N + 5);
        <B><FONT COLOR="#228B22">int</FONT></B> b; <B><FONT COLOR="#A020F0">for</FONT></B> (b = 0; 1&lt;&lt;b &lt;= N; b++);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N + 5; i++)
            M[i] = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; (b);

        <I><FONT COLOR="#B22222">//initialize M for the intervals with length 1
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            M[i][0] = i;
            A[i] = in[i];
        }
        <I><FONT COLOR="#B22222">//compute values from smaller to bigger intervals
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; 1&lt;&lt;j &lt;= N; j++){
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i + (1&lt;&lt;j) - 1 &lt; N; i++)
                <B><FONT COLOR="#A020F0">if</FONT></B> (A[M[i][j - 1]] &lt; A[M[i + (1 &lt;&lt; (j - 1))][j - 1]]) M[i][j] = M[i][j - 1];
                <B><FONT COLOR="#A020F0">else</FONT></B> M[i][j] = M[i + (1 &lt;&lt; (j - 1))][j - 1];
        }
    }

    <I><FONT COLOR="#B22222">// returns min(A[left...right])
</FONT></I>    <I><FONT COLOR="#B22222">// also can be modified to return the index
</FONT></I>    T get_min(<B><FONT COLOR="#228B22">int</FONT></B> left, <B><FONT COLOR="#228B22">int</FONT></B> right) {
        <B><FONT COLOR="#228B22">int</FONT></B> num = right - left + 1;
        <B><FONT COLOR="#228B22">int</FONT></B> e = 1, k = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (e * 2 &lt;= num) e *= 2, k++;
        <B><FONT COLOR="#228B22">int</FONT></B> temp = right - e + 1;
        <B><FONT COLOR="#A020F0">if</FONT></B> (A[M[left][k]] &lt;= A[M[temp][k]]) <B><FONT COLOR="#A020F0">return</FONT></B> A[M[left][k]];
        <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> A[M[temp][k]];
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">bruteforce_rmq</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> *a, <B><FONT COLOR="#228B22">int</FONT></B> left, <B><FONT COLOR="#228B22">int</FONT></B> right) {
    <B><FONT COLOR="#228B22">int</FONT></B> ret = a[left];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = left + 1; i &lt;= right; i++) {
        ret = min(ret, a[i]);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N = 15;
    <B><FONT COLOR="#228B22">int</FONT></B> in[] = {-1, 4, 1, 6, 2, -10, 11, 3, 7, 100, 4, -123123123, 19, 1, -5};
    RangeMinimumQuery&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; rmq(in, N);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i; j &lt; N; j++) {
            assert(rmq.get_min(i, j) == bruteforce_rmq(in, i, j));
        }
    }
    <I><FONT COLOR="#B22222">/*
    assert(rmq.get_min(0, 0) == -1);
    assert(rmq.get_min(0, 9) == -10);
    assert(rmq.get_min(0, 2) == -1);
    assert(rmq.get_min(4, 9) == -10);
    assert(rmq.get_min(3, 3) == 6);
    assert(rmq.get_min(6, 8) == 3);
    */</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file9">
<H1>data_structure/CentroidDecomposition.cpp 9/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file8">prev</A>][<A HREF="#file10">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Centroid Decomposition
</FONT></I><I><FONT COLOR="#B22222">//  Complexity: N log N
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://codeforces.com/contest/321/problem/C
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PB</FONT></B>(x) push_back(x)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))

<B><FONT COLOR="#228B22">class</FONT></B> CentroidDecomposition {
<B><FONT COLOR="#228B22">public</FONT></B>:
    vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; removed;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    <B><FONT COLOR="#228B22">int</FONT></B> cd_root;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; cd_depths, cd_parents, tree_size;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; adj;
    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>    CentroidDecomposition (<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) {
        adj.resize(N); cd_depths.resize(N); removed.resize(N);
        tree_size.resize(N); cd_parents.resize(N);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) {
        adj[u].PB(v); adj[v].PB(u);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> decompose() {
        cd_root = decompose(0, 0);
        cd_parents[cd_root] = -1;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <I><FONT COLOR="#B22222">// Returns the centroid of the current subtree
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> decompose(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> dep) {
        <B><FONT COLOR="#228B22">int</FONT></B> center = find_center(at);
        cd_depths[center] = dep;
        removed[center] = true;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v : adj[center]) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (!removed[v]) {
                <B><FONT COLOR="#228B22">int</FONT></B> subroot = decompose(v, dep + 1);
                cd_parents[subroot] = center;
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> center;
    }
    <I><FONT COLOR="#B22222">// Center node is the node whose all subtrees' size is not greater than half of the whole tree
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> find_center(<B><FONT COLOR="#228B22">int</FONT></B> at) {
        cal_size(at, -1);
        <B><FONT COLOR="#228B22">int</FONT></B> limit = tree_size[at] / 2, par = -1;
        <B><FONT COLOR="#228B22">bool</FONT></B> found = false;
        <B><FONT COLOR="#A020F0">while</FONT></B> (!found) {
            found = true;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v : adj[at]) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (!removed[v] &amp;&amp; v != par &amp;&amp; tree_size[v] &gt; limit) {
                    found = false;
                    par = at, at = v;
                    <B><FONT COLOR="#A020F0">break</FONT></B>;
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> at;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> cal_size(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> par) {
        tree_size[at] = 1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v : adj[at]) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (v != par &amp;&amp; !removed[v]) {
                cal_size(v, at);
                tree_size[at] += tree_size[v];
            }
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    <B><FONT COLOR="#228B22">int</FONT></B> u, v;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;N);
    CentroidDecomposition cd(N);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N - 1; i++ ){
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;u, &amp;v); u--, v--;
        cd.add_edge(u, v);
    }
    cd.decompose();
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        printf(<B><FONT COLOR="#BC8F8F">&quot;%c &quot;</FONT></B>, cd.cd_depths[i] + <B><FONT COLOR="#BC8F8F">'A'</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file10">
<H1>data_structure/FenwickTree.cpp 10/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file9">prev</A>][<A HREF="#file11">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Fenwick Tree
</FONT></I><I><FONT COLOR="#B22222">//  An example of sum fenwick tree
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Note: use map&lt;int, T&gt; instead of vector&lt;T&gt; for Sparse Fenwick Tree
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> FenwickTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    vector&lt;T&gt; data;
    <B><FONT COLOR="#228B22">int</FONT></B> N;

    <I><FONT COLOR="#B22222">// Indices are 1-based.
</FONT></I>    FenwickTree(<B><FONT COLOR="#228B22">int</FONT></B> n) {
        N = n;
        data = vector&lt;T&gt;(N + 5);
    }

    <I><FONT COLOR="#B22222">// Return the prefix sum XXXXXXat....
</FONT></I>    T query(<B><FONT COLOR="#228B22">int</FONT></B> at) {
        T res = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = at; i; i -= (i &amp; (-i)))
            res += data[i];
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }

    <I><FONT COLOR="#B22222">// Add a value to a single element
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> at, T value) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = at; i &lt;= N; i += (i &amp; (-i)))
            data[i] += value;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    FenwickTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; tree(10);
    <B><FONT COLOR="#228B22">int</FONT></B> sum = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++) tree.update(i, i);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++) {
        sum += i;
        assert(tree.query(i) == sum);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++) tree.update(i, i * i);
    sum = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++) {
        sum += i * i + i;
        assert(tree.query(i) == sum);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
    
    

</PRE>
<HR>
<A NAME="file11">
<H1>data_structure/HeavyLightDecomposition.cpp 11/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file10">prev</A>][<A HREF="#file12">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Heavy Light Decompostion (only support a single tree node updating)
</FONT></I><I><FONT COLOR="#B22222">//  An example of how to solve a problem where there are 2 types of queries
</FONT></I><I><FONT COLOR="#B22222">//      1. change an edge's weight
</FONT></I><I><FONT COLOR="#B22222">//      2. find the max weight among all edges alone the path (u, v)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://www.spoj.com/problems/QTREE/
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstring&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Value_t&gt;
<B><FONT COLOR="#228B22">class</FONT></B> SegmentTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> segment_st {
        Value_t value;
        <B><FONT COLOR="#228B22">int</FONT></B> left, right;
    } TreeNode;

    vector&lt;TreeNode&gt; tree;
    <B><FONT COLOR="#228B22">int</FONT></B> N; <I><FONT COLOR="#B22222">// the number of data
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> tree_size; <I><FONT COLOR="#B22222">// the number of tree nodes
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; leaves; <I><FONT COLOR="#B22222">// leaves' indices
</FONT></I>    SegmentTree(<B><FONT COLOR="#228B22">int</FONT></B> n) { vector&lt;Value_t&gt; v(n); build_tree(n, v); }
    SegmentTree(<B><FONT COLOR="#228B22">int</FONT></B> n, vector&lt;Value_t&gt; &amp;v) { build_tree(n, v); }
    Value_t query(<B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr) { <B><FONT COLOR="#A020F0">return</FONT></B> query(1, ll, rr); }
    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t val) { internal_update(at, val); }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> build_tree(<B><FONT COLOR="#228B22">int</FONT></B> n, vector&lt;Value_t&gt; &amp;v){
        N = n; <B><FONT COLOR="#228B22">int</FONT></B> base = 1; <B><FONT COLOR="#A020F0">while</FONT></B> (base &lt; N) base *= 2; tree_size = base * 2;
        leaves.resize(N + 1); tree = vector&lt;TreeNode&gt; (tree_size);
        init(1, 1, n, v);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> init(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr, vector&lt;Value_t&gt; &amp;v) {
        tree[at].left = ll; tree[at].right = rr;
        <B><FONT COLOR="#A020F0">if</FONT></B>(ll == rr) { tree[at].value = v[ll - 1]; leaves[ll] = at; }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = (tree[at].left + tree[at].right) / 2;
            init(at * 2, tree[at].left, mid, v);
            init(at * 2 + 1, mid + 1, tree[at].right, v);
            update_up(at);
        }
    }

    <I><FONT COLOR="#B22222">// Return the node's value
</FONT></I>    Value_t node_to_value(<B><FONT COLOR="#228B22">int</FONT></B> at) {
        <B><FONT COLOR="#A020F0">return</FONT></B> tree[at].value;
    }

    <I><FONT COLOR="#B22222">// Recalculate the parent's value
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_up(<B><FONT COLOR="#228B22">int</FONT></B> at){
        tree[at].value = max(node_to_value(at * 2), node_to_value(at * 2 + 1));
    }

    <I><FONT COLOR="#B22222">// Update the result
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_result(Value_t &amp;res, Value_t val) {
        res = max(res, val);
    }

    <I><FONT COLOR="#B22222">// Update leaf's value for internal update
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_leaf_value(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t val) {
        tree[at].value = val;
    }

    Value_t query(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr){
        <B><FONT COLOR="#A020F0">if</FONT></B>(tree[at].left == ll &amp;&amp; tree[at].right == rr){
            <B><FONT COLOR="#A020F0">return</FONT></B> node_to_value(at);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = (tree[at].left + tree[at].right) / 2;
            Value_t res = 0;
            <B><FONT COLOR="#A020F0">if</FONT></B>(ll &lt;= mid) update_result(res, query(at * 2, ll, min(rr, mid)));
            <B><FONT COLOR="#A020F0">if</FONT></B>(rr &gt; mid) update_result(res, query(at * 2 + 1, max(mid + 1, ll), rr));
            <B><FONT COLOR="#A020F0">return</FONT></B> res;
        }
    }

    <B><FONT COLOR="#228B22">void</FONT></B> internal_update(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t val) {
        at = leaves[at];
        update_leaf_value(at, val);
        at /= 2;
        <B><FONT COLOR="#A020F0">while</FONT></B> (at) { update_up(at); at /= 2; }
    }
};


<I><FONT COLOR="#B22222">// Value's type, Max number of nodes, true if values on vertices
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> Value_t, <B><FONT COLOR="#228B22">int</FONT></B> MN, <B><FONT COLOR="#228B22">bool</FONT></B> VALUE_ON_VERTICES&gt;
<B><FONT COLOR="#228B22">class</FONT></B> HeavyLightDecompositon {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> ON_VERTICES = VALUE_ON_VERTICES;
    <B><FONT COLOR="#228B22">int</FONT></B> N, M; <I><FONT COLOR="#B22222">// number of vertices, edges
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> head[MN], weight[MN*2], to[MN*2], nxt[MN*2], ecnt;
    <B><FONT COLOR="#228B22">int</FONT></B> edge_id[MN]; <I><FONT COLOR="#B22222">// i-th edge (u,v,c) = (to[id], to[id^1], weight[id]), id = edge_id[i]
</FONT></I>    Value_t node_value[MN]; <I><FONT COLOR="#B22222">// node value is initialized in tree_setup
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> tree_size[MN], parent[MN], dep[MN], heaviest_child[MN];
    <B><FONT COLOR="#228B22">int</FONT></B> chain_head[MN], dfs_clock, num_chain;
    <B><FONT COLOR="#228B22">int</FONT></B> pos_on_base_array[MN]; <I><FONT COLOR="#B22222">// 1-based
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> vertex_on_base_array[MN]; <I><FONT COLOR="#B22222">// 1-based
</FONT></I>    vector&lt;Value_t&gt; base_array_value; <I><FONT COLOR="#B22222">// 0-based
</FONT></I>    <I><FONT COLOR="#B22222">// Vertices and Edges are 1-based indexed.
</FONT></I>    HeavyLightDecompositon(<B><FONT COLOR="#228B22">int</FONT></B> n) {
        N = n; ecnt = 2, M = 0; base_array_value.resize(N+5);
        memset(head, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(head));
    }
    <I><FONT COLOR="#B22222">// Returns base_array_value
</FONT></I>    vector&lt;Value_t&gt; decompose() {
        initialize_node_value(1, -1);
        internal_tree_setup(1, 0, 0);
        dfs_clock = 0; num_chain = 1;
        internal_dfs_heavy_edge(1, 1);
        <B><FONT COLOR="#A020F0">return</FONT></B> base_array_value;
    }
    <I><FONT COLOR="#B22222">// Initialize node's value ***
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> initialize_node_value(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> par) {
        node_value[u] = 1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = head[u]; p; p = nxt[p]) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = to[p]; <B><FONT COLOR="#A020F0">if</FONT></B> (v == par) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            initialize_node_value(v, u);
            <B><FONT COLOR="#A020F0">if</FONT></B> (ON_VERTICES) {  <I><FONT COLOR="#B22222">// Value on vertices case
</FONT></I>                node_value[u] += node_value[v];
            } <B><FONT COLOR="#A020F0">else</FONT></B> {            <I><FONT COLOR="#B22222">// Value on edges case
</FONT></I>                node_value[v] = weight[p];
            }
        }
    }
    <I><FONT COLOR="#B22222">// Set base_array_value[ind] by considering the current node
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> set_base_array_value(<B><FONT COLOR="#228B22">int</FONT></B> ind, <B><FONT COLOR="#228B22">int</FONT></B> cur_node) {
        base_array_value[ind] = node_value[cur_node];
    }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, <B><FONT COLOR="#228B22">int</FONT></B> c) {
        edge_id[++M] = ecnt;
        to[ecnt] = v; weight[ecnt] = c; nxt[ecnt] = head[u]; head[u] = ecnt++;
        to[ecnt] = u; weight[ecnt] = c; nxt[ecnt] = head[v]; head[v] = ecnt++;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> internal_tree_setup(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> par, <B><FONT COLOR="#228B22">int</FONT></B> depth) {
        <B><FONT COLOR="#228B22">int</FONT></B> maxsize = 0;
        parent[u] = par; dep[u] = depth;
        tree_size[u] = 1; heaviest_child[u] = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = head[u]; p; p = nxt[p]) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = to[p]; <B><FONT COLOR="#A020F0">if</FONT></B> (v == par) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            internal_tree_setup(v, u, depth + 1);
            tree_size[u] += tree_size[v];
            <B><FONT COLOR="#A020F0">if</FONT></B> (tree_size[v] &gt; maxsize) { maxsize = tree_size[v]; heaviest_child[u] = v; }
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> internal_dfs_heavy_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> chain_head_id) {
        pos_on_base_array[u] = ++dfs_clock; chain_head[u] = chain_head_id;
        vertex_on_base_array[dfs_clock] = u;
        set_base_array_value(dfs_clock - 1, u);
        <B><FONT COLOR="#A020F0">if</FONT></B>(heaviest_child[u])
            internal_dfs_heavy_edge(heaviest_child[u], chain_head_id); <I><FONT COLOR="#B22222">// Expand the chain
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> p = head[u]; p; p = nxt[p]) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = to[p]; <B><FONT COLOR="#A020F0">if</FONT></B>(v == parent[u] || v == heaviest_child[u]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            num_chain++; <I><FONT COLOR="#B22222">// Create a new chain
</FONT></I>            internal_dfs_heavy_edge(v, v);
        }
    }
};

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MAXN = 10010;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> INF = 0x7fffffff;
<B><FONT COLOR="#228B22">typedef</FONT></B> HeavyLightDecompositon&lt;<B><FONT COLOR="#228B22">int</FONT></B>, MAXN, false&gt; HLD;
<B><FONT COLOR="#228B22">typedef</FONT></B> SegmentTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; SegTree;

<I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">// Using HLD and Segment tree to process query and update
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////
</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">update_result</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> &amp;res, <B><FONT COLOR="#228B22">int</FONT></B> val) {
    res = max(res, val);
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">query</FONT></B>(SegTree &amp;seg_tree, HLD &amp;hld, <B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y) {
    <B><FONT COLOR="#228B22">int</FONT></B> res = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B>(hld.chain_head[x] != hld.chain_head[y]) {
        <B><FONT COLOR="#228B22">int</FONT></B> head_x = hld.chain_head[x], head_y = hld.chain_head[y];
        <B><FONT COLOR="#A020F0">if</FONT></B>(hld.dep[head_x] &lt; hld.dep[head_y]) swap(x, y), swap(head_x, head_y);
        update_result(res, seg_tree.query(hld.pos_on_base_array[head_x],
                                          hld.pos_on_base_array[x]));
        x = hld.parent[head_x];
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(hld.dep[x] &gt; hld.dep[y]) swap(x, y);
    <B><FONT COLOR="#228B22">int</FONT></B> from = hld.pos_on_base_array[x] + (hld.ON_VERTICES == false);
    <B><FONT COLOR="#228B22">int</FONT></B> to = hld.pos_on_base_array[y];
    update_result(res, seg_tree.query(from, to));
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">update</FONT></B>(SegTree &amp;seg_tree, HLD &amp;hld, <B><FONT COLOR="#228B22">int</FONT></B> e, <B><FONT COLOR="#228B22">int</FONT></B> y) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (hld.ON_VERTICES) { <I><FONT COLOR="#B22222">// Value on vertices
</FONT></I>        seg_tree.update(hld.pos_on_base_array[e], y);
    } <B><FONT COLOR="#A020F0">else</FONT></B> {               <I><FONT COLOR="#B22222">// Value on edges
</FONT></I>        e = hld.edge_id[e];
        <B><FONT COLOR="#228B22">int</FONT></B> u = hld.to[e], v = hld.to[e ^ 1];
        <B><FONT COLOR="#A020F0">if</FONT></B>(hld.parent[v] == u) swap(u, v);
        <I><FONT COLOR="#B22222">// Update the lower end of this edge e
</FONT></I>        seg_tree.update(hld.pos_on_base_array[u], y);
    }
}

<B><FONT COLOR="#228B22">char</FONT></B> str[15];
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> n;
    <B><FONT COLOR="#228B22">int</FONT></B> T; scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;T);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> t = 1; t &lt;= T; ++t) {
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;n);
        HLD hld(n);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; n; ++i) {
            <B><FONT COLOR="#228B22">int</FONT></B> u, v, c;
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %d&quot;</FONT></B>, &amp;u, &amp;v, &amp;c);
            hld.add_edge(u, v, c);
        }
        vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; base_array_value = hld.decompose();
        SegTree seg_tree(n, base_array_value);
        <B><FONT COLOR="#A020F0">while</FONT></B>(scanf(<B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, str) &amp;&amp; *str != <B><FONT COLOR="#BC8F8F">'D'</FONT></B>) {
            <B><FONT COLOR="#228B22">int</FONT></B> x, y;
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;x, &amp;y);
            <B><FONT COLOR="#A020F0">if</FONT></B>(*str == <B><FONT COLOR="#BC8F8F">'C'</FONT></B>) update(seg_tree, hld, x, y);
            <B><FONT COLOR="#A020F0">else</FONT></B> printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, query(seg_tree, hld, x, y));
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file12">
<H1>data_structure/LazySegmentTree.cpp 12/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file11">prev</A>][<A HREF="#file13">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Lazy Segment Tree (lazy propagation)
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> LazySegmentTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> Update_t;
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> Query_t;
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> Value_t;
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> Lazy_t;

    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> tree_st {
        Value_t value;
        Lazy_t lazy;
        <B><FONT COLOR="#228B22">int</FONT></B> l, r;
    } TreeNode;
    vector&lt;TreeNode&gt; tree;
    <B><FONT COLOR="#228B22">int</FONT></B> N; <I><FONT COLOR="#B22222">// the number of data
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> tree_size; <I><FONT COLOR="#B22222">// the number of tree nodes
</FONT></I>    LazySegmentTree() {}
    LazySegmentTree(<B><FONT COLOR="#228B22">int</FONT></B> n) { build_tree(n); }
    Query_t query(<B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr) { <B><FONT COLOR="#A020F0">return</FONT></B> value_to_result(query(1, ll, rr)); }
    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr, Update_t val) { update(1, ll, rr, val); }
<B><FONT COLOR="#228B22">private</FONT></B>:
    Lazy_t DEF_LAZY = 0;
    Value_t DEF_VALUE = 0;
    <I><FONT COLOR="#B22222">// Initialize node
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> initialize_node (<B><FONT COLOR="#228B22">int</FONT></B> at) {
        tree[at].lazy = DEF_LAZY;
        tree[at].value = DEF_VALUE;
    }
    <I><FONT COLOR="#B22222">// Node's value to query's result
</FONT></I>    Query_t value_to_result(Value_t val) {
        <B><FONT COLOR="#A020F0">return</FONT></B> val;
    }
    <I><FONT COLOR="#B22222">// Return node's value (considering the given node's value and lazy)
</FONT></I>    Value_t node_to_value(<B><FONT COLOR="#228B22">int</FONT></B> at) {
        <B><FONT COLOR="#A020F0">return</FONT></B> tree[at].value + (tree[at].r - tree[at].l + 1) * tree[at].lazy;
    }
    <I><FONT COLOR="#B22222">// Update node's lazy
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_lazy(<B><FONT COLOR="#228B22">int</FONT></B> at, Update_t up_val) {
        tree[at].lazy += up_val;
    }
    <I><FONT COLOR="#B22222">// Recalculate the parent's value without considering the parent's lazy
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_up(<B><FONT COLOR="#228B22">int</FONT></B> at){
        tree[at].value = node_to_value(at * 2) + node_to_value(at * 2 + 1);
    }
    <I><FONT COLOR="#B22222">// Update children's lazy
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_down(<B><FONT COLOR="#228B22">int</FONT></B> at){
        <B><FONT COLOR="#A020F0">if</FONT></B> (tree[at].lazy == DEF_LAZY) <B><FONT COLOR="#A020F0">return</FONT></B> ; <I><FONT COLOR="#B22222">// no need to update
</FONT></I>        tree[at * 2].lazy += tree[at].lazy;
        tree[at * 2 + 1].lazy += tree[at].lazy;
        tree[at].lazy = DEF_LAZY;
    }
    <I><FONT COLOR="#B22222">// Update the result
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_result(Value_t &amp;res, Value_t q) {
        res += q;
    }
    Value_t query(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr){
        <B><FONT COLOR="#A020F0">if</FONT></B> (ll &gt; tree[at].r || rr &lt; tree[at].l) <B><FONT COLOR="#A020F0">return</FONT></B> DEF_VALUE;
        <B><FONT COLOR="#A020F0">if</FONT></B> (ll &lt;= tree[at].l &amp;&amp; tree[at].r &lt;= rr) {
            <B><FONT COLOR="#A020F0">return</FONT></B> node_to_value(at);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            Value_t res = DEF_VALUE;
            update_down(at);
            update_result(res, query(at * 2, ll, rr));
            update_result(res, query(at * 2 + 1, ll, rr));
            update_up(at);
            <B><FONT COLOR="#A020F0">return</FONT></B> res;
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr, Update_t up_val){
        <B><FONT COLOR="#A020F0">if</FONT></B> (ll &gt; tree[at].r || rr &lt; tree[at].l) <B><FONT COLOR="#A020F0">return</FONT></B> ;
        <B><FONT COLOR="#A020F0">if</FONT></B> (ll &lt;= tree[at].l &amp;&amp; tree[at].r &lt;= rr) {
            update_lazy(at, up_val);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            update_down(at);
            update(at * 2, ll, rr, up_val);
            update(at * 2 + 1, ll, rr, up_val);
            update_up(at);
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> build_tree(<B><FONT COLOR="#228B22">int</FONT></B> n) {
        N = n; <B><FONT COLOR="#228B22">int</FONT></B> base = 1; <B><FONT COLOR="#A020F0">while</FONT></B> (base &lt; N) base *= 2; tree_size = base * 2;
        tree = vector&lt;TreeNode&gt; (tree_size);
        init(1, 1, n);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> init(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr) {
        tree[at].l = ll; tree[at].r = rr;
        initialize_node(at);
        <B><FONT COLOR="#A020F0">if</FONT></B> (ll &lt; rr) {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = (tree[at].l + tree[at].r) &gt;&gt; 1;
            init(at * 2, tree[at].l, mid);
            init(at * 2 + 1, mid + 1, tree[at].r);
            update_up(at);
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    <B><FONT COLOR="#228B22">int</FONT></B> N = 7;
    LazySegmentTree tree(N);
    tree.update(1, 7, 4);
    assert(tree.query(1, 7) == 28);
    tree.update(3, 5, 2);
    assert(tree.query(3, 3) == 6);
    assert(tree.query(1, 7) == 34);
    assert(tree.query(5, 6) == 10);
    assert(tree.query(1, 4) == 20);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file13">
<H1>data_structure/PersistentTree.cpp 13/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file12">prev</A>][<A HREF="#file14">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Persistent Segment Tree
</FONT></I><I><FONT COLOR="#B22222">//  Single-element updating, interval query
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Problem: query: return the k-th smallest number in a given interval
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://www.spoj.com/problems/MKTHNUM/
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;map&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PB</FONT></B>(x) push_back(x)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))

<B><FONT COLOR="#228B22">class</FONT></B> PersistentTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> Node {
        Node *l, *r;
        <B><FONT COLOR="#228B22">int</FONT></B> cnt;
        Node () { l = r = NULL; cnt = 0; }
        Node (Node *ll, Node *rr) {
            l = ll, r = rr;
            update_up();
        }
        <I><FONT COLOR="#B22222">// Update node's value
</FONT></I>        <B><FONT COLOR="#228B22">void</FONT></B> update_up() {
            cnt = 0;
            <B><FONT COLOR="#A020F0">if</FONT></B> (l) cnt += l-&gt;cnt;
            <B><FONT COLOR="#A020F0">if</FONT></B> (r) cnt += r-&gt;cnt;
        }
    } *NPtr;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;NPtr&gt; roots;
    PersistentTree(<B><FONT COLOR="#228B22">int</FONT></B> n) {
        N = n;
        roots.PB(build(1, N));
    }
    <B><FONT COLOR="#228B22">void</FONT></B> update_leaf(NPtr prev, NPtr now) {
        now-&gt;cnt = prev-&gt;cnt + 1;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> at) {
        roots.PB(update(roots.back(), 1, N, at));
    }
    <B><FONT COLOR="#228B22">int</FONT></B> query(<B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">int</FONT></B> val) {
        <B><FONT COLOR="#A020F0">return</FONT></B> query(roots[l - 1], roots[r], 1, N, val);
    }
    <B><FONT COLOR="#228B22">int</FONT></B> query(NPtr left_t, NPtr right_t, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">int</FONT></B> val) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (l == r) {
            <B><FONT COLOR="#A020F0">return</FONT></B> l;
        }
        <B><FONT COLOR="#228B22">int</FONT></B> m = (l + r) &gt;&gt; 1;
        <B><FONT COLOR="#228B22">int</FONT></B> cnt = right_t-&gt;l-&gt;cnt - left_t-&gt;l-&gt;cnt;
        <B><FONT COLOR="#A020F0">if</FONT></B> (val &lt;= cnt) <B><FONT COLOR="#A020F0">return</FONT></B> query(left_t-&gt;l, right_t-&gt;l, l, m, val);
        val -= cnt;
        <B><FONT COLOR="#A020F0">return</FONT></B> query(left_t-&gt;r, right_t-&gt;r, m + 1, r, val);
    }
    NPtr update(NPtr ptree, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">int</FONT></B> at) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (l &lt;= at &amp;&amp; at &lt;= r) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (l == r) {
                NPtr node = <B><FONT COLOR="#A020F0">new</FONT></B> Node();
                update_leaf(ptree, node);
                <B><FONT COLOR="#A020F0">return</FONT></B> node;
            }
            <B><FONT COLOR="#228B22">int</FONT></B> m = (l + r) &gt;&gt; 1;
            <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">new</FONT></B> Node(update(ptree-&gt;l, l, m, at), update(ptree-&gt;r, m + 1, r, at));
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> ptree;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    NPtr build(<B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (l == r) {
            <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">new</FONT></B> Node();
        }
        <B><FONT COLOR="#228B22">int</FONT></B> m = (l + r) &gt;&gt; 1;
        <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">new</FONT></B> Node(build(l, m), build(m + 1, r));
    }
};

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXN</FONT> (100005)

map&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; order;
<B><FONT COLOR="#228B22">int</FONT></B> inversed_order[MAXN];

<B><FONT COLOR="#228B22">int</FONT></B> in[MAXN];

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N, M;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;N, &amp;M);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) {
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;in[i]);
        order[in[i]]++;
    }
    N = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (map&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt;::iterator it = order.begin(); it != order.end(); it++) {
        it-&gt;second = ++N;
        inversed_order[N] = it-&gt;first;
    }
    PersistentTree tree(N);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) {
        tree.update(order[in[i]]);
    }
    <B><FONT COLOR="#228B22">int</FONT></B> l, r, k;
    REP(m, M) {
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %d&quot;</FONT></B>, &amp;l, &amp;r, &amp;k);
        <B><FONT COLOR="#228B22">int</FONT></B> res = tree.query(l, r, k);
        printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, inversed_order[res]);
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file14">
<H1>data_structure/SegmentTree.cpp 14/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file13">prev</A>][<A HREF="#file15">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Segment Tree
</FONT></I><I><FONT COLOR="#B22222">//  Only work for single element updating
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Value_t&gt;
<B><FONT COLOR="#228B22">class</FONT></B> SegmentTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> segment_st {
        Value_t value;
        <B><FONT COLOR="#228B22">int</FONT></B> l, r;
    } TreeNode;

    vector&lt;TreeNode&gt; tree;
    <B><FONT COLOR="#228B22">int</FONT></B> N; <I><FONT COLOR="#B22222">// the number of data
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> tree_size; <I><FONT COLOR="#B22222">// the number of tree nodes
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; leaves; <I><FONT COLOR="#B22222">// leaves' indices
</FONT></I>    SegmentTree(<B><FONT COLOR="#228B22">int</FONT></B> n) { build_tree(n); }
    Value_t query(<B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr) { <B><FONT COLOR="#A020F0">return</FONT></B> query(1, ll, rr); }
    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t val) { internal_update(at, val); }
<B><FONT COLOR="#228B22">private</FONT></B>:
    Value_t DEF_VALUE = 0;
    <I><FONT COLOR="#B22222">// Initialize node
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> initialize_node (<B><FONT COLOR="#228B22">int</FONT></B> at) {
        tree[at].value = DEF_VALUE;
    }
    <I><FONT COLOR="#B22222">// Recalculate the parent's value
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_up(<B><FONT COLOR="#228B22">int</FONT></B> at){
        <B><FONT COLOR="#228B22">int</FONT></B> left = at + at;
        <B><FONT COLOR="#228B22">int</FONT></B> right = at + at + 1;
        tree[at].value = tree[left].value + tree[right].value;
    }
    <I><FONT COLOR="#B22222">// Update the result
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_result(Value_t &amp;res, Value_t val) {
        res += val;
    }
    <I><FONT COLOR="#B22222">// Update leaf's value for internal update
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_leaf_value(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t &amp;val) {
        tree[at].value += val;
    }
    Value_t query(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr){
        <B><FONT COLOR="#A020F0">if</FONT></B> (ll &gt; tree[at].r || rr &lt; tree[at].l) <B><FONT COLOR="#A020F0">return</FONT></B> DEF_VALUE;
        <B><FONT COLOR="#A020F0">if</FONT></B> (ll &lt;= tree[at].l &amp;&amp; tree[at].r &lt;= rr) {
            <B><FONT COLOR="#A020F0">return</FONT></B> tree[at].value;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            Value_t res = DEF_VALUE;
            update_result(res, query(at + at, ll, rr));
            update_result(res, query(at + at + 1, ll, rr));
            <B><FONT COLOR="#A020F0">return</FONT></B> res;
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> internal_update(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t &amp;val) {
        at = leaves[at];
        update_leaf_value(at, val);
        at &gt;&gt;= 1;
        <B><FONT COLOR="#A020F0">while</FONT></B> (at) { update_up(at); at &gt;&gt;= 1; }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> build_tree(<B><FONT COLOR="#228B22">int</FONT></B> n) {
        N = n; <B><FONT COLOR="#228B22">int</FONT></B> base = 1; <B><FONT COLOR="#A020F0">while</FONT></B> (base &lt; N) base &lt;&lt;= 1; tree_size = base &lt;&lt; 1;
        leaves.resize(N + 1); tree = vector&lt;TreeNode&gt; (tree_size);
        init(1, 1, n);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> init(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr) {
        tree[at].l = ll; tree[at].r = rr;
        initialize_node(at);
        <B><FONT COLOR="#A020F0">if</FONT></B>(ll == rr) { leaves[ll] = at; }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = (tree[at].l + tree[at].r) &gt;&gt; 1;
            init(at + at, tree[at].l, mid);
            init(at + at + 1, mid + 1, tree[at].r);
            update_up(at);
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    <B><FONT COLOR="#228B22">int</FONT></B> N = 7;
    SegmentTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; tree(N);
    <B><FONT COLOR="#228B22">int</FONT></B> sum = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) {
        tree.update(i, i);
        sum += i;
        assert(tree.query(1, N) == sum);
        assert(tree.query(i, i) == i);
    }
    sum += 10;
    tree.update(4, 10);
    assert(tree.query(1, N) == sum);
    assert(tree.query(1, 3) == 6);
    assert(tree.query(4, 5) == 19);
    assert(tree.query(5, 6) == 11);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file15">
<H1>data_structure/SplayTree.cpp 15/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file14">prev</A>][<A HREF="#file16">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Splay Tree with lazy propagation
</FONT></I><I><FONT COLOR="#B22222">//      - values on left subtree &lt;= x
</FONT></I><I><FONT COLOR="#B22222">//      - values on right subtree &gt; x
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))

<I><FONT COLOR="#B22222">// left: &lt;= x
</FONT></I><I><FONT COLOR="#B22222">// right: &gt; x
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> SplayTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">struct</FONT></B> Node {
        Node *left, *right, *par;
        <B><FONT COLOR="#228B22">int</FONT></B> sz;
        T key;
        Node () {}
        Node (T v) {
            left = right = par = NULL;
            sz = 1;
            key = v;
        }
        <B><FONT COLOR="#228B22">void</FONT></B> push() {}
    };
    <B><FONT COLOR="#228B22">typedef</FONT></B> Node *NPtr;
    NPtr root;
    SplayTree() { root = NULL; }
    SplayTree(NPtr r) { root = r; <B><FONT COLOR="#A020F0">if</FONT></B>(root) root-&gt;par = NULL; }
    <B><FONT COLOR="#228B22">void</FONT></B> update_node (NPtr x) {
        x-&gt;sz = (x-&gt;left == NULL ? 0 : x-&gt;left-&gt;sz) +
                (x-&gt;right == NULL ? 0 : x-&gt;right-&gt;sz) + 1;
    }
    <I><FONT COLOR="#B22222">// Rotate x up one level
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> rotate(NPtr x) {
        assert(x-&gt;par != NULL);
        NPtr p_x = x-&gt;par;
        NPtr pp_x = x-&gt;par-&gt;par;
        p_x-&gt;push();
        x-&gt;push();
        x-&gt;par = pp_x;
        <B><FONT COLOR="#A020F0">if</FONT></B> (pp_x) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (pp_x-&gt;left == p_x) pp_x-&gt;left = x;
            <B><FONT COLOR="#A020F0">else</FONT></B> pp_x-&gt;right = x;
        }
        p_x-&gt;par = x;
        <B><FONT COLOR="#A020F0">if</FONT></B> (x == p_x-&gt;left) { <I><FONT COLOR="#B22222">// x is the left child
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (x-&gt;right) x-&gt;right-&gt;par = p_x;
            p_x-&gt;left = x-&gt;right;
            x-&gt;right = p_x;
        } <B><FONT COLOR="#A020F0">else</FONT></B> { <I><FONT COLOR="#B22222">// x is the right child
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (x-&gt;left) x-&gt;left-&gt;par = p_x;
            p_x-&gt;right = x-&gt;left;
            x-&gt;left = p_x;
        }
        update_node(p_x);
        update_node(x);
    }
    <I><FONT COLOR="#B22222">// If p == NULL, splay to the root. Otherwise, splay to the child of p
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> splay(NPtr x) { splay(x, NULL); }
    <B><FONT COLOR="#228B22">void</FONT></B> splay(NPtr x, NPtr p) {
        <B><FONT COLOR="#A020F0">while</FONT></B> (x-&gt;par != p) {
            NPtr p_x = x-&gt;par;
            NPtr pp_x = x-&gt;par-&gt;par;
            <B><FONT COLOR="#A020F0">if</FONT></B> (pp_x == p) <I><FONT COLOR="#B22222">// zig
</FONT></I>                rotate(x);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((pp_x-&gt;left == p_x) == (p_x-&gt;left == x)) <I><FONT COLOR="#B22222">// zig-zig
</FONT></I>                rotate(p_x), rotate(x);
            <B><FONT COLOR="#A020F0">else</FONT></B> <I><FONT COLOR="#B22222">// zig-zag
</FONT></I>                rotate(x), rotate(x);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (!p) root = x;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> splayMax() {
        NPtr temp = root;
        <B><FONT COLOR="#A020F0">while</FONT></B> (temp &amp;&amp; temp-&gt;right) temp = temp-&gt;right;
        <B><FONT COLOR="#A020F0">if</FONT></B> (temp) splay(temp);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> insert(T key) {
        NPtr n = <B><FONT COLOR="#A020F0">new</FONT></B> Node(key);
        <B><FONT COLOR="#A020F0">if</FONT></B> (!root) {
            root = n;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            NPtr t = root;
            <B><FONT COLOR="#A020F0">while</FONT></B>(t) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (key &gt; t-&gt;key) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (t-&gt;right) t = t-&gt;right;
                    <B><FONT COLOR="#A020F0">else</FONT></B> {
                        t-&gt;right = n;
                        <B><FONT COLOR="#A020F0">break</FONT></B>;
                    }
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (t-&gt;left) t = t-&gt;left;
                    <B><FONT COLOR="#A020F0">else</FONT></B> {
                        t-&gt;left = n;
                        <B><FONT COLOR="#A020F0">break</FONT></B>;
                    }
                }
            }
            n-&gt;par = t;
        }
        splay(n, NULL);
    }
    <B><FONT COLOR="#228B22">int</FONT></B> size() { <B><FONT COLOR="#A020F0">return</FONT></B> root ? root-&gt;sz : 0; }
    <B><FONT COLOR="#228B22">void</FONT></B> join(SplayTree&lt;T&gt; &amp;tree) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (root) {
            splayMax();
            root-&gt;right = tree.root;
            <B><FONT COLOR="#A020F0">if</FONT></B> (tree.root) tree.root-&gt;par = root;
            update_node(root);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            root = tree.root;
        }
    }

    <B><FONT COLOR="#228B22">void</FONT></B> erase(T k) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (contains(k)) {
            SplayTree&lt;T&gt; lc(root-&gt;left);
            SplayTree&lt;T&gt; rc(root-&gt;right);
            <B><FONT COLOR="#A020F0">delete</FONT></B> root;
            root = lc.root;
            join(rc);
        }
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> contains(T k) {
        NPtr t = find(root, k);
        <B><FONT COLOR="#A020F0">if</FONT></B> (t) {
            splay(t);
            <B><FONT COLOR="#A020F0">return</FONT></B> t-&gt;key == k;
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    T get_kth_smallest(<B><FONT COLOR="#228B22">int</FONT></B> k) {
        assert(k &gt;= 1 &amp;&amp; k &lt;= size());
        k--;
        NPtr t = root;
        <B><FONT COLOR="#A020F0">while</FONT></B> (t) {
            <B><FONT COLOR="#228B22">int</FONT></B> x = size(t-&gt;left);
            <B><FONT COLOR="#A020F0">if</FONT></B> (k == x) {
                splay(t);
                <B><FONT COLOR="#A020F0">return</FONT></B> t-&gt;key;
            }
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (k &lt; x) t = t-&gt;left;
            <B><FONT COLOR="#A020F0">else</FONT></B> {
                k -= x + 1;
                t = t-&gt;right;
            }
        }
        assert(false);
    }
    <I><FONT COLOR="#B22222">// Return the number of nodes whose key &lt;= k
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> get_rank(T k) {
        NPtr t = find(root, k);
        <B><FONT COLOR="#A020F0">if</FONT></B> (t == NULL) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            splay(t);
            <B><FONT COLOR="#A020F0">return</FONT></B> size(root-&gt;left) + 1;
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> print() {
        <B><FONT COLOR="#A020F0">if</FONT></B> (root) {
            print(root);
            cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt; root-&gt;sz &lt;&lt; endl;
            printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> print(NPtr t) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (t) {
            print(t-&gt;left);
            printf(<B><FONT COLOR="#BC8F8F">&quot;%d,&quot;</FONT></B>, t-&gt;key);
            print(t-&gt;right);
        }
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> size(NPtr t) { <B><FONT COLOR="#A020F0">return</FONT></B> t ? t-&gt;sz : 0; }
    <I><FONT COLOR="#B22222">// Return the right most node whose key &lt;= k of the subtree t
</FONT></I>    NPtr find(NPtr t, T k) {
        NPtr ret = NULL;
        <B><FONT COLOR="#A020F0">while</FONT></B>(t) {
            t-&gt;push();
            <B><FONT COLOR="#A020F0">if</FONT></B> (k == t-&gt;key) <B><FONT COLOR="#A020F0">return</FONT></B> t;
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (k &lt; t-&gt;key) t = t-&gt;left;
            <B><FONT COLOR="#A020F0">else</FONT></B> {
                ret = t;
                t = t-&gt;right;
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    SplayTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; tree;
    srand(time(NULL));
    REP(i, 20) {
        <B><FONT COLOR="#228B22">int</FONT></B> x = rand() % 20;
        printf(<B><FONT COLOR="#BC8F8F">&quot;Insert: %d\n&quot;</FONT></B>, x);
        tree.insert(x);
        tree.print();
    }
    REP(i, 10) {
        <B><FONT COLOR="#228B22">int</FONT></B> x = rand() % 20;
        printf(<B><FONT COLOR="#BC8F8F">&quot;Erase: %d\n&quot;</FONT></B>, x);
        tree.erase(x);
        tree.print();
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file16">
<H1>data_structure/Treap.cpp 16/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file15">prev</A>][<A HREF="#file17">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Treap - randomized binary search tree
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PB</FONT></B>(x) push_back(x)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MEMSET</FONT></B>(x,v) memset(x,v,sizeof(x))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII; <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;PII, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII2;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> Treap {
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> Treapnode {
        T key; <I><FONT COLOR="#B22222">// (x = key, y = id) can differentiate the duplicate keys
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> fix;
        Treapnode *left, *right;
        <B><FONT COLOR="#228B22">int</FONT></B> sz;
        LL sum; <I><FONT COLOR="#B22222">// sum of all keys
</FONT></I>        Treapnode() { left = right = NULL; sz = 0; sum = 0; }
    } *NPtr;
<B><FONT COLOR="#228B22">public</FONT></B>:
    NPtr root;
    Treap() { root = NULL; srand(time(NULL)); }
    <B><FONT COLOR="#228B22">void</FONT></B> insert(T key) { root = insert(root, key); }
    <B><FONT COLOR="#228B22">int</FONT></B> size() { <B><FONT COLOR="#A020F0">return</FONT></B> size(root); }
    <B><FONT COLOR="#228B22">int</FONT></B> size(Treapnode node) { <B><FONT COLOR="#A020F0">return</FONT></B> (node == NULL) ? 0 : node-&gt;sz; }
    T find_ksmallest(<B><FONT COLOR="#228B22">int</FONT></B> k) {
        assert(k &gt;= 1 &amp;&amp; k &lt;= <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root-&gt;sz);
        <B><FONT COLOR="#A020F0">return</FONT></B> find_ksmallest(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root, k);
    }
    LL find_ksmallest_sum(<B><FONT COLOR="#228B22">int</FONT></B> k) {
        assert(k &gt;= 1 &amp;&amp; k &lt;= <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root-&gt;sz);
        <B><FONT COLOR="#A020F0">return</FONT></B> find_ksmallest_sum(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root, k);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> remove(T key) { root = remove(root, key); }
    <B><FONT COLOR="#228B22">bool</FONT></B> find(T key) { <B><FONT COLOR="#A020F0">return</FONT></B> find(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root, key); }
<B><FONT COLOR="#228B22">private</FONT></B>:
    NPtr insert(NPtr node, T key) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node == NULL) {
            node = <B><FONT COLOR="#A020F0">new</FONT></B> Treapnode();
            node-&gt;left = node-&gt;right = NULL;
            node-&gt;key = key;
            node-&gt;fix = rand();
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;key == key) {
                <I><FONT COLOR="#B22222">// do nothing
</FONT></I>            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;key &gt; key) {
                node-&gt;left = insert(node-&gt;left, key);
                <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left-&gt;fix &gt; node-&gt;fix)
                    rotate_right(node);
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                node-&gt;right = insert(node-&gt;right, key);
                <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;right-&gt;fix &gt; node-&gt;fix)
                    rotate_left(node);
            }
        }
        update_size(node);
        update_sum(node);
        <B><FONT COLOR="#A020F0">return</FONT></B> node;
    }

    NPtr remove(NPtr node, T key) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (key &gt; node-&gt;key) {
                node-&gt;right = remove(node-&gt;right, key);
                update_size(node);
                update_sum(node);
            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (key &lt; node-&gt;key) {
                node-&gt;left = remove(node-&gt;left, key);
                update_size(node);
                update_sum(node);
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) {
                    <B><FONT COLOR="#A020F0">delete</FONT></B> node;
                    node = NULL;
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left == NULL) {
                    NPtr temp = node-&gt;right;
                    <B><FONT COLOR="#A020F0">delete</FONT></B> node;
                    node = temp;
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;right == NULL) {
                    NPtr temp = node-&gt;left;
                    <B><FONT COLOR="#A020F0">delete</FONT></B> node;
                    node = temp;
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left-&gt;fix &lt; node-&gt;right-&gt;fix) {
                        rotate_left(node);
                        node-&gt;left = remove(node-&gt;left, key);
                    } <B><FONT COLOR="#A020F0">else</FONT></B> {
                        rotate_right(node);
                        node-&gt;right = remove(node-&gt;right, key);
                    }
                    update_size(node);
                    update_sum(node);
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> node;
    }

    <B><FONT COLOR="#228B22">void</FONT></B> rotate_left(NPtr &amp;node) {
        NPtr temp;
        temp = node-&gt;right; node-&gt;right = temp-&gt;left;
        temp-&gt;left = node; node = temp;
        update_size(node-&gt;left); update_size(node);
        update_sum(node-&gt;left); update_sum(node);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> rotate_right(NPtr &amp;node) {
        NPtr temp;
        temp = node-&gt;left; node-&gt;left = temp-&gt;right;
        temp-&gt;right = node; node = temp;
        update_size(node-&gt;right); update_size(node);
        update_sum(node-&gt;right); update_sum(node);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> update_size(NPtr node) {
        node-&gt;sz = 1;
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left) node-&gt;sz += node-&gt;left-&gt;sz;
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;right) node-&gt;sz += node-&gt;right-&gt;sz;
    }

    <B><FONT COLOR="#228B22">void</FONT></B> update_sum(NPtr node) {
        node-&gt;sum = node-&gt;key.x;
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left) node-&gt;sum += node-&gt;left-&gt;sum;
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;right) node-&gt;sum += node-&gt;right-&gt;sum;
    }

    T find_ksmallest(NPtr node, <B><FONT COLOR="#228B22">int</FONT></B> k) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left == NULL) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (k == 1)
                <B><FONT COLOR="#A020F0">return</FONT></B> node-&gt;key;
            <B><FONT COLOR="#A020F0">return</FONT></B> find_ksmallest(node-&gt;right, k - 1);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> num_left = node-&gt;left-&gt;sz;
            <B><FONT COLOR="#A020F0">if</FONT></B> (k &lt;= num_left)
                <B><FONT COLOR="#A020F0">return</FONT></B> find_ksmallest(node-&gt;left, k);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (k == num_left + 1)
                <B><FONT COLOR="#A020F0">return</FONT></B> node-&gt;key;
            <B><FONT COLOR="#A020F0">else</FONT></B>
                <B><FONT COLOR="#A020F0">return</FONT></B> find_ksmallest(node-&gt;right, k - num_left - 1);
        }
    }

    LL find_ksmallest_sum(NPtr node, <B><FONT COLOR="#228B22">int</FONT></B> k) {
        LL res = 0;
        <B><FONT COLOR="#A020F0">if</FONT></B> (node &amp;&amp; k) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left == NULL) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (k == node-&gt;sz)
                    res = node-&gt;sum;
                <B><FONT COLOR="#A020F0">else</FONT></B>
                    res = node-&gt;key.x + find_ksmallest_sum(node-&gt;right, k - 1);
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                <B><FONT COLOR="#228B22">int</FONT></B> num_left = node-&gt;left-&gt;sz;
                <B><FONT COLOR="#A020F0">if</FONT></B> (k &lt;= num_left)
                    res = find_ksmallest_sum(node-&gt;left, k);
                <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (k == num_left + 1)
                    res = node-&gt;key.x + node-&gt;left-&gt;sum;
                <B><FONT COLOR="#A020F0">else</FONT></B>
                    res = node-&gt;key.x + node-&gt;left-&gt;sum + find_ksmallest_sum(node-&gt;right, k - num_left - 1);
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> find(NPtr node, T key) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;key == key) <B><FONT COLOR="#A020F0">return</FONT></B> true;
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (key &lt; node-&gt;key) <B><FONT COLOR="#A020F0">return</FONT></B> find(node-&gt;left, key);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> find(node-&gt;right, key);
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
};

<I><FONT COLOR="#B22222">////////////////
</FONT></I><I><FONT COLOR="#B22222">//  USAGE
</FONT></I><I><FONT COLOR="#B22222">////////////////
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    Treap&lt;PII&gt; tree;
    tree.insert(PII(1, 0));
    tree.insert(PII(5, 0));
    tree.insert(PII(2, 0));
    tree.insert(PII(3, 0));
    tree.insert(PII(10, 0));
    tree.insert(PII(8, 0));
    tree.insert(PII(4, 0));
    tree.insert(PII(7, 0));
    tree.insert(PII(6, 0));
    tree.insert(PII(9, 0));

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= 11; i++) cout &lt;&lt; tree.find(PII(i, 0)) &lt;&lt; endl;
    cout &lt;&lt; endl;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++)
        cout &lt;&lt; tree.find_ksmallest(i).x &lt;&lt; endl;
    cout &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++)
        cout &lt;&lt; tree.find_ksmallest_sum(i) &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file17">
<H1>data_structure/Trie.cpp 17/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file16">prev</A>][<A HREF="#file18">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Trie
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://codeforces.com/contest/455/problem/B
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>


<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ALPHABET = 26;
using namespace std;
<B><FONT COLOR="#228B22">class</FONT></B> TrieNode {
<B><FONT COLOR="#228B22">public</FONT></B>:
    TrieNode *next[ALPHABET];
    <I><FONT COLOR="#B22222">// any other fields here
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> val; <I><FONT COLOR="#B22222">// 0 W, 1 L
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> val2;
    TrieNode () {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; ALPHABET; i++) {
            next[i] = NULL;
        }
        val = val2 = 0;
    }
};
<B><FONT COLOR="#228B22">typedef</FONT></B> TrieNode* TrieNodePtr;

<B><FONT COLOR="#228B22">class</FONT></B> Trie {
<B><FONT COLOR="#228B22">public</FONT></B>:
    TrieNodePtr root;
    Trie() { root = <B><FONT COLOR="#A020F0">new</FONT></B> TrieNode(); }
    <B><FONT COLOR="#228B22">void</FONT></B> insert(string &amp;s) {
        TrieNodePtr cur = root;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; (<B><FONT COLOR="#228B22">int</FONT></B>)s.size(); j++) {
            insert(cur, s[j]);
        }
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> insert(TrieNodePtr &amp;cur, <B><FONT COLOR="#228B22">char</FONT></B> c) {
        assert(c &gt;= <B><FONT COLOR="#BC8F8F">'a'</FONT></B> &amp;&amp; c &lt;= <B><FONT COLOR="#BC8F8F">'z'</FONT></B>);
        <B><FONT COLOR="#228B22">bool</FONT></B> ret = false;
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;next[c - <B><FONT COLOR="#BC8F8F">'a'</FONT></B>] == NULL) {
            ret = true;
            cur-&gt;next[c - <B><FONT COLOR="#BC8F8F">'a'</FONT></B>] = <B><FONT COLOR="#A020F0">new</FONT></B> TrieNode();
        }
        cur = cur-&gt;next[c - <B><FONT COLOR="#BC8F8F">'a'</FONT></B>];
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
};

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(TrieNodePtr cur) {
    <B><FONT COLOR="#228B22">int</FONT></B> sz = 0;
    <B><FONT COLOR="#228B22">int</FONT></B> cnt_l = 0;
    <B><FONT COLOR="#228B22">int</FONT></B> cnt_w = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; ALPHABET; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;next[i] != NULL) {
            dfs(cur-&gt;next[i]);
            sz++;
            <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;next[i]-&gt;val == 1) cnt_l++;
            <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;next[i]-&gt;val2 == 0) cnt_w++;
        }
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (sz == 0) {
        cur-&gt;val = 1;
        cur-&gt;val2 = 1;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (cnt_l) cur-&gt;val = 0;
        <B><FONT COLOR="#A020F0">else</FONT></B> cur-&gt;val = 1;
        <B><FONT COLOR="#A020F0">if</FONT></B> (cnt_w) cur-&gt;val2 = 1;
        <B><FONT COLOR="#A020F0">else</FONT></B> cur-&gt;val2 = 0;
    }
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    string s;
    <B><FONT COLOR="#228B22">int</FONT></B> N, K;
    cin &gt;&gt; N &gt;&gt; K;
    Trie tree;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        cin &gt;&gt; s;
        tree.insert(s);
    }
    dfs(tree.root);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tree.root-&gt;val == 1) printf(<B><FONT COLOR="#BC8F8F">&quot;Second\n&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((K % 2 == 0) &amp;&amp; tree.root-&gt;val2 == 0) printf(<B><FONT COLOR="#BC8F8F">&quot;Second\n&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">else</FONT></B> printf(<B><FONT COLOR="#BC8F8F">&quot;First\n&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file18">
<H1>dp/ConvexHullOptimization.cpp 18/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file17">prev</A>][<A HREF="#file19">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Convex Hull Optimization
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  dp[i] = min(dp[j] + b[j] * a[i]), j &lt; i
</FONT></I><I><FONT COLOR="#B22222">//  y     = min(c     + m    * x)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Requires b[j] &gt;= b[j + 1] (lines are added in decreasing order of slopes
</FONT></I><I><FONT COLOR="#B22222">//  Requires for this implementation: a[i] &lt;= a[i + 1] (query x in increasing order)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://codeforces.com/contest/319/problem/C
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)(x).size())

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> ConvexHullOptimization {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">struct</FONT></B> Line { T c, m; };
    deque&lt;Line&gt; sk;
    ConvexHullOptimization () {}
    <B><FONT COLOR="#228B22">void</FONT></B> add_line(T m, T c) {
        Line new_line = {c, m};
        <B><FONT COLOR="#A020F0">if</FONT></B> (!sk.empty() &amp;&amp; sk.back().m == new_line.m) {
            sk.back().c = min(sk.back().c, new_line.c);
            <B><FONT COLOR="#A020F0">return</FONT></B> ;
        }
        <B><FONT COLOR="#A020F0">while</FONT></B> (SZ(sk) &gt;= 2 &amp;&amp; cross_left(sk[SZ(sk) - 2], sk.back(), new_line)) sk.pop_back();
        sk.push_back(new_line);
    }
    <I><FONT COLOR="#B22222">// Returns the minimum value of y
</FONT></I>    T minimize(T x) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (sk.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (SZ(sk) &gt;= 2 &amp;&amp; cal_y(sk.front(), x) &gt; cal_y(sk[1], x)) sk.pop_front();
        <B><FONT COLOR="#A020F0">return</FONT></B> cal_y(sk.front(), x);
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <I><FONT COLOR="#B22222">// Returns true if x_ab &gt; x_bc
</FONT></I>    <I><FONT COLOR="#B22222">//   x_ab = the x-coordinate of the intersection of A and B
</FONT></I>    <I><FONT COLOR="#B22222">//   x_bc = the x-coordinate of the intersection of B and new_line
</FONT></I>    <B><FONT COLOR="#228B22">bool</FONT></B> cross_left(Line A, Line B, Line new_line) {
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> x_ab = (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>)(B.c - A.c) / (A.m - B.m);
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> x_bc = (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>)(new_line.c - B.c) / (B.m - new_line.m);
        <B><FONT COLOR="#A020F0">return</FONT></B> x_ab &gt; x_bc;
    }
    T cal_y(Line a, T x) { <B><FONT COLOR="#A020F0">return</FONT></B> a.m * x + a.c; }
};

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXN</FONT> (100005)
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">int</FONT></B> heights[MAXN];
<B><FONT COLOR="#228B22">int</FONT></B> costs[MAXN];
LL dp[MAXN];

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    <B><FONT COLOR="#228B22">int</FONT></B> n;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;n);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++ ) scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;heights[i]);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++ ) scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;costs[i]);

    <I><FONT COLOR="#B22222">// dp[i] = min({dp[k] + costs[k] * heights[i]})
</FONT></I>    <I><FONT COLOR="#B22222">// y = dp[i], c = dp[k], m = costs[k], x = heights[i]
</FONT></I>    <I><FONT COLOR="#B22222">// costs is decreasing, heights is increasing
</FONT></I>    ConvexHullOptimization&lt;LL&gt; solver;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++ ) {
        dp[i] = solver.minimize(heights[i]);
        solver.add_line(costs[i], dp[i]);
    }
    cout &lt;&lt; dp[n] &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file19">
<H1>geometry/ClosestPair.cpp 19/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file18">prev</A>][<A HREF="#file20">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Closest Pair Example
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://www.spoj.com/problems/CLOPPAIR/
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;


<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (1LL&lt;&lt;62)

<B><FONT COLOR="#228B22">class</FONT></B> ClosestPair {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;LL, LL&gt; Point;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;Point, Point&gt; PPP;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">double</FONT></B>, pair&lt;Point, Point&gt; &gt; PDPP;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;LL, pair&lt;Point, Point&gt; &gt; PLPP;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;LL, LL&gt; PLL;
    vector&lt;Point&gt; all_points;
    <B><FONT COLOR="#228B22">int</FONT></B> N;

    ClosestPair () {
        N = 0;
    }
    
    <B><FONT COLOR="#228B22">void</FONT></B> add_point(Point p) {
        N++; all_points.push_back(p);
    }

    <I><FONT COLOR="#B22222">// Return the closest distance and the pair of the two points
</FONT></I>    PDPP get_closest_pair() {
        assert(N &gt;= 2);
        sort(all_points.begin(), all_points.end());
        PLPP ret = get_closest_pair(0, N - 1);
        <B><FONT COLOR="#A020F0">return</FONT></B> PDPP(sqrt(ret.first), ret.second);
    }

<B><FONT COLOR="#228B22">private</FONT></B>:
    LL dist2(<B><FONT COLOR="#228B22">int</FONT></B> id1, <B><FONT COLOR="#228B22">int</FONT></B> id2) {
        LL dx = all_points[id1].first - all_points[id2].first;
        LL dy = all_points[id1].second - all_points[id2].second;
        <B><FONT COLOR="#A020F0">return</FONT></B> dx * dx + dy * dy;
    }

    PLPP get_closest_pair(<B><FONT COLOR="#228B22">int</FONT></B> left, <B><FONT COLOR="#228B22">int</FONT></B> right) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (left &gt;= right) {
            <B><FONT COLOR="#A020F0">return</FONT></B> PLPP(INF, PPP(Point(0, 0), Point(0, 0)));
        }
        <B><FONT COLOR="#228B22">int</FONT></B> mid = (left + right) / 2;
        PLPP ret_left = get_closest_pair(left, mid);
        PLPP ret_right = get_closest_pair(mid + 1, right);
        LL minn = INF;

        PPP ret;
        <B><FONT COLOR="#A020F0">if</FONT></B> (ret_left.first &lt; minn) {
            minn = ret_left.first;
            ret = ret_left.second;
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (ret_right.first &lt; minn) {
            minn = ret_right.first;
            ret = ret_right.second;
        }
        <B><FONT COLOR="#228B22">double</FONT></B> minn2 = sqrt(minn);
        
        vector&lt;PLL&gt; left_part;
        vector&lt;PLL&gt; right_part;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = left; i &lt;= right; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (i &lt;= mid) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (all_points[mid].first - all_points[i].first &lt;= minn2) {
                    <I><FONT COLOR="#B22222">// ....|.X..|....|....
</FONT></I>                    left_part.push_back(PLL(all_points[i].second, i));
                }
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                <B><FONT COLOR="#A020F0">if</FONT></B> (all_points[i].first - all_points[mid].first &lt;= minn2) {
                    <I><FONT COLOR="#B22222">// ....|....|.X..|...
</FONT></I>                    right_part.push_back(PLL(all_points[i].second, i));
                }
            }
        }

        <I><FONT COLOR="#B22222">// sort by y-coordinates
</FONT></I>        sort(left_part.begin(), left_part.end());
        sort(right_part.begin(), right_part.end());
    
        <B><FONT COLOR="#228B22">int</FONT></B> left_sz = left_part.size();
        <B><FONT COLOR="#228B22">int</FONT></B> right_sz = right_part.size();
        <B><FONT COLOR="#228B22">int</FONT></B> lower = 0, upper = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; left_sz; i++) {
            <B><FONT COLOR="#A020F0">while</FONT></B> (upper &lt; right_sz &amp;&amp; all_points[right_part[upper].second].second - all_points[left_part[i].second].second &lt;= minn2) upper++;
            <B><FONT COLOR="#A020F0">while</FONT></B> (lower &lt; right_sz &amp;&amp; all_points[left_part[i].second].second - all_points[right_part[lower].second].second &gt; minn2) lower++;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = lower; j &lt; upper; j++) {
                LL temp = dist2(left_part[i].second, right_part[j].second);
                <B><FONT COLOR="#A020F0">if</FONT></B> (temp &lt; minn) {
                    minn = temp;
                    ret = PPP(all_points[left_part[i].second], all_points[right_part[j].second]);
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> PLPP(minn, ret);
    }
};
    
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXN</FONT> (50005)
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;LL, LL&gt; Point;

Point in[MAXN];
    
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    cin &gt;&gt; N;
    ClosestPair solver;
    <B><FONT COLOR="#228B22">int</FONT></B> x, y;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;x, &amp;y);
        in[i] = Point(x, y);
        solver.add_point(in[i]);
    }

    pair&lt;<B><FONT COLOR="#228B22">double</FONT></B>, pair&lt;Point, Point&gt; &gt; ret = solver.get_closest_pair();

    <B><FONT COLOR="#228B22">int</FONT></B> ans1, ans2;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (in[i] == ret.second.first) ans1 = i;
        <B><FONT COLOR="#A020F0">if</FONT></B> (in[i] == ret.second.second) ans2 = i;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (ans1 &gt; ans2) swap(ans1, ans2);
    printf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %.6lf\n&quot;</FONT></B>, ans1, ans2, ret.first);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file20">
<H1>geometry/EarthCoordinates.cpp 20/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file19">prev</A>][<A HREF="#file21">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Earth Coordinates
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">latitude_longitude_to_xyz</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> R, <B><FONT COLOR="#228B22">double</FONT></B> lat, <B><FONT COLOR="#228B22">double</FONT></B> lon, <B><FONT COLOR="#228B22">double</FONT></B> &amp;x, <B><FONT COLOR="#228B22">double</FONT></B> &amp;y, <B><FONT COLOR="#228B22">double</FONT></B> &amp;z) {
    x = -R * cos(lat) * cos(lon);
    y = R * sin(lat);
    z = R * cos(lat) * sin(lon);
}

<I><FONT COLOR="#B22222">// Return the distance between the two given points
</FONT></I><I><FONT COLOR="#B22222">// R = Earth's radius
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">cal_dist</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> R, <B><FONT COLOR="#228B22">double</FONT></B> lat1, <B><FONT COLOR="#228B22">double</FONT></B> long1, <B><FONT COLOR="#228B22">double</FONT></B> lat2, <B><FONT COLOR="#228B22">double</FONT></B> long2) {
    <B><FONT COLOR="#228B22">double</FONT></B> xi, yi, zi;
    latitude_longitude_to_xyz(R, lat1 * M_PI / 180.0, long1 * M_PI / 180.0, xi, yi, zi);
    <B><FONT COLOR="#228B22">double</FONT></B> xj, yj, zj;
    latitude_longitude_to_xyz(R, lat2 * M_PI / 180.0, long2 * M_PI / 180.0, xj, yj, zj);

    <B><FONT COLOR="#228B22">double</FONT></B> dot = xi * xj + yi * yj + zi * zj;
    <B><FONT COLOR="#228B22">double</FONT></B> dist_i = sqrt (xi * xi + yi * yi + zi * zi);
    <B><FONT COLOR="#228B22">double</FONT></B> dist_j = sqrt (xj * xj + yj * yj + zj * zj);
    <B><FONT COLOR="#228B22">double</FONT></B> angle = acos(dot / dist_i / dist_j);
    <B><FONT COLOR="#A020F0">return</FONT></B> min(R * angle, R * (2 * M_PI - angle));
}
</PRE>
<HR>
<A NAME="file21">
<H1>geometry/Line.cpp 21/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file20">prev</A>][<A HREF="#file22">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Line
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> Line {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
    LL a, b, c;
    Line() {}
    Line(LL a_, LL b_, LL c_) { init(a_, b_, c_); }
    Line(LL x1, LL y1, LL x2, LL y2) {
        LL A = y2 - y1, B = x1 - x2, C = -A * x1 - B * y1;
        init(A, B, C);
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> == (<B><FONT COLOR="#228B22">const</FONT></B> Line &amp;o) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> a == o.a &amp;&amp; b == o.b &amp;&amp; c == o.c; }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> != (<B><FONT COLOR="#228B22">const</FONT></B> Line &amp;o) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> !(*<B><FONT COLOR="#A020F0">this</FONT></B> == o); }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> &lt; (<B><FONT COLOR="#228B22">const</FONT></B> Line &amp;o) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B>(a != o.a) <B><FONT COLOR="#A020F0">return</FONT></B> a &lt; o.a;
        <B><FONT COLOR="#A020F0">if</FONT></B>(b != o.b) <B><FONT COLOR="#A020F0">return</FONT></B> b &lt; o.b;
        <B><FONT COLOR="#A020F0">return</FONT></B> c &lt; o.c;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> init(LL A, LL B, LL C){
        a = A, b = B, c = C;
        <B><FONT COLOR="#A020F0">if</FONT></B>(a &lt; 0 || (a == 0 &amp;&amp; b &lt; 0)) a = -a, b = -b, c = -c;
        reduce();
    }
    <B><FONT COLOR="#228B22">void</FONT></B> reduce(){
        LL g = gcd(labs(a), gcd(labs(b), labs(c)));
        a /= g, b /= g, c /= g;       
    }
    LL gcd(LL x, LL y) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (x == 0 || y == 0) <B><FONT COLOR="#A020F0">return</FONT></B> x + y;
        <B><FONT COLOR="#A020F0">if</FONT></B> (x % y == 0) <B><FONT COLOR="#A020F0">return</FONT></B> y;
        <B><FONT COLOR="#A020F0">return</FONT></B> gcd(y, x % y);
    }
};
</PRE>
<HR>
<A NAME="file22">
<H1>geometry/Util.cpp 22/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file21">prev</A>][<A HREF="#file23">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Geometry
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))

<I><FONT COLOR="#B22222">// -- Adapted from Stanford ACM team notebook --
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> INF = 1e100;
<B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-9;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">struct</FONT></B> Point {
    T x, y;
    Point() {}
    Point(T x, T y) : x(x), y(y) {}
    Point(<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;p) : x(p.x), y(p.y) {}
    Point <B><FONT COLOR="#A020F0">operator</FONT></B> + (<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;p) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Point(x+p.x, y+p.y); }
    Point <B><FONT COLOR="#A020F0">operator</FONT></B> - (<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;p) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Point(x-p.x, y-p.y); }
    Point <B><FONT COLOR="#A020F0">operator</FONT></B> * (T c)            <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Point(x*c,   y*c  ); }
    Point <B><FONT COLOR="#A020F0">operator</FONT></B> / (T c)            <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Point(x/c,   y/c  ); }
    <B><FONT COLOR="#228B22">bool</FONT></B>  <B><FONT COLOR="#A020F0">operator</FONT></B> &lt; (<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;p) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(y,x) &lt; make_pair(p.y,p.x); }
    <B><FONT COLOR="#228B22">bool</FONT></B>  <B><FONT COLOR="#A020F0">operator</FONT></B> ==(<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;p) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(y,x) == make_pair(p.y,p.x); }
};

T cross(Point p, Point q) { <B><FONT COLOR="#A020F0">return</FONT></B> p.x*q.y-p.y*q.x; }
T area2(Point a, Point b, Point c) { <B><FONT COLOR="#A020F0">return</FONT></B> cross(a,b) + cross(b,c) + cross(c,a); }
T dot(Point p, Point q) { <B><FONT COLOR="#A020F0">return</FONT></B> p.x*q.x+p.y*q.y; }
T dist2(Point p, Point q) { <B><FONT COLOR="#A020F0">return</FONT></B> dot(p-q,p-q); }

ostream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(ostream &amp;os, <B><FONT COLOR="#228B22">const</FONT></B> Point &amp;p) {
    <B><FONT COLOR="#A020F0">return</FONT></B> os &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> &lt;&lt; p.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B> &lt;&lt; p.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;
}
<I><FONT COLOR="#B22222">// rotate a point CCW or CW around the origin
</FONT></I>Point <B><FONT COLOR="#0000FF">RotateCCW90</FONT></B>(Point p) { <B><FONT COLOR="#A020F0">return</FONT></B> Point(-p.y,p.x); }
Point <B><FONT COLOR="#0000FF">RotateCW90</FONT></B>(Point p) { <B><FONT COLOR="#A020F0">return</FONT></B> Point(p.y,-p.x); }

Point <B><FONT COLOR="#0000FF">RotateCCW</FONT></B>(Point p, <B><FONT COLOR="#228B22">double</FONT></B> t) { <B><FONT COLOR="#A020F0">return</FONT></B> Point(p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)); }


<I><FONT COLOR="#B22222">////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  ConvexHull
</FONT></I><I><FONT COLOR="#B22222">////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">// Compute the 2D convex hull of a set of points using the monotone chain
</FONT></I><I><FONT COLOR="#B22222">// algorithm. Eliminate redundant points from the hull if REMOVE_REDUNDANT is
</FONT></I><I><FONT COLOR="#B22222">// #defined.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n log n)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: a vector of input points, unordered.
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT: a vector of points in the convex hull, counterclockwise, starting
</FONT></I><I><FONT COLOR="#B22222">// with bottommost/leftmost point
</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">between</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> Point &amp;b, <B><FONT COLOR="#228B22">const</FONT></B> Point &amp;c) {
    <B><FONT COLOR="#A020F0">return</FONT></B> (fabs(area2(a,b,c)) &lt; EPS &amp;&amp; (a.x-b.x)*(c.x-b.x) &lt;= 0 &amp;&amp;
            (a.y-b.y)*(c.y-b.y) &lt;= 0);
}
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">ConvexHull</FONT></B>(vector&lt;Point&gt; &amp;pts) {
    sort(pts.begin(), pts.end());
    pts.erase(unique(pts.begin(), pts.end()), pts.end());
    vector&lt;Point&gt; up, dn;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(pts); i++) {
        <B><FONT COLOR="#A020F0">while</FONT></B> (SZ(up) &gt; 1 &amp;&amp; area2(up[SZ(up)-2], up.back(), pts[i]) &gt;= 0) <I><FONT COLOR="#B22222">// up = concave down (top convex)
</FONT></I>            up.pop_back();
        <B><FONT COLOR="#A020F0">while</FONT></B> (SZ(dn) &gt; 1 &amp;&amp; area2(dn[SZ(dn)-2], dn.back(), pts[i]) &lt;= 0) <I><FONT COLOR="#B22222">// dn = concave up (bot convex)
</FONT></I>            dn.pop_back();
        up.push_back(pts[i]);
		dn.push_back(pts[i]);
    }
    pts = dn;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = (<B><FONT COLOR="#228B22">int</FONT></B>) SZ(up) - 2; i &gt;= 1; i--) pts.push_back(up[i]);
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>
    <B><FONT COLOR="#A020F0">if</FONT></B> (SZ(pts) &lt;= 2) <B><FONT COLOR="#A020F0">return</FONT></B>;
    dn.clear();
    dn.push_back(pts[0]);
    dn.push_back(pts[1]);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i &lt; SZ(pts); i++){
        <B><FONT COLOR="#A020F0">if</FONT></B> (between(dn[SZ(dn)-2], dn[SZ(dn)-1], pts[i])) dn.pop_back();
		dn.push_back(pts[i]);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (SZ(dn) &gt;= 3 &amp;&amp; between(dn.back(), dn[0], dn[1])) {
        dn[0] = dn.back();
        dn.pop_back();
    }
    pts = dn;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
}

<I><FONT COLOR="#B22222">// project point c onto line through a and b
</FONT></I><I><FONT COLOR="#B22222">// assuming a != b
</FONT></I>Point <B><FONT COLOR="#0000FF">ProjectPointLine</FONT></B>(Point a, Point b, Point c) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);
}

<I><FONT COLOR="#B22222">// project point c onto line segment through a and b
</FONT></I>Point <B><FONT COLOR="#0000FF">ProjectPointSegment</FONT></B>(Point a, Point b, Point c) {
    <B><FONT COLOR="#228B22">double</FONT></B> r = dot(b-a,b-a);
    <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(r) &lt; EPS) <B><FONT COLOR="#A020F0">return</FONT></B> a;
    r = dot(c-a, b-a)/r;
    <B><FONT COLOR="#A020F0">if</FONT></B> (r &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> a;
    <B><FONT COLOR="#A020F0">if</FONT></B> (r &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> b;
    <B><FONT COLOR="#A020F0">return</FONT></B> a + (b-a)*r;
}
<I><FONT COLOR="#B22222">// compute distance from c to line between a and b
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointLine</FONT></B>(Point a, Point b, Point c) {
    Point ac = c - a;
    Point ab = b - a;
    <B><FONT COLOR="#A020F0">return</FONT></B> abs(cross(ac, ab) / sqrt(dot(ab, ab)));
}
<I><FONT COLOR="#B22222">// compute distance from c to segment between a and b
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointSegment</FONT></B>(Point a, Point b, Point c) {
    <B><FONT COLOR="#A020F0">return</FONT></B> sqrt(dist2(c, ProjectPointSegment(a, b, c)));
}
<I><FONT COLOR="#B22222">// compute distance between point (x,y,z) and plane ax+by+cz=d
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointPlane</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y, <B><FONT COLOR="#228B22">double</FONT></B> z,
                          <B><FONT COLOR="#228B22">double</FONT></B> a, <B><FONT COLOR="#228B22">double</FONT></B> b, <B><FONT COLOR="#228B22">double</FONT></B> c, <B><FONT COLOR="#228B22">double</FONT></B> d){
    <B><FONT COLOR="#A020F0">return</FONT></B> fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);
}
<I><FONT COLOR="#B22222">// determine if lines from a to b and c to d are parallel or collinear
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesParallel</FONT></B>(Point a, Point b, Point c, Point d) {
    <B><FONT COLOR="#A020F0">return</FONT></B> fabs(cross(b-a, c-d)) &lt; EPS;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesCollinear</FONT></B>(Point a, Point b, Point c, Point d) {
    <B><FONT COLOR="#A020F0">return</FONT></B> LinesParallel(a, b, c, d) &amp;&amp; fabs(cross(a-b, a-c)) &lt; EPS &amp;&amp;
        fabs(cross(c-d, c-a)) &lt; EPS;
}

<I><FONT COLOR="#B22222">// determine if line segment from a to b intersects with
</FONT></I><I><FONT COLOR="#B22222">// line segment from c to d
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">SegmentsIntersect</FONT></B>(Point a, Point b, Point c, Point d) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (LinesCollinear(a, b, c, d)) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(a, c) &lt; EPS || dist2(a, d) &lt; EPS ||
            dist2(b, c) &lt; EPS || dist2(b, d) &lt; EPS)
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
        <B><FONT COLOR="#A020F0">if</FONT></B> (dot(c-a, c-b) &gt; 0 &amp;&amp; dot(d-a, d-b) &gt; 0 &amp;&amp; dot(c-b, d-b) &gt; 0)
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (cross(d-a, b-a) * cross(c-a, b-a) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B> (cross(a-c, d-c) * cross(b-c, d-c) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
<I><FONT COLOR="#B22222">// compute intersection of line passing through a and b
</FONT></I><I><FONT COLOR="#B22222">// with line passing through c and d, assuming that unique
</FONT></I><I><FONT COLOR="#B22222">// intersection exists; for segment intersection, check if
</FONT></I><I><FONT COLOR="#B22222">// segments intersect first
</FONT></I><I><FONT COLOR="#B22222">// if they are colinear, return only a point
</FONT></I>Point <B><FONT COLOR="#0000FF">ComputeLineIntersection</FONT></B>(Point a, Point b, Point c, Point d) {
    b=b-a; d=c-d; c=c-a;
    assert(dot(b, b) &gt; EPS &amp;&amp; dot(d, d) &gt; EPS);
    <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(cross(b, d)) &lt; EPS) { <I><FONT COLOR="#B22222">// colinear
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (min(c.x, d.x) &lt;= b.x &amp;&amp; b.x &lt;= max(c.x, d.x)) <B><FONT COLOR="#A020F0">return</FONT></B> b;
        <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> a;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> a + b*cross(c, d)/cross(b, d);
}
<I><FONT COLOR="#B22222">// compute center of circle given three points
</FONT></I>Point <B><FONT COLOR="#0000FF">ComputeCircleCenter</FONT></B>(Point a, Point b, Point c) {
    b=(a+b)/2;
    c=(a+c)/2;
    <B><FONT COLOR="#A020F0">return</FONT></B> ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));
}

<I><FONT COLOR="#B22222">// compute center of circle given 2 points and its radius
</FONT></I><I><FONT COLOR="#B22222">// idea:
</FONT></I><I><FONT COLOR="#B22222">//   1. Find the vector passing between a and b -&gt; (x2-x1, y2-y1)
</FONT></I><I><FONT COLOR="#B22222">//   2. Find the mirror vector between a and b -&gt; (y2-y1, x1-x2)
</FONT></I><I><FONT COLOR="#B22222">//   3. Normalize the mirror vector ((y2-y1)/d, (x1-x2)/d)
</FONT></I><I><FONT COLOR="#B22222">//   4. Use the distance between the center and the midpoint and 3.
</FONT></I><I><FONT COLOR="#B22222">//      to compute the center.
</FONT></I><I><FONT COLOR="#B22222">// Returns two possible centers
</FONT></I>vector&lt;Point&gt; ComputeCircleCenter(Point a, Point b, <B><FONT COLOR="#228B22">double</FONT></B> r) {
    vector&lt;Point&gt; res;
    Point mid = (a + b) / 2;
    <B><FONT COLOR="#228B22">double</FONT></B> d = sqrt(dist2(a, b));
    <B><FONT COLOR="#228B22">double</FONT></B> d_sq = dist2(a, b);
    <B><FONT COLOR="#A020F0">if</FONT></B> (d_sq &lt; EPS || d_sq &gt; 4 * r * r - EPS) <B><FONT COLOR="#A020F0">return</FONT></B> res;
    Point v_ab = b - a;
    Point v1 = RotateCW90(v_ab) / d;
    <B><FONT COLOR="#228B22">double</FONT></B> d2 = sqrt(r*r - (d / 2) * (d / 2));
    res.push_back(mid + v1 * d2);
    res.push_back(mid - v1 * d2);
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}

<I><FONT COLOR="#B22222">// determine if point is in a possibly non-convex polygon (by William
</FONT></I><I><FONT COLOR="#B22222">// Randolph Franklin); returns 1 for strictly interior points, 0 for
</FONT></I><I><FONT COLOR="#B22222">// strictly exterior points, and 0 or 1 for the remaining points.
</FONT></I><I><FONT COLOR="#B22222">// Note that it is possible to convert this into an *exact* test using
</FONT></I><I><FONT COLOR="#B22222">// integer arithmetic by taking care of the division appropriately
</FONT></I><I><FONT COLOR="#B22222">// (making sure to deal with signs properly) and then by writing exact
</FONT></I><I><FONT COLOR="#B22222">// tests for checking point on polygon boundary
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointInPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p, Point q) {
    <B><FONT COLOR="#228B22">bool</FONT></B> c = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(p); i++){
        <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1)%SZ(p);
        <B><FONT COLOR="#A020F0">if</FONT></B> ((p[i].y &lt;= q.y &amp;&amp; q.y &lt; p[j].y || p[j].y &lt;= q.y &amp;&amp; q.y &lt; p[i].y) &amp;&amp;
            q.x &lt; p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))
            c = !c;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> c;
}

<I><FONT COLOR="#B22222">// determine if point is on the boundary of a polygon
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointOnPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p, Point q) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(p); i++)
        <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(ProjectPointSegment(p[i], p[(i+1)%SZ(p)], q), q) &lt; EPS)
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<I><FONT COLOR="#B22222">// compute intersection of line through points a and b with
</FONT></I><I><FONT COLOR="#B22222">// circle centered at c with radius r &gt; 0
</FONT></I>vector&lt;Point&gt; CircleLineIntersection(Point a, Point b, Point c, <B><FONT COLOR="#228B22">double</FONT></B> r) {
    vector&lt;Point&gt; ret;
    b = b-a;
    a = a-c;
    <B><FONT COLOR="#228B22">double</FONT></B> A = dot(b, b);
    <B><FONT COLOR="#228B22">double</FONT></B> B = dot(a, b);
    <B><FONT COLOR="#228B22">double</FONT></B> C = dot(a, a) - r*r;
    <B><FONT COLOR="#228B22">double</FONT></B> D = B*B - A*C;
    <B><FONT COLOR="#A020F0">if</FONT></B> (D &lt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);
    <B><FONT COLOR="#A020F0">if</FONT></B> (D &gt; EPS)
	ret.push_back(c+a+b*(-B-sqrt(D))/A);
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// compute intersection of circle centered at a with radius r
</FONT></I><I><FONT COLOR="#B22222">// with circle centered at b with radius R
</FONT></I>vector&lt;Point&gt; CircleCircleIntersection(Point a, Point b, <B><FONT COLOR="#228B22">double</FONT></B> r, <B><FONT COLOR="#228B22">double</FONT></B> R) {
    vector&lt;Point&gt; ret;
    <B><FONT COLOR="#228B22">double</FONT></B> d = sqrt(dist2(a, b));
    <B><FONT COLOR="#A020F0">if</FONT></B> (d &gt; r+R || d+min(r, R) &lt; max(r, R)) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    <B><FONT COLOR="#228B22">double</FONT></B> x = (d*d-R*R+r*r)/(2*d);
    <B><FONT COLOR="#228B22">double</FONT></B> y = sqrt(r*r-x*x);
    Point v = (b-a)/d;
    ret.push_back(a+v*x + RotateCCW90(v)*y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (y &gt; 0)
        ret.push_back(a+v*x - RotateCCW90(v)*y);
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// This code computes the area or centroid of a (possibly nonconvex)
</FONT></I><I><FONT COLOR="#B22222">// polygon, assuming that the coordinates are listed in a clockwise or
</FONT></I><I><FONT COLOR="#B22222">// counterclockwise fashion. Note that the centroid is often known as
</FONT></I><I><FONT COLOR="#B22222">// the &quot;center of gravity&quot; or &quot;center of mass&quot;.
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeSignedArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p) {
    <B><FONT COLOR="#228B22">double</FONT></B> area = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(p); i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % SZ(p);
        area += p[i].x*p[j].y - p[j].x*p[i].y;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> area / 2.0;
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p) {
    <B><FONT COLOR="#A020F0">return</FONT></B> fabs(ComputeSignedArea(p));
}

Point <B><FONT COLOR="#0000FF">ComputeCentroid</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p) {
    Point c(0,0);
    <B><FONT COLOR="#228B22">double</FONT></B> scale = 6.0 * ComputeSignedArea(p);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(p); i++){
        <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % SZ(p);
        c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> c / scale;
}

<I><FONT COLOR="#B22222">// tests whether or not a given polygon (in CW or CCW order) is simple
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">IsSimple</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(p); i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = i+1; k &lt; SZ(p); k++) {
            <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % SZ(p);
            <B><FONT COLOR="#228B22">int</FONT></B> l = (k+1) % SZ(p);
            <B><FONT COLOR="#A020F0">if</FONT></B> (i == l || j == k) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (SegmentsIntersect(p[i], p[j], p[k], p[l]))
                <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
	<I><FONT COLOR="#B22222">// expected: (-5,2)
</FONT></I>	cerr &lt;&lt; RotateCCW90(Point(2,5)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (5,-2)
</FONT></I>	cerr &lt;&lt; RotateCW90(Point(2,5)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (-5,2)
</FONT></I>	cerr &lt;&lt; RotateCCW(Point(2,5),M_PI/2) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (5,2)
</FONT></I>	cerr &lt;&lt; ProjectPointLine(Point(-5,-2), Point(10,4), Point(3,7)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (5,2) (7.5,3) (2.5,1)
</FONT></I>	cerr &lt;&lt; ProjectPointSegment(Point(-5,-2), Point(10,4), Point(3,7)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; ProjectPointSegment(Point(7.5,3), Point(10,4), Point(3,7)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; ProjectPointSegment(Point(-5,-2), Point(2.5,1), Point(3,7)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: 6.78903
</FONT></I>	cerr &lt;&lt; DistancePointPlane(4,-4,3,2,-2,5,-8) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: 1 0 1
</FONT></I>	cerr &lt;&lt; LinesParallel(Point(1,1), Point(3,5), Point(2,1), Point(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; LinesParallel(Point(1,1), Point(3,5), Point(2,0), Point(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; LinesParallel(Point(1,1), Point(3,5), Point(5,9), Point(7,13)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: 0 0 1
</FONT></I>	cerr &lt;&lt; LinesCollinear(Point(1,1), Point(3,5), Point(2,1), Point(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; LinesCollinear(Point(1,1), Point(3,5), Point(2,0), Point(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; LinesCollinear(Point(1,1), Point(3,5), Point(5,9), Point(7,13)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: 1 1 1 0
</FONT></I>	cerr &lt;&lt; SegmentsIntersect(Point(0,0), Point(2,4), Point(3,1), Point(-1,3)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; SegmentsIntersect(Point(0,0), Point(2,4), Point(4,3), Point(0,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; SegmentsIntersect(Point(0,0), Point(2,4), Point(2,-1), Point(-2,1)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; SegmentsIntersect(Point(0,0), Point(2,4), Point(5,5), Point(1,7)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (1,2)
</FONT></I>	cerr &lt;&lt; ComputeLineIntersection(Point(0,0), Point(2,4), Point(3,1), Point(-1,3)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (1,1)
</FONT></I>	cerr &lt;&lt; ComputeCircleCenter(Point(-3,4), Point(6,1), Point(4,5)) &lt;&lt; endl;
	vector&lt;Point&gt; v;
	v.push_back(Point(0,0));
	v.push_back(Point(5,0));
	v.push_back(Point(5,5));
	v.push_back(Point(0,5));
	<I><FONT COLOR="#B22222">// expected: 1 1 1 0 0
</FONT></I>	cerr &lt;&lt; PointInPolygon(v, Point(2,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointInPolygon(v, Point(2,0)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointInPolygon(v, Point(0,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointInPolygon(v, Point(5,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointInPolygon(v, Point(2,5)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: 0 1 1 1 1
</FONT></I>	cerr &lt;&lt; PointOnPolygon(v, Point(2,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointOnPolygon(v, Point(2,0)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointOnPolygon(v, Point(0,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointOnPolygon(v, Point(5,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointOnPolygon(v, Point(2,5)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (1,6)
</FONT></I>	<I><FONT COLOR="#B22222">// (5,4) (4,5)
</FONT></I>	<I><FONT COLOR="#B22222">// blank line
</FONT></I>	<I><FONT COLOR="#B22222">// (4,5) (5,4)
</FONT></I>	<I><FONT COLOR="#B22222">// blank line
</FONT></I>	<I><FONT COLOR="#B22222">// (4,5) (5,4)
</FONT></I>	vector&lt;Point&gt; u = CircleLineIntersection(Point(0,6), Point(2,6), Point(1,1), 5);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(u); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	u = CircleLineIntersection(Point(0,9), Point(9,0), Point(1,1), 5);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(u); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	u = CircleCircleIntersection(Point(1,1), Point(10,10), 5, 5);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(u); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	u = CircleCircleIntersection(Point(1,1), Point(8,8), 5, 5);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(u); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	u = CircleCircleIntersection(Point(1,1), Point(4.5,4.5), 10, sqrt(2.0)/2.0);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(u); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	u = CircleCircleIntersection(Point(1,1), Point(4.5,4.5), 5, sqrt(2.0)/2.0);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(u); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// area should be 5.0
</FONT></I>	<I><FONT COLOR="#B22222">// centroid should be (1.1666666, 1.166666)
</FONT></I>	Point pa[] = { Point(0,0), Point(5,0), Point(1,1), Point(0,5) };
	vector&lt;Point&gt; p(pa, pa+4);
	Point c = ComputeCentroid(p);
	cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Area: &quot;</FONT></B> &lt;&lt; ComputeArea(p) &lt;&lt; endl;
	cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Centroid: &quot;</FONT></B> &lt;&lt; c &lt;&lt; endl;
	<B><FONT COLOR="#A020F0">return</FONT></B> 0;
}


<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Pick's Theorem
</FONT></I><I><FONT COLOR="#B22222">//  On a simple polygon constructed on a grid of equal-distanced points,
</FONT></I><I><FONT COLOR="#B22222">//  for area A, the number of interior points I, number of boundary points B,
</FONT></I><I><FONT COLOR="#B22222">//  we have A = I + B / 2 - 1.
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">// Returns true if Rec(a, b) can fit in Rec(c, d)
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">can_ab_fit_in_cd</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> a, <B><FONT COLOR="#228B22">double</FONT></B> b, <B><FONT COLOR="#228B22">double</FONT></B> c, <B><FONT COLOR="#228B22">double</FONT></B> d){
	<B><FONT COLOR="#A020F0">if</FONT></B>(a * b &gt; c * d) <B><FONT COLOR="#A020F0">return</FONT></B> false;
	<B><FONT COLOR="#A020F0">if</FONT></B>(a &gt; b) swap(a, b);
	<B><FONT COLOR="#A020F0">if</FONT></B>(c &gt; d) swap(c, d);
	<B><FONT COLOR="#A020F0">if</FONT></B>(a &gt; c) <B><FONT COLOR="#A020F0">return</FONT></B> false;
	<B><FONT COLOR="#A020F0">if</FONT></B>(a &lt;= c &amp;&amp; b &lt;= d) <B><FONT COLOR="#A020F0">return</FONT></B> true;
	<B><FONT COLOR="#228B22">double</FONT></B> dis = sqrt(a * a + b * b);
	<B><FONT COLOR="#228B22">double</FONT></B> P = asin(c / dis);
	<B><FONT COLOR="#228B22">double</FONT></B> Q = asin(a / dis);
	<B><FONT COLOR="#228B22">double</FONT></B> theta = P - Q;
	<B><FONT COLOR="#228B22">double</FONT></B> dd = b * cos(theta) + a * sin(theta);
	<B><FONT COLOR="#A020F0">return</FONT></B> dd &lt;= d;
}

</PRE>
<HR>
<A NAME="file23">
<H1>graph/BiconnectedComponent.cpp 23/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file22">prev</A>][<A HREF="#file24">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Biconnected Component, Articulation points, Bridges
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3785
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> BiconnectedComponent {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N, M;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; adj;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; bicomponents; <I><FONT COLOR="#B22222">// biconnected component
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; bridges; <I><FONT COLOR="#B22222">// component whose all pairs are connected by exactly one simple path
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; dfs_numbers;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; low_numbers;
    vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; is_articulation_point;
    <B><FONT COLOR="#228B22">int</FONT></B> dfs_number;
    
    <I><FONT COLOR="#B22222">// Vertices are 1-based
</FONT></I>    BiconnectedComponent(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) {
        M = 0; adj.resize(N + 1); bicomponents.resize(N + 1); bridges.resize(N + 1);
        dfs_numbers.resize(N + 1); low_numbers.resize(N + 1);
        is_articulation_point.resize(N + 1); dfs_number = 0;
    }

    <B><FONT COLOR="#228B22">int</FONT></B> find_bicomponent(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> find_component(bicomponents, x); }
    <B><FONT COLOR="#228B22">int</FONT></B> find_bridge(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> find_component(bridges, x); }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { adj[u].push_back(v); }
    <B><FONT COLOR="#228B22">void</FONT></B> cal_components() {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) { bicomponents[i] = i; bridges[i] = i; }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (dfs_numbers[i] == 0) cal_components(i, -1);
        }
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> is_articulation(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> is_articulation_point[x]; }

<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> find_component(vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;com, <B><FONT COLOR="#228B22">int</FONT></B> x) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (com[x] == x) <B><FONT COLOR="#A020F0">return</FONT></B> x;
        <B><FONT COLOR="#A020F0">return</FONT></B> com[x] = find_component(com, com[x]);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> union_set(vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;com, <B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y) {
        <B><FONT COLOR="#228B22">int</FONT></B> a = find_component(com, x);
        <B><FONT COLOR="#228B22">int</FONT></B> b = find_component(com, y);
        com[a] = b;
    }

    <B><FONT COLOR="#228B22">void</FONT></B> cal_components(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> parent) {
        dfs_numbers[at] = low_numbers[at] = ++dfs_number;
        <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[at].size();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = adj[at][i];
            <B><FONT COLOR="#A020F0">if</FONT></B> (!dfs_numbers[v]) {
                cal_components(v, at);
                low_numbers[at] = min(low_numbers[at], low_numbers[v]);
                <B><FONT COLOR="#A020F0">if</FONT></B> (low_numbers[v] &gt; dfs_numbers[at]) {
                    <I><FONT COLOR="#B22222">// at is an articulation point separating v
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (at &gt; 1) is_articulation_point[at] = true;
                    union_set(bridges, v, at);
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    union_set(bicomponents, v, at);
                }
            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (v != parent) {
                low_numbers[at] = min(low_numbers[at], dfs_numbers[v]);
            }
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#A020F0">while</FONT></B> (1) {
        <B><FONT COLOR="#228B22">int</FONT></B> N, M, Q;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %d&quot;</FONT></B>, &amp;N, &amp;M, &amp;Q);
        <B><FONT COLOR="#A020F0">if</FONT></B> (N + M + Q == 0) <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        BiconnectedComponent solver(N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;u, &amp;v);
            solver.add_edge(u, v);
            solver.add_edge(v, u);
        }
        
        solver.cal_components();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; Q; q++) {
            <B><FONT COLOR="#228B22">int</FONT></B> start, finish;
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;start, &amp;finish);
            <B><FONT COLOR="#228B22">int</FONT></B> a = solver.find_bridge(start);
            <B><FONT COLOR="#228B22">int</FONT></B> b = solver.find_bridge(finish);
            <B><FONT COLOR="#A020F0">if</FONT></B> (a == b) printf(<B><FONT COLOR="#BC8F8F">&quot;Y\n&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">else</FONT></B> printf(<B><FONT COLOR="#BC8F8F">&quot;N\n&quot;</FONT></B>);
        }
        printf(<B><FONT COLOR="#BC8F8F">&quot;-\n&quot;</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file24">
<H1>graph/Dinic.cpp 24/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file23">prev</A>][<A HREF="#file25">next</A>]
<PRE>

<I><FONT COLOR="#B22222">////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Dinic algorithm
</FONT></I><I><FONT COLOR="#B22222">////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">// Adjacency list implementation of Dinic's blocking flow algorithm.
</FONT></I><I><FONT COLOR="#B22222">// This is very fast in practice, and only loses to push-relabel flow.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time:
</FONT></I><I><FONT COLOR="#B22222">//     O(|V|^2 |E|)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//     - source
</FONT></I><I><FONT COLOR="#B22222">//     - sink
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - maximum flow value
</FONT></I><I><FONT COLOR="#B22222">//     - To obtain the actual flow values, look at all edges with
</FONT></I><I><FONT COLOR="#B22222">//       capacity &gt; 0 (zero capacity edges are residual edges).
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> inf_flow = 2000000000;
<B><FONT COLOR="#228B22">class</FONT></B> Dinic {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">struct</FONT></B> Edge {
        <B><FONT COLOR="#228B22">int</FONT></B> from, to, cap, flow, index;
        Edge(<B><FONT COLOR="#228B22">int</FONT></B> from_, <B><FONT COLOR="#228B22">int</FONT></B> to_, <B><FONT COLOR="#228B22">int</FONT></B> cap_, <B><FONT COLOR="#228B22">int</FONT></B> flow_, <B><FONT COLOR="#228B22">int</FONT></B> index_) :
            from(from_), to(to_), cap(cap_), flow(flow_), index(index_) {}
    };

    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;vector&lt;Edge&gt; &gt; G;
    vector&lt;Edge *&gt; dad;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; Q;
  
    Dinic(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n), G(n), dad(n), Q(n) {}
  
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to, <B><FONT COLOR="#228B22">int</FONT></B> cap) {
        G[from].push_back(Edge(from, to, cap, 0, G[to].size()));
        <B><FONT COLOR="#A020F0">if</FONT></B> (from == to) G[from].back().index++;
        G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));
    }

    <B><FONT COLOR="#228B22">void</FONT></B> reset_flow() {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> sz = G[i].size();
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz; j++) {
                G[i][j].flow = 0;
            }
        }
    }
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> get_maxflow(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> totflow = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> flow = blocking_flow(s, t))
            totflow += flow;
        <B><FONT COLOR="#A020F0">return</FONT></B> totflow;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> blocking_flow(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
        fill(dad.begin(), dad.end(), (Edge *) NULL);
        dad[s] = &amp;G[0][0] - 1;
    
        <B><FONT COLOR="#228B22">int</FONT></B> head = 0, tail = 0;
        Q[tail++] = s;
        <B><FONT COLOR="#A020F0">while</FONT></B> (head &lt; tail) {
            <B><FONT COLOR="#228B22">int</FONT></B> x = Q[head++];
            <B><FONT COLOR="#228B22">int</FONT></B> sz = G[x].size();
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
                Edge &amp;e = G[x][i];
                <B><FONT COLOR="#A020F0">if</FONT></B> (!dad[e.to] &amp;&amp; e.cap - e.flow &gt; 0) {
                    dad[e.to] = &amp;G[x][i];
                    Q[tail++] = e.to;
                }
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (!dad[t]) <B><FONT COLOR="#A020F0">return</FONT></B> 0;

        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> totflow = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> sz = G[t].size();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
            Edge *start = &amp;G[G[t][i].to][G[t][i].index];
            <B><FONT COLOR="#228B22">int</FONT></B> amt = inf_flow;
            <B><FONT COLOR="#A020F0">for</FONT></B> (Edge *e = start; amt &amp;&amp; e != dad[s]; e = dad[e-&gt;from]) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (!e) { amt = 0; <B><FONT COLOR="#A020F0">break</FONT></B>; }
                amt = min(amt, e-&gt;cap - e-&gt;flow);
            }
            <B><FONT COLOR="#A020F0">if</FONT></B> (amt == 0) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            <B><FONT COLOR="#A020F0">for</FONT></B> (Edge *e = start; amt &amp;&amp; e != dad[s]; e = dad[e-&gt;from]) {
                e-&gt;flow += amt;
                G[e-&gt;to][e-&gt;index].flow -= amt;
            }
            totflow += amt;
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> totflow;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    Dinic mf(3);
    mf.add_edge(0, 1, 2);
    mf.add_edge(1, 2, 2);
    assert(mf.get_maxflow(0, 2) == 2);

    mf = Dinic(4);
    mf.add_edge(0, 1, 2);
    mf.add_edge(0, 2, 2);
    mf.add_edge(1, 3, 1);
    mf.add_edge(1, 2, 1);
    mf.add_edge(2, 3, 2);
    assert(mf.get_maxflow(0, 3) == 3);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file25">
<H1>graph/EulerCircuit.cpp 25/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file24">prev</A>][<A HREF="#file26">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Euler Circuit (undirected graph)
</FONT></I><I><FONT COLOR="#B22222">//  Considering the number of odd-degree nodes
</FONT></I><I><FONT COLOR="#B22222">//     if 0, there is an euler circuit
</FONT></I><I><FONT COLOR="#B22222">//        2, there is an euler path
</FONT></I><I><FONT COLOR="#B22222">//     otherwise, neither of them exists
</FONT></I><I><FONT COLOR="#B22222">//  To find an euler path
</FONT></I><I><FONT COLOR="#B22222">//     - Add one edge between the two odd-degree nodes,
</FONT></I><I><FONT COLOR="#B22222">//     - Find an euler circuit and then remove that edge later
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Implementation of Euler Circuit
</FONT></I><I><FONT COLOR="#B22222">//    procedure FindEuler (u)
</FONT></I><I><FONT COLOR="#B22222">//      Iterate over all edges (u, v):
</FONT></I><I><FONT COLOR="#B22222">//        remove edge(u, v) from the graph
</FONT></I><I><FONT COLOR="#B22222">//        FindEuler(v)
</FONT></I><I><FONT COLOR="#B22222">//      add vertex u in the result
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://www.spoj.com/KSTN/problems/EULER/
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stack&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> EulerCircuit {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII; <I><FONT COLOR="#B22222">// (v, id)
</FONT></I>    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;vector&lt;PII&gt; &gt; VVP;
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> edge_st {
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        edge_st () {}
        edge_st(<B><FONT COLOR="#228B22">int</FONT></B> u_, <B><FONT COLOR="#228B22">int</FONT></B> v_) : u(u_), v(v_) {}
    } Edge;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;Edge&gt; edges;
    VI deg; <I><FONT COLOR="#B22222">// need to run get_euler_circuit first
</FONT></I>    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>    EulerCircuit() { N = 0; }
    EulerCircuit(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) {}
    <I><FONT COLOR="#B22222">// Add an edge between u and v
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { edges.push_back(Edge(u, v)); }
    <I><FONT COLOR="#B22222">// Return an empty list if no an euler circuit
</FONT></I>    VI get_euler_circuit(<B><FONT COLOR="#228B22">int</FONT></B> start) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (N &lt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> VI();
        <B><FONT COLOR="#228B22">int</FONT></B> M = edges.size(); VVP adj (N); VI empty_ret, ret;
        <B><FONT COLOR="#A020F0">if</FONT></B> (M == 0) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (N &gt; 1) { <B><FONT COLOR="#A020F0">return</FONT></B> empty_ret; } <B><FONT COLOR="#A020F0">else</FONT></B> { ret.push_back(0); <B><FONT COLOR="#A020F0">return</FONT></B> ret; }
        }
        vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; removed (M);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
            adj[edges[i].u].push_back(PII(edges[i].v, i));
            adj[edges[i].v].push_back(PII(edges[i].u, i));
        }
        deg = VI (N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) { <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[i].size();
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz; j++) {
                deg[adj[i][j].first]++;
            }
        }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) { <B><FONT COLOR="#A020F0">if</FONT></B> (deg[i] % 2) <B><FONT COLOR="#A020F0">return</FONT></B> empty_ret; }
        stack&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; st; VI cur_pt(N);
        st.push(start);
        <B><FONT COLOR="#A020F0">while</FONT></B> (!st.empty()) {
            <B><FONT COLOR="#228B22">int</FONT></B> u = st.top(), v = -1, id = 0;
            <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[u].size();
            <B><FONT COLOR="#A020F0">while</FONT></B> (cur_pt[u] &lt; sz &amp;&amp; v == -1) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (!removed[adj[u][cur_pt[u]].second]) {
                    v = adj[u][cur_pt[u]].first;
                    id = adj[u][cur_pt[u]].second;
                }
                cur_pt[u]++;
            }

            <B><FONT COLOR="#A020F0">if</FONT></B> (v == -1) { ret.push_back(u); st.pop(); }
            <B><FONT COLOR="#A020F0">else</FONT></B> { removed[id] = true; st.push(v); }
        }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) { <B><FONT COLOR="#A020F0">if</FONT></B> (!removed[i]) <B><FONT COLOR="#A020F0">return</FONT></B> empty_ret; }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N, M;
    <B><FONT COLOR="#228B22">int</FONT></B> u, v;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;N, &amp;M);
    EulerCircuit solver(N);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;u, &amp;v);
        u--, v--;
        solver.add_edge(u, v);
    }
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; res = solver.get_euler_circuit(0);
    <B><FONT COLOR="#228B22">int</FONT></B> sz = res.size();

    <B><FONT COLOR="#A020F0">if</FONT></B> (sz) {
        <I><FONT COLOR="#B22222">// Print an euler curcuit
</FONT></I>        printf(<B><FONT COLOR="#BC8F8F">&quot;1&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; sz; i++) {
            printf(<B><FONT COLOR="#BC8F8F">&quot; %d&quot;</FONT></B>, res[i] + 1);
        }
        printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#228B22">bool</FONT></B> bad = false;
        u = -1, v = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (solver.deg[i] % 2) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (u == -1) u = i;
                <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (v == -1) v = i;
                <B><FONT COLOR="#A020F0">else</FONT></B> bad = true; <I><FONT COLOR="#B22222">// No euler path as well.
</FONT></I>            }
        }

        <B><FONT COLOR="#A020F0">if</FONT></B> (bad) {
            <I><FONT COLOR="#B22222">// Neither euler path nor euler curcuit exists.
</FONT></I>        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <I><FONT COLOR="#B22222">// Print euler path.
</FONT></I>            solver.add_edge(u, v);
            res = solver.get_euler_circuit(0);
            sz = res.size();
            sz--;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
                <B><FONT COLOR="#228B22">int</FONT></B> a = res[i];
                <B><FONT COLOR="#228B22">int</FONT></B> b = res[(i + 1) % sz];
                <B><FONT COLOR="#A020F0">if</FONT></B> ((a == u &amp;&amp; b == v) || (a == v &amp;&amp; b == u)) {
                    printf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, b + 1);
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz - 1; j++) {
                        printf(<B><FONT COLOR="#BC8F8F">&quot; %d&quot;</FONT></B>, res[(i + j + 2) % sz] + 1);
                    }
                    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
                    <B><FONT COLOR="#A020F0">break</FONT></B>;
                }
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">/* tests
int main() {
    EulerCircuit solver;
    assert(solver.get_euler_circuit(0).size() == 0);
    solver = EulerCircuit(2);
    solver.add_edge(0, 1);
    assert(solver.get_euler_circuit(0).size() == 0);
    solver = EulerCircuit(1);
    assert(solver.get_euler_circuit(0).size() == 1);
    solver.add_edge(0, 0);
    solver.add_edge(0, 0);
    vector&lt;int&gt; res = solver.get_euler_circuit(0);
    assert(res.size() &gt; 0);
    for (int i = 0; i &lt; (int)res.size(); i++) printf(&quot;%d &quot;, res[i]); printf(&quot;\n&quot;);
    solver = EulerCircuit(6);
    solver.add_edge(0, 1);
    solver.add_edge(0, 2);
    solver.add_edge(2, 1);
    solver.add_edge(0, 3);
    solver.add_edge(3, 4);
    solver.add_edge(4, 5);
    solver.add_edge(5, 3);
    assert(solver.get_euler_circuit(0).size() == 0);
    solver.add_edge(0, 3);
    res = solver.get_euler_circuit(0);
    assert(res.size() &gt; 0);
    for (int i = 0; i &lt; (int)res.size(); i++) printf(&quot;%d &quot;, res[i]); printf(&quot;\n&quot;);
    res = solver.get_euler_circuit(1);
    assert(res.size() &gt; 0);
    for (int i = 0; i &lt; (int)res.size(); i++) printf(&quot;%d &quot;, res[i]); printf(&quot;\n&quot;);
    return 0;
}
*/</FONT></I>
</PRE>
<HR>
<A NAME="file26">
<H1>graph/EulerPathDirectedGraph.cpp 26/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file25">prev</A>][<A HREF="#file27">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Euler Path (directed graph)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))

<B><FONT COLOR="#228B22">class</FONT></B> EulerPathDirectedGraph {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N; <I><FONT COLOR="#B22222">// zero-based indexed.
</FONT></I>    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; adj;
    EulerPathDirectedGraph (<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) { adj.resize(n); }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { adj[u].push_back(v); }
    <I><FONT COLOR="#B22222">// Return an empty vector if no euler path exists.
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; get_euler_path() {
        vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; outdeg(N), indeg(N);
        REP(u, N) <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v : adj[u]) { outdeg[u]++, indeg[v]++; }
        <B><FONT COLOR="#228B22">int</FONT></B> num_plus = 0, num_minus = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> start = -1;
        <B><FONT COLOR="#228B22">bool</FONT></B> good = true;
        REP(i, N) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (abs(indeg[i] - outdeg[i]) &gt; 1) {
                good = false;
            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (abs(indeg[i] - outdeg[i]) == 1) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (outdeg[i] &gt; indeg[i]) start = i, num_plus++;
                <B><FONT COLOR="#A020F0">else</FONT></B> num_minus++;
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (start == -1) REP(i, N) <B><FONT COLOR="#A020F0">if</FONT></B> (outdeg[i]) { start = i; <B><FONT COLOR="#A020F0">break</FONT></B>; } <I><FONT COLOR="#B22222">// also have an euler circuit
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (good &amp;&amp; ((num_plus == 1 &amp;&amp; num_minus == 1) || (num_plus == 0 &amp;&amp; num_minus == 0))) {
            vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; cur_i(N), ans;
            stack&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; st;
            st.push(start);
            vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; visited(N);
            <B><FONT COLOR="#A020F0">while</FONT></B> (!st.empty()) {
                <B><FONT COLOR="#228B22">int</FONT></B> u = st.top();
                visited[u] = true;
                <B><FONT COLOR="#A020F0">if</FONT></B> (cur_i[u] == SZ(adj[u])) {
                    ans.push_back(u);
                    st.pop();
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    <B><FONT COLOR="#228B22">int</FONT></B> v = adj[u][cur_i[u]];
                    st.push(v);
                    cur_i[u]++;
                }
            }
            reverse(ans.begin(), ans.end());
            REP(i, N) { <B><FONT COLOR="#A020F0">if</FONT></B> (!visited[i]) { <B><FONT COLOR="#A020F0">return</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(); } }
            <B><FONT COLOR="#A020F0">return</FONT></B> ans;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#A020F0">return</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;();
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    EulerPathDirectedGraph solver(4);
    solver.add_edge(0, 1);
    solver.add_edge(1, 2);
    solver.add_edge(2, 1);
    solver.add_edge(1, 0);
    solver.add_edge(0, 2);
    solver.add_edge(2, 3);
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; ans = solver.get_euler_path();
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> u : ans) {
        cout &lt;&lt; u &lt;&lt; endl;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file27">
<H1>graph/FordFulkerson.cpp 27/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file26">prev</A>][<A HREF="#file28">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  MaximumFlow by FordFulkerson (for sparse graph)
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> inf_flow = 2000000000;
<B><FONT COLOR="#228B22">class</FONT></B> FordFulkerson {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <I><FONT COLOR="#B22222">// runtime: O(E F), E = #edges, F = max flow values
</FONT></I>    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> edge {
        <B><FONT COLOR="#228B22">int</FONT></B> v;
        <B><FONT COLOR="#228B22">int</FONT></B> capacity; 
        <B><FONT COLOR="#228B22">int</FONT></B> flow; <I><FONT COLOR="#B22222">// current amount allowed to flow
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> rev_index; <I><FONT COLOR="#B22222">// store its reversed edge's index
</FONT></I>        edge(<B><FONT COLOR="#228B22">int</FONT></B> v_, <B><FONT COLOR="#228B22">int</FONT></B> c_, <B><FONT COLOR="#228B22">int</FONT></B> f_, <B><FONT COLOR="#228B22">int</FONT></B> rev) : v(v_), capacity(c_), flow(f_), rev_index(rev) {}
    } Edge;
    <B><FONT COLOR="#228B22">int</FONT></B> N; <I><FONT COLOR="#B22222">// node from 0 to N - 1
</FONT></I>    vector&lt;vector&lt;Edge&gt; &gt; maxFlowEdge;
    <B><FONT COLOR="#228B22">int</FONT></B> mark;   <I><FONT COLOR="#B22222">// global variable for checking if a node is already visited
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; seen;  <I><FONT COLOR="#B22222">// status of each node
</FONT></I>    FordFulkerson(<B><FONT COLOR="#228B22">int</FONT></B> numNode){
        N = numNode;
        maxFlowEdge = vector&lt;vector&lt;Edge&gt; &gt;(numNode);
        seen = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(numNode);
        mark = 0;
    }

    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to, <B><FONT COLOR="#228B22">int</FONT></B> cap){
        maxFlowEdge[from].push_back(Edge(to, cap, cap, maxFlowEdge[to].size()));
        maxFlowEdge[to].push_back(Edge(from, 0, 0, maxFlowEdge[from].size() - 1));
    }
 
    <B><FONT COLOR="#228B22">void</FONT></B> reset_flow(){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++ ){
            seen[i] = false;
            <B><FONT COLOR="#228B22">int</FONT></B> sz = maxFlowEdge[i].size();
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz; j++ ){
                maxFlowEdge[i][j].flow = maxFlowEdge[i][j].capacity;
            }
        }
    }
    
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> get_maxflow(<B><FONT COLOR="#228B22">int</FONT></B> S, <B><FONT COLOR="#228B22">int</FONT></B> T){
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> res = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B>(1){
            mark++;
            <B><FONT COLOR="#228B22">int</FONT></B> flow = find_augmenting_path(S, T, inf_flow);
            <B><FONT COLOR="#A020F0">if</FONT></B> (flow == 0) <B><FONT COLOR="#A020F0">break</FONT></B>;
            <B><FONT COLOR="#A020F0">else</FONT></B> res += flow;
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> find_augmenting_path(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> sink, <B><FONT COLOR="#228B22">int</FONT></B> val){
        <B><FONT COLOR="#228B22">int</FONT></B> sol = 0;
        seen[at] = mark;
        <B><FONT COLOR="#A020F0">if</FONT></B> (at == sink) <B><FONT COLOR="#A020F0">return</FONT></B> val;
        <B><FONT COLOR="#228B22">int</FONT></B> sz = maxFlowEdge[at].size();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++ ) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = maxFlowEdge[at][i].v;
            <B><FONT COLOR="#228B22">int</FONT></B> f = maxFlowEdge[at][i].flow;
            <B><FONT COLOR="#A020F0">if</FONT></B> (seen[v] != mark &amp;&amp; f &gt; 0){
                sol = find_augmenting_path(v, sink, min(f, val));
                <B><FONT COLOR="#A020F0">if</FONT></B> (sol) {
                    maxFlowEdge[at][i].flow -= sol;
                    <B><FONT COLOR="#228B22">int</FONT></B> rev = maxFlowEdge[at][i].rev_index;
                    maxFlowEdge[v][rev].flow += sol;
                    <B><FONT COLOR="#A020F0">return</FONT></B> sol;
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    FordFulkerson mf(3);
    mf.add_edge(0, 1, 2);
    mf.add_edge(1, 2, 2);
    assert(mf.get_maxflow(0, 2) == 2);

    mf = FordFulkerson(4);
    mf.add_edge(0, 1, 2);
    mf.add_edge(0, 2, 2);
    mf.add_edge(1, 3, 1);
    mf.add_edge(1, 2, 1);
    mf.add_edge(2, 3, 2);
    assert(mf.get_maxflow(0, 3) == 3);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file28">
<H1>graph/GlobalMinCut.cpp 28/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file27">prev</A>][<A HREF="#file29">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Global Minimum Cut
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">// Adjacency matrix implementation of Stoer-Wagner min cut algorithm.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time:
</FONT></I><I><FONT COLOR="#B22222">//     O(|V|^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph - adjacency matrix
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - (min cut value, nodes in half of min cut)
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Cost_t, Cost_t INF&gt;

<B><FONT COLOR="#228B22">class</FONT></B> GlobalMinCut {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;Cost_t&gt; VI;
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
    pair&lt;Cost_t, VI&gt; GetMinCut(VVI &amp;weights) {
        <B><FONT COLOR="#228B22">int</FONT></B> N = weights.size();
        VI used(N), cut, best_cut;
        <B><FONT COLOR="#228B22">int</FONT></B> best_weight = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> phase = N-1; phase &gt;= 0; phase--) {
            VI w = weights[0];
            VI added = used;
            <B><FONT COLOR="#228B22">int</FONT></B> prev, last = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; phase; i++) {
                prev = last;
                last = -1;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt; N; j++)
                    <B><FONT COLOR="#A020F0">if</FONT></B> (!added[j] &amp;&amp; (last == -1 || w[j] &gt; w[last])) last = j;
                <B><FONT COLOR="#A020F0">if</FONT></B> (i == phase-1) {
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++) weights[prev][j] += weights[last][j];
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++) weights[j][prev] = weights[prev][j];
                    used[last] = true;
                    cut.push_back(last);
                    <B><FONT COLOR="#A020F0">if</FONT></B> (best_weight == -1 || w[last] &lt; best_weight) {
                        best_cut = cut;
                        best_weight = w[last];
                    }
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++)
                        w[j] += weights[last][j];
                    added[last] = true;
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(best_weight, best_cut);
    }
};

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> INF = 1000000000;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N = 4;
    VVI graph (N);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) graph[i] = VI(N);
    <B><FONT COLOR="#228B22">int</FONT></B> in[4][4] = {{0, 4, 10, 0},
                    {0, 0, 1, 10},
                    {2, 0, 0, 2},
                    {0, 0, 0, 0}};
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++)
            graph[i][j] = in[i][j];
    GlobalMinCut&lt;<B><FONT COLOR="#228B22">int</FONT></B>, INF&gt; solver;
    pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, VI&gt; ret = solver.GetMinCut(graph);
    assert(ret.first == 1);
    cout &lt;&lt; ret.first &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>)ret.second.size(); i++) cout &lt;&lt; ret.second[i] &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
    

</PRE>
<HR>
<A NAME="file29">
<H1>graph/LCA.cpp 29/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file28">prev</A>][<A HREF="#file30">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Lowest Common Ancestor (LCA)
</FONT></I><I><FONT COLOR="#B22222">//  O(lgn) per query
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://www.spoj.com/status/LCA/
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stack&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))

<B><FONT COLOR="#228B22">class</FONT></B> LCA {
<B><FONT COLOR="#228B22">public</FONT></B>:
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; depths;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; parents;
    <B><FONT COLOR="#228B22">int</FONT></B> N, root, max_lvl;
    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>    LCA () {}
    LCA (<B><FONT COLOR="#228B22">int</FONT></B> root_, vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; &amp;graph) {
        root = root_; N = graph.size(); depths.resize(N);
        max_lvl = 1; <B><FONT COLOR="#A020F0">while</FONT></B> ((1&lt;&lt;max_lvl) &lt; N) max_lvl++;
        parents.resize(max_lvl, vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(N));
        build_lca(root, -1, graph, 0);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; max_lvl; i++)
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++)
                <B><FONT COLOR="#A020F0">if</FONT></B> (parents[i - 1][j] != -1) {
                    parents[i][j] = parents[i - 1][parents[i - 1][j]];
                }
    }
    <B><FONT COLOR="#228B22">int</FONT></B> lca(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (depths[u] &lt; depths[v]) swap(u, v);
        <B><FONT COLOR="#228B22">int</FONT></B> diff_dep = depths[u] - depths[v];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; max_lvl; i++)
            <B><FONT COLOR="#A020F0">if</FONT></B> ((1&lt;&lt;i) &amp; diff_dep) {
                u = parents[i][u];
            }
        <B><FONT COLOR="#A020F0">if</FONT></B> (u == v) {
            <B><FONT COLOR="#A020F0">return</FONT></B> u;
        }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = max_lvl - 1; i &gt;= 0; i--) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (parents[i][u] != parents[i][v]) {
                u = parents[i][u];
                v = parents[i][v];
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> parents[0][u];
    }
    <B><FONT COLOR="#228B22">int</FONT></B> get_depth(<B><FONT COLOR="#228B22">int</FONT></B> u) { <B><FONT COLOR="#A020F0">return</FONT></B> depths[u]; }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> build_lca(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> par, vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; &amp;adj, <B><FONT COLOR="#228B22">int</FONT></B> dep) {
        parents[0][at] = par;
        depths[at] = dep;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> v : adj[at]) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (v != par) {
                build_lca(v, at, adj, dep + 1);
            }
        }
    }
};
<I><FONT COLOR="#B22222">// Using a stack to build a tree (might be necessary)
</FONT></I><I><FONT COLOR="#B22222">// void build_lca(int at, int par, VVI &amp;adj, int dep) {
</FONT></I><I><FONT COLOR="#B22222">//     stack&lt;int&gt; S;
</FONT></I><I><FONT COLOR="#B22222">//     parents[0][at] = par;
</FONT></I><I><FONT COLOR="#B22222">//     depths[at] = dep;
</FONT></I><I><FONT COLOR="#B22222">//     S.push(at);
</FONT></I><I><FONT COLOR="#B22222">//     vector&lt;int&gt; cnt(N, 0);
</FONT></I><I><FONT COLOR="#B22222">//     while (!S.empty()) {
</FONT></I><I><FONT COLOR="#B22222">//         int u = S.top(); S.pop();
</FONT></I><I><FONT COLOR="#B22222">//         while (cnt[u] &lt; SZ(adj[u])) {
</FONT></I><I><FONT COLOR="#B22222">//             int v = adj[u][cnt[u]++];
</FONT></I><I><FONT COLOR="#B22222">//             if (v != parents[0][u]) {
</FONT></I><I><FONT COLOR="#B22222">//                 parents[0][v] = u;
</FONT></I><I><FONT COLOR="#B22222">//                 depths[v] = depths[u] + 1;
</FONT></I><I><FONT COLOR="#B22222">//                 S.push(v);
</FONT></I><I><FONT COLOR="#B22222">//                 if (cnt[u] &lt; SZ(adj[u])) S.push(u);
</FONT></I><I><FONT COLOR="#B22222">//                 break;
</FONT></I><I><FONT COLOR="#B22222">//             }
</FONT></I><I><FONT COLOR="#B22222">//         }
</FONT></I><I><FONT COLOR="#B22222">//     }
</FONT></I><I><FONT COLOR="#B22222">// }
</FONT></I>
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXN</FONT> 1005

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> test;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;test);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> tt = 0; tt &lt; test; tt++) {
        printf(<B><FONT COLOR="#BC8F8F">&quot;Case %d:\n&quot;</FONT></B>, tt + 1);
        <B><FONT COLOR="#228B22">int</FONT></B> N;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;N);
        VI parents (N, -1);
        VVI graph (N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> sz;
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;sz);
            <B><FONT COLOR="#228B22">int</FONT></B> v;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz; j++) {
                scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;v); v--;
                parents[v] = i;
                graph[i].push_back(v);
                graph[v].push_back(i);
            }
        }
        <B><FONT COLOR="#228B22">int</FONT></B> root = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (parents[root] != -1) root = parents[root];
        LCA solver(root, graph);
        <B><FONT COLOR="#228B22">int</FONT></B> Q;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;Q);
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; Q; i++) {
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;u, &amp;v); u--, v--;
            printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, solver.lca(u, v) + 1);
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file30">
<H1>graph/MaximumBipartiteMatching.cpp 30/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file29">prev</A>][<A HREF="#file31">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Maximum Bipartite Matching on undirected graph
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> MaximumBipartiteMatching {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; adj;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; pairs; <I><FONT COLOR="#B22222">// stores the previous node on the path
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> mark;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; seen;
    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>    MaximumBipartiteMatching() { N = 0; }
    MaximumBipartiteMatching(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) { adj.resize(N); pairs.resize(N); seen.resize(N); mark = 0; }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { adj[u].push_back(v); }
    <I><FONT COLOR="#B22222">// Requires the graph to be bipartite indirected.
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> maximum_matching() {
        assert(N &gt; 0);
        <B><FONT COLOR="#228B22">int</FONT></B> matching = 0;
        fill(pairs.begin(), pairs.end(), -1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) { mark++; matching += dfs(i); }
        <B><FONT COLOR="#A020F0">return</FONT></B> matching / 2; <I><FONT COLOR="#B22222">// return the number of pairs
</FONT></I>    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">bool</FONT></B> dfs(<B><FONT COLOR="#228B22">int</FONT></B> at){
        <B><FONT COLOR="#A020F0">if</FONT></B> (seen[at] == mark) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        seen[at] = mark;
        <B><FONT COLOR="#228B22">int</FONT></B> ss = adj[at].size();
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; ss; i++ ){
            <B><FONT COLOR="#228B22">int</FONT></B> v = adj[at][i];
            <B><FONT COLOR="#A020F0">if</FONT></B>(pairs[v] == -1 || dfs(pairs[v])){
                pairs[v] = at;
                <B><FONT COLOR="#A020F0">return</FONT></B> true;
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    MaximumBipartiteMatching solver(7);
    solver.add_edge(0, 3);
    solver.add_edge(3, 0);
    solver.add_edge(1, 4);
    solver.add_edge(4, 1);
    solver.add_edge(2, 4);
    solver.add_edge(4, 2);
    assert(solver.maximum_matching() == 2);
    solver.add_edge(2, 5);
    solver.add_edge(5, 2);
    assert(solver.maximum_matching() == 3);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
        
    

</PRE>
<HR>
<A NAME="file31">
<H1>graph/MinCostMaxFlow.cpp 31/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file30">prev</A>][<A HREF="#file32">next</A>]
<PRE>
<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Minimum Cost Maximum Flow Algorithm
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://codeforces.com/contest/362/problem/E
</FONT></I><I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;

<B><FONT COLOR="#228B22">const</FONT></B> LL inf_cost = 1000000000000LL;
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Flow_t, <B><FONT COLOR="#228B22">class</FONT></B> Cost_t&gt;
<B><FONT COLOR="#228B22">class</FONT></B> MinCostMaxFlow {
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;Cost_t, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PCI;
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">struct</FONT></B> Edge {
        <B><FONT COLOR="#228B22">int</FONT></B> to, rev;
        Flow_t capacity;
        Cost_t cost;
        Edge (<B><FONT COLOR="#228B22">int</FONT></B> t, <B><FONT COLOR="#228B22">int</FONT></B> r, Flow_t cap, Cost_t c) : to(t), rev(r), capacity(cap), cost(c) {}
    };
    vector&lt;vector&lt;Edge&gt; &gt; edges;
    MinCostMaxFlow (<B><FONT COLOR="#228B22">int</FONT></B> n) { <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>        edges.assign(n, vector&lt;Edge&gt;());
    }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge (<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to, Flow_t cap, Cost_t cost) {
        Edge f = Edge(to, SZ(edges[to]), cap, cost);
        Edge b = Edge(from, SZ(edges[from]), 0, -cost);
        edges[from].push_back(f), edges[to].push_back(b);
    }
    <I><FONT COLOR="#B22222">// Using SPFA (Shortest Path Faster Algor) for negative cost
</FONT></I>    <I><FONT COLOR="#B22222">// Using Dijkstra for non-negative cost
</FONT></I>    <I><FONT COLOR="#B22222">// f is the require amount of flow
</FONT></I>    pair&lt;Flow_t, Cost_t&gt; get_min_cost_max_flow (<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t, Flow_t f = inf_cost, <B><FONT COLOR="#228B22">bool</FONT></B> useSPFA = false) {
        <B><FONT COLOR="#228B22">int</FONT></B> n = SZ(edges);
        vector&lt;Cost_t&gt; dist(n); vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; prev(n), prev_edge(n);
        pair&lt;Flow_t, Cost_t&gt; res = make_pair(0, 0);
        vector&lt;Cost_t&gt; potential(n);
        <B><FONT COLOR="#A020F0">while</FONT></B> (f &gt; 0) {
            fill(dist.begin(), dist.end(), inf_cost);
            <B><FONT COLOR="#A020F0">if</FONT></B> (useSPFA || res.first == 0) {
                queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; Q;
                Q.push(s); dist[s] = 0; vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; inqueue(n);
                <B><FONT COLOR="#A020F0">while</FONT></B> (!Q.empty()) {
                    <B><FONT COLOR="#228B22">int</FONT></B> u = Q.front(); Q.pop();
                    inqueue[u] = false;
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(edges[u]); i++) {
                        <B><FONT COLOR="#228B22">int</FONT></B> v = edges[u][i].to;
                        <B><FONT COLOR="#A020F0">if</FONT></B> (edges[u][i].capacity &gt; 0 &amp;&amp; dist[u] + edges[u][i].cost &lt; dist[v]) {
                            <B><FONT COLOR="#A020F0">if</FONT></B> (!inqueue[v]) {
                                inqueue[v] = true;
                                Q.push(v);
                            }
                            dist[v] = dist[u] + edges[u][i].cost;
                            prev[v] = u; prev_edge[v] = i;
                        }
                    }

                }
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                priority_queue&lt;PCI, vector&lt;PCI&gt;, greater&lt;PCI&gt; &gt; Q;
                Q.push(PCI(0, s)); dist[s] = 0; vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; visited(n);
                <B><FONT COLOR="#A020F0">while</FONT></B> (!Q.empty()) {
                    <B><FONT COLOR="#228B22">int</FONT></B> u = Q.top().second; Q.pop();
                    <B><FONT COLOR="#A020F0">if</FONT></B> (visited[u]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                    visited[u] = true;
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(edges[u]); i++) {
                        <B><FONT COLOR="#228B22">int</FONT></B> v = edges[u][i].to;
                        <B><FONT COLOR="#A020F0">if</FONT></B> (edges[u][i].capacity &gt; 0) {
                            Cost_t d = dist[u] + edges[u][i].cost + potential[u] - potential[v];
                            <B><FONT COLOR="#A020F0">if</FONT></B> (dist[v] &gt; d) {
                                dist[v] = d;
                                prev[v] = u; prev_edge[v] = i;
                                Q.push(PCI(d, v));
                            }
                        }
                    }
                }
            }
            <B><FONT COLOR="#A020F0">if</FONT></B> (dist[t] == inf_cost) <B><FONT COLOR="#A020F0">break</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (!useSPFA) <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) potential[i] += dist[i];
            Flow_t min_f = f; Cost_t c = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v = t; v != s; v = prev[v]) {
                <B><FONT COLOR="#228B22">int</FONT></B> u = prev[v], eid = prev_edge[v];
                min_f = min(min_f, edges[u][eid].capacity);
                c += edges[u][eid].cost;
            }
            f -= min_f; res.first += min_f; res.second += min_f * c;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v = t; v != s; v = prev[v]) {
                <B><FONT COLOR="#228B22">int</FONT></B> u = prev[v], eid = prev_edge[v];
                edges[u][eid].capacity -= min_f;
                edges[edges[u][eid].to][edges[u][eid].rev].capacity += min_f;
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
};

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (1000000000)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXN</FONT> 55
<B><FONT COLOR="#228B22">int</FONT></B> caps[MAXN][MAXN];

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    <B><FONT COLOR="#228B22">int</FONT></B> N, K;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;N, &amp;K);

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++ )
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++ )
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;caps[i][j]);

    <B><FONT COLOR="#228B22">int</FONT></B> left = 0, right = 1000000000;
    <B><FONT COLOR="#A020F0">while</FONT></B>(left &lt;= right){
        <B><FONT COLOR="#228B22">int</FONT></B> mid = (left + right) / 2;
        MinCostMaxFlow&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt; mcf(N);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++ )
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++ ){
                <B><FONT COLOR="#A020F0">if</FONT></B>(caps[i][j] == 0) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                mcf.add_edge(i, j, caps[i][j], 0);
                mcf.add_edge(i, j, INF, 1);
            }

        pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt; p = mcf.get_min_cost_max_flow(0, N - 1, mid);
        <B><FONT COLOR="#A020F0">if</FONT></B> (p.first != mid || p.second &gt; K) {
            right = mid - 1;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            left = mid + 1;
        }
    }

    cout &lt;&lt; right &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file32">
<H1>graph/MinimumPathCoverDAG.cpp 32/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file31">prev</A>][<A HREF="#file33">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Minimum Path Cover on DAG (the minimum number of paths we need so that all nodes are
</FONT></I><I><FONT COLOR="#B22222">//  part of exactly one path)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Notice: From the DAG with n points, we make a bipartite graph with n points on each side.
</FONT></I><I><FONT COLOR="#B22222">//  For each edge (u, v) in the DAG, we draw an edge between u on the left side and v on
</FONT></I><I><FONT COLOR="#B22222">//  the right side in the bipartite graph.
</FONT></I><I><FONT COLOR="#B22222">//  Then, the number of minimum path cover is just n - #max_matchings
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> MaximumBipartiteMatching {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; adj;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; pairs; <I><FONT COLOR="#B22222">// stores the previous node on the path
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> mark;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; seen;
    MaximumBipartiteMatching() { N = 0; }
    MaximumBipartiteMatching(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) { adj.resize(N); pairs.resize(N); seen.resize(N); mark = 0; }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { adj[u].push_back(v); }
    <I><FONT COLOR="#B22222">// Requires the graph to be bipartite indirected.
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> maximum_matching() {
        assert(N &gt; 0);
        <B><FONT COLOR="#228B22">int</FONT></B> matching = 0;
        fill(pairs.begin(), pairs.end(), -1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) { mark++; matching += dfs(i); }
        <B><FONT COLOR="#A020F0">return</FONT></B> matching / 2; <I><FONT COLOR="#B22222">// return the number of pairs
</FONT></I>    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">bool</FONT></B> dfs(<B><FONT COLOR="#228B22">int</FONT></B> at){
        <B><FONT COLOR="#A020F0">if</FONT></B> (seen[at] == mark) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        seen[at] = mark;
        <B><FONT COLOR="#228B22">int</FONT></B> ss = adj[at].size();
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; ss; i++ ){
            <B><FONT COLOR="#228B22">int</FONT></B> v = adj[at][i];
            <B><FONT COLOR="#A020F0">if</FONT></B>(pairs[v] == -1 || dfs(pairs[v])){
                pairs[v] = at;
                <B><FONT COLOR="#A020F0">return</FONT></B> true;
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
};

<B><FONT COLOR="#228B22">class</FONT></B> MinimumPathCoverDAG {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; adj;
    MaximumBipartiteMatching solver;
    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>    MinimumPathCoverDAG(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) { adj.resize(N); }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { adj[u].push_back(v); }
    <B><FONT COLOR="#228B22">int</FONT></B> minimum_path_cover() {
        solver = MaximumBipartiteMatching(2 * N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[i].size();
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz; j++) {
                solver.add_edge(i, adj[i][j] + N);
                solver.add_edge(adj[i][j] + N, i);
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> N - solver.maximum_matching();
    }
    <B><FONT COLOR="#228B22">void</FONT></B> print_path() {
        vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; seen (N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (!seen[i]) { seen[i] = true; <B><FONT COLOR="#228B22">int</FONT></B> now = i; <B><FONT COLOR="#228B22">bool</FONT></B> found = true;
                printf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, i);
                <B><FONT COLOR="#A020F0">while</FONT></B> (found) { found = false;
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = N; j &lt; 2 * N; j++) {
                        <B><FONT COLOR="#A020F0">if</FONT></B> (solver.pairs[j] == now) {
                            now = j - N; seen[now] = true; found = true; <B><FONT COLOR="#A020F0">break</FONT></B>;
                        }
                    }
                    <B><FONT COLOR="#A020F0">if</FONT></B> (found) printf(<B><FONT COLOR="#BC8F8F">&quot; -&gt; %d&quot;</FONT></B>, now);
                }
                printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
            }
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    MinimumPathCoverDAG solver(7);
    solver.add_edge(0, 1);
    solver.add_edge(3, 1);
    solver.add_edge(1, 6);
    solver.add_edge(4, 6);
    solver.add_edge(6, 2);
    solver.add_edge(6, 5);
    assert(solver.minimum_path_cover() == 4);
    solver.print_path();
    solver.add_edge(3, 2);
    assert(solver.minimum_path_cover() == 3);
    printf(<B><FONT COLOR="#BC8F8F">&quot;---------\n&quot;</FONT></B>);
    solver.print_path();
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file33">
<H1>graph/MinimumSpanningTree.cpp 33/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file32">prev</A>][<A HREF="#file34">next</A>]
<PRE>
<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  MinimumSpanningTree (by Kruskal
</FONT></I><I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Cost_t&gt;
<B><FONT COLOR="#228B22">class</FONT></B> MinimumSpanningTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> edge_st {
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        Cost_t c;
        <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> &lt; (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> edge_st &amp;o) <B><FONT COLOR="#228B22">const</FONT></B> {
            <B><FONT COLOR="#A020F0">return</FONT></B> c &lt; o.c;
        }
    } Edge;
    vector&lt;Edge&gt; edges;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; parents;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    <I><FONT COLOR="#B22222">// Vertices are 1-based indexed.
</FONT></I>    MinimumSpanningTree(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) { parents.resize(n + 5); }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, Cost_t c) { Edge e = {u, v, c}; edges.push_back(e); }
    Cost_t kruskal() {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) parents[i] = i;        
        <B><FONT COLOR="#228B22">int</FONT></B> sz = edges.size();
        sort(edges.begin(), edges.end());
        Cost_t res = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> need_edge = N - 1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz &amp;&amp; need_edge; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> pu = find_parent(edges[i].u);
            <B><FONT COLOR="#228B22">int</FONT></B> pv = find_parent(edges[i].v);
            <B><FONT COLOR="#A020F0">if</FONT></B> (pu != pv) { res += edges[i].c; need_edge--; parents[pu] = pv; }
        }
        assert(need_edge == 0);
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> find_parent(<B><FONT COLOR="#228B22">int</FONT></B> u) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (u == parents[u]) <B><FONT COLOR="#A020F0">return</FONT></B> u;
        <B><FONT COLOR="#A020F0">return</FONT></B> parents[u] = find_parent(parents[u]);
    }
};    
        
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    MinimumSpanningTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; mst(5);
    mst.add_edge(1, 4, 1);
    mst.add_edge(1, 4, 7);
    mst.add_edge(2, 3, 5);
    mst.add_edge(5, 3, 9);
    mst.add_edge(1, 3, 4);
    mst.add_edge(1, 2, 3);
    mst.add_edge(2, 5, 2);
    assert(mst.kruskal() == 10);
    mst.add_edge(1, 3, 1);
    assert(mst.kruskal() == 7);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file34">
<H1>graph/ShortestPath.cpp 34/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file33">prev</A>][<A HREF="#file35">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Shortest Path
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Cost_t, Cost_t INF&gt;
<B><FONT COLOR="#228B22">class</FONT></B> ShortestPath {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;Cost_t, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PCI; <I><FONT COLOR="#B22222">// (cost, vertex)
</FONT></I>    vector&lt;vector&lt;PCI&gt; &gt; adj;
    vector&lt;Cost_t&gt; min_cost;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    <I><FONT COLOR="#B22222">// Vertices are 1-based indexed.
</FONT></I>    ShortestPath(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) { adj.resize(N + 5); min_cost.resize(N + 5); }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, Cost_t c) { adj[u].push_back(PCI(c, v)); }
    Cost_t dijkstra(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to) { dijkstra_algorithm(from, to); <B><FONT COLOR="#A020F0">return</FONT></B> min_cost[to]; }
    vector&lt;Cost_t&gt; dijkstra(<B><FONT COLOR="#228B22">int</FONT></B> from) { dijkstra_algorithm(from, -1); <B><FONT COLOR="#A020F0">return</FONT></B> min_cost; }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> dijkstra_algorithm(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to){
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        Cost_t c;
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++ ) { min_cost[i] = INF; }
        min_cost[from] = 0;
        priority_queue&lt;PCI, vector&lt;PCI&gt;, greater&lt;PCI&gt; &gt; Q;
        vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; seen (N + 5);
        Q.push(PCI(min_cost[from], from));
        <B><FONT COLOR="#A020F0">while</FONT></B> (!Q.empty()) {
            u = Q.top().second;
            Q.pop();
            <B><FONT COLOR="#A020F0">if</FONT></B> (u == to) <B><FONT COLOR="#A020F0">break</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (seen[u]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            seen[u] = true;
            <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[u].size();
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
                v = adj[u][i].second;
                c = adj[u][i].first;
                <B><FONT COLOR="#A020F0">if</FONT></B> (!seen[v] &amp;&amp; min_cost[v] &gt; min_cost[u] + c) {
                    min_cost[v] = min_cost[u] + c;
                    Q.push(PCI(min_cost[v], v));
                }
            }
        }
    }
};

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (1000000000)

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    ShortestPath&lt;<B><FONT COLOR="#228B22">int</FONT></B>, INF&gt; solver(5);
    solver.add_edge(1, 2, 3);
    solver.add_edge(2, 1, 3);
    solver.add_edge(1, 3, 1);
    solver.add_edge(3, 1, 1);
    solver.add_edge(3, 2, 1);
    solver.add_edge(2, 3, 1);
    solver.add_edge(4, 2, 2);
    solver.add_edge(2, 4, 2);
    assert(solver.dijkstra(1, 4) == 4);
    assert(solver.dijkstra(1, 5) == INF);
    solver.add_edge(4, 5, 1);
    solver.add_edge(5, 4, 1);
    assert(solver.dijkstra(1, 5) == 5);
    solver.add_edge(1, 5, 2);
    solver.add_edge(5, 1, 2);
    assert(solver.dijkstra(1, 5) == 2);
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; dist = solver.dijkstra(5);
    assert(dist[1] == 2);
    assert(dist[2] == 3);
    assert(dist[3] == 3);
    assert(dist[4] == 1);
    assert(dist[5] == 0);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file35">
<H1>graph/StronglyConnectedComponent.cpp 35/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file34">prev</A>][<A HREF="#file36">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Strongly Connected Component
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstring&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> StronglyConnectedComponent {
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI; <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">struct</FONT></B> edge{
        <B><FONT COLOR="#228B22">int</FONT></B> e, nxt;
        edge() {}
        edge(<B><FONT COLOR="#228B22">int</FONT></B> _e, <B><FONT COLOR="#228B22">int</FONT></B> _nxt) : e(_e), nxt(_nxt) {}
    };
    <B><FONT COLOR="#228B22">int</FONT></B> V, E;
    vector&lt;edge&gt; e, er;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; sp, spr, group_num, stk;
    <B><FONT COLOR="#228B22">int</FONT></B> group_cnt; vector&lt;set&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; graph; <I><FONT COLOR="#B22222">// reduced graph
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; visited;
    <I><FONT COLOR="#B22222">// Vertices are 1-based indexed.
</FONT></I>    StronglyConnectedComponent() {}
    StronglyConnectedComponent(<B><FONT COLOR="#228B22">int</FONT></B> _V) {
        V = _V; E = 0; group_cnt = 0; group_num = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(V + 5);
        sp = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(V + 5); spr = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(V + 5); stk = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(V + 5);
        visited = vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt;(V + 5); e.push_back(edge()); er.push_back(edge());
    }
    <B><FONT COLOR="#228B22">void</FONT></B> fill_forward(<B><FONT COLOR="#228B22">int</FONT></B> x){
        visited[x] = true;
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = sp[x]; i; i = e[i].nxt) <B><FONT COLOR="#A020F0">if</FONT></B> (!visited[e[i].e]) fill_forward(e[i].e);
        stk[++stk[0]] = x;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> fill_backward(<B><FONT COLOR="#228B22">int</FONT></B> x){
        visited[x] = false;
        group_num[x] = group_cnt;
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = spr[x]; i; i = er[i].nxt) <B><FONT COLOR="#A020F0">if</FONT></B> (visited[er[i].e]) fill_backward(er[i].e);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> v1, <B><FONT COLOR="#228B22">int</FONT></B> v2){ <I><FONT COLOR="#B22222">// Add edge v1-&gt;v2
</FONT></I>        E++;
        e.push_back(edge(v2, sp[v1])); sp[v1] = E;
        er.push_back(edge(v1, spr[v2])); spr[v2] = E;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> cal_scc() {
        stk[0] = 0;
        fill(visited.begin(), visited.end(), false);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= V; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (!visited[i]) fill_forward(i);
        group_cnt = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = stk[0]; i &gt;= 1; i--) <B><FONT COLOR="#A020F0">if</FONT></B> (visited[stk[i]]) { group_cnt++; fill_backward(stk[i]); }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> cal_reduced_graph() { <I><FONT COLOR="#B22222">// need to call cal_scc() before
</FONT></I>        graph = vector&lt;set&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt;(group_cnt + 1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= V; i++) { <B><FONT COLOR="#228B22">int</FONT></B> u = group_num[i];
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = sp[i]; j; j = e[j].nxt) {
                <B><FONT COLOR="#228B22">int</FONT></B> v = group_num[e[j].e];
                <I><FONT COLOR="#B22222">// If we don't need to remove duplicates, use Vector instead of Set.
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> (u != v) graph[u].insert(v); 
            }
        }
    }
};

<I><FONT COLOR="#B22222">///////////
</FONT></I><I><FONT COLOR="#B22222">//  2-SAT
</FONT></I><I><FONT COLOR="#B22222">///////////
</FONT></I>
<I><FONT COLOR="#B22222">/*
0. V = 2 * N (N = the number of variables)
1. Add edges:(a || b) -&gt; edge(~a, b), edge(~b, a)
2. SCC()
3. it's possible if a and ~a are in the difference components (different group_num[])
4. Ans: if group_num[a] &gt; group_num[~a], assign a to True
*/</FONT></I>
</PRE>
<HR>
<A NAME="file36">
<H1>number/FFT.cpp 36/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file35">prev</A>][<A HREF="#file37">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Fast Fourier Transform
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  fft  X_k =         \sum_{j=0}^{N - 1} x_k e^{-i * 2pi * j * k / N}
</FONT></I><I><FONT COLOR="#B22222">//  ifft x_k = (1/N) * \sum_{j=0}^{N - 1} x_k e^{ i * 2pi * j * k / N}
</FONT></I><I><FONT COLOR="#B22222">//  ex:
</FONT></I><I><FONT COLOR="#B22222">//  [1, 2, 3, 4]
</FONT></I><I><FONT COLOR="#B22222">//  [5, 6, 7, 8]
</FONT></I><I><FONT COLOR="#B22222">//  66: 5 * 1 + 6 * 4 + 7 * 3 + 8 * 2
</FONT></I><I><FONT COLOR="#B22222">//  68: 5 * 2 + 6 * 1 + 7 * 4 + 8 * 3
</FONT></I><I><FONT COLOR="#B22222">//  66: 5 * 3 + 6 * 2 + 7 * 1 + 8 * 4
</FONT></I><I><FONT COLOR="#B22222">//  60: 5 * 4 + 6 * 3 + 7 * 2 + 8 * 1
</FONT></I><I><FONT COLOR="#B22222">//  Usage
</FONT></I><I><FONT COLOR="#B22222">//  Given x[0...N-1], y[0...N-1]
</FONT></I><I><FONT COLOR="#B22222">//  The convolution z[n] = sum of x[k]y[n-k] (k = 0,...,N-1)
</FONT></I><I><FONT COLOR="#B22222">//  The index is cyclic: x[-1]=x[N-1], etc.
</FONT></I><I><FONT COLOR="#B22222">//  To find z[] in O(NlgN)
</FONT></I><I><FONT COLOR="#B22222">//     1. Compute X = fft(x), Y = fft(y)
</FONT></I><I><FONT COLOR="#B22222">//     2. fft(z) = Z = X * Y (element-wise multiplication)
</FONT></I><I><FONT COLOR="#B22222">//     3. z = ifft(Z)
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)(x).size())
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PB</FONT></B>(x) push_back(x)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MEMSET</FONT></B>(x,v) memset(x,v,sizeof(x))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;

<B><FONT COLOR="#228B22">class</FONT></B> FFT {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">const</FONT></B> LL mod = 5 * (1 &lt;&lt; 25) + 1;
    <B><FONT COLOR="#228B22">const</FONT></B> LL root = 243;
    <B><FONT COLOR="#228B22">const</FONT></B> LL root_1 = 114609789;
    <B><FONT COLOR="#228B22">const</FONT></B> LL root_pw = 1&lt;&lt;25;
    LL gcd(LL a, LL b, LL &amp;s, LL &amp;t) { <I><FONT COLOR="#B22222">// a * s + b * t = g
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (b==0) {
            t = 0; s = (a &lt; 0) ? -1 : 1; <B><FONT COLOR="#A020F0">return</FONT></B> (a &lt; 0) ? -a : a;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            LL g = gcd(b, a%b, t, s);  t -= a/b*s;  <B><FONT COLOR="#A020F0">return</FONT></B> g;
        }
    }
    LL inverse(LL n, LL mod) {
        LL s, t;
        gcd(n, mod, s, t);
        <B><FONT COLOR="#A020F0">return</FONT></B> (s &gt; 0) ? s : s + mod;
    }
    <I><FONT COLOR="#B22222">// Length of a is a power of 2
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> fft (vector&lt;LL&gt; &amp; a, <B><FONT COLOR="#228B22">bool</FONT></B> invert) {
        assert(__builtin_popcount(SZ(a)) == 1);
        <B><FONT COLOR="#228B22">int</FONT></B> n = (<B><FONT COLOR="#228B22">int</FONT></B>) a.size();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1, j = 0; i &lt; n; ++i) {
            <B><FONT COLOR="#228B22">int</FONT></B> bit = n &gt;&gt; 1;
            <B><FONT COLOR="#A020F0">for</FONT></B> (; j &gt;= bit; bit &gt;&gt;= 1)
                j -= bit;
            j += bit;
            <B><FONT COLOR="#A020F0">if</FONT></B> (i &lt; j) swap (a[i], a[j]);
        }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> len = 2; len &lt;= n; len &lt;&lt;= 1) {
            LL wlen = invert ? root_1 : root;
            <B><FONT COLOR="#A020F0">for</FONT></B> (LL i = len; i &lt; root_pw; i &lt;&lt;= 1)
                wlen = LL (wlen * 1LL * wlen % mod);
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i += len) {
                LL w = 1;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; len / 2; ++j) {
                    LL u = a[i + j],  v = LL (a[i + j + len/2] * 1LL * w % mod);
                    a[i + j] = u + v &lt; mod ? u + v : u + v - mod;
                    a[i + j + len / 2] = u - v &gt;= 0 ? u - v : u - v + mod;
                    w = LL (w * 1LL * wlen % mod);
                }
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (invert) {
            LL nrev = inverse(n, mod);
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; ++i)
                a[i] = LL (a[i] * 1LL * nrev % mod);
        }
    }
    vector&lt;LL&gt; multiply(vector&lt;LL&gt; &amp;a, vector&lt;LL&gt; &amp;b) {
        <B><FONT COLOR="#228B22">int</FONT></B> n = SZ(a);
        vector&lt;LL&gt; res(n);
        fft(a, false);
        fft(b, false);
        REP(i, n) res[i] = a[i] * b[i] % mod;
        fft(res, true);
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    vector&lt;LL&gt; a = {1, 2, 3, 4};
    vector&lt;LL&gt; b = {5, 6, 7, 8};
    FFT solver;
    vector&lt;LL&gt; c = solver.multiply(a, b);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> x : c) cout &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cout &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file37">
<H1>number/LinearAlgebra.cpp 37/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file36">prev</A>][<A HREF="#file38">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Linear Algebra/ Solving a system of linear equation
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;

<I><FONT COLOR="#B22222">// Compute the totient of the numbers in [1, maxn)
</FONT></I><I><FONT COLOR="#B22222">// phi(n) = n(1-1/p1)(1-1/p2)...(1-1/pi), pi | n
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">compute_totient</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> maxn, <B><FONT COLOR="#228B22">int</FONT></B> phi[]) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; maxn; i++) {
        phi[i] += i;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i * 2; j &lt; maxn; j += i) {
            phi[j] -= phi[i];
        }
    }
}

<I><FONT COLOR="#B22222">// Compute n choose m
</FONT></I>LL <B><FONT COLOR="#0000FF">binomial</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n, <B><FONT COLOR="#228B22">int</FONT></B> m) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (n &lt; m || n &lt; 0 || m &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    LL ans = 1, ans2 = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) {
        ans *= n - i;
        ans2 *= i + 1;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ans / ans2;
}

<I><FONT COLOR="#B22222">// compute catalan number (n &gt;= 0)
</FONT></I><I><FONT COLOR="#B22222">// 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, ...
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Ex. Number of ways to insert n pairs of parentheses in a word of n+1 letters.
</FONT></I><I><FONT COLOR="#B22222">//     E.g., for n=3 there are 5 ways: ((ab)(cd)), (((ab)c)d), ((a(bc))d), (a((bc)d)), (a(b(cd))).
</FONT></I>LL <B><FONT COLOR="#0000FF">catalan_number</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n) {
    <B><FONT COLOR="#A020F0">return</FONT></B> binomial(n * 2, n) / (n + 1);
}

<I><FONT COLOR="#B22222">// return a % b (positive value)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
T mod(T a, T b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> ((a%b)+b)%b;
}

<I><FONT COLOR="#B22222">// computes gcd(a,b)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
T gcd(T a, T b) {
    T tmp;
    <B><FONT COLOR="#A020F0">while</FONT></B> (b) {
        a%=b; tmp=a; a=b; b=tmp;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> a;
}

<I><FONT COLOR="#B22222">// computes lcm(a,b)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
T lcm(T a, T b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a / gcd(a,b) * b;
}

<I><FONT COLOR="#B22222">// returns d = gcd(a,b); finds x,y such that d = ax + by
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
T extended_euclid(T a, T b, T &amp;x, T &amp;y) {  
    T xx = y = 0;
    T yy = x = 1;
    <B><FONT COLOR="#A020F0">while</FONT></B> (b) {
        T q = a / b;
        T t = b; b = a % b; a = t;
        t = xx; xx = x - q * xx; x = t;
        t = yy; yy = y - q * yy; y = t;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> a;
}

<I><FONT COLOR="#B22222">// computes b such that ab = 1 (mod n), returns -1 on failure
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
T mod_inverse(T a, T n) {
    T x, y;
    T d = extended_euclid(a, n, x, y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (d &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> -1;
    <B><FONT COLOR="#A020F0">return</FONT></B> mod(x,n);
}

<I><FONT COLOR="#B22222">// finds all solutions to ax = b (mod n)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
vector&lt;T&gt; modular_linear_equation_solver(T a, T b, T n) {
    T x, y;
    vector&lt;T&gt; solutions;
    T d = extended_euclid(a, n, x, y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(b%d)) {
        x = mod (x*(b/d), n);
        <B><FONT COLOR="#A020F0">for</FONT></B> (T i = 0; i &lt; d; i++)
            solutions.push_back(mod(x + i*(n/d), n));
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> solutions;
}


<I><FONT COLOR="#B22222">//  return the smallest value of x s.t x &gt;= lowerBound 
</FONT></I><I><FONT COLOR="#B22222">//  and ax = c (mod b) 
</FONT></I>LL <B><FONT COLOR="#0000FF">get_greater</FONT></B>(LL c, LL a, LL b, LL lowerBound){
    LL x, y;
    LL A = a, B = b, C = c;
    LL g = extended_euclid(A, B, x, y);
    x = (x + B) % B;
    LL key = (-C) * x / g;
    LL k = (lowerBound - key) / B;
    LL ret = key + B * k;
    <B><FONT COLOR="#A020F0">while</FONT></B>(ret &lt; lowerBound){
        <B><FONT COLOR="#A020F0">if</FONT></B>(B &gt; 0) ret += B; 
        <B><FONT COLOR="#A020F0">else</FONT></B> ret -= B;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">//  return the largest value of x s.t x &lt;= upperBound
</FONT></I><I><FONT COLOR="#B22222">//	and ax = c (mod b)
</FONT></I>LL <B><FONT COLOR="#0000FF">get_less</FONT></B>(LL c, LL a, LL b, LL upperBound){
    LL x, y;
    LL A = a, B = b, C = c;
    LL g = extended_euclid(A, B, x, y);
    x = (x + B) % B;
    LL key = (-C) * x / g;
    LL k = (upperBound - key) / B;
    LL ret = key + B * k;
    <I><FONT COLOR="#B22222">// for edge case
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(B &gt; 0) ret += 2 * B;
    <B><FONT COLOR="#A020F0">else</FONT></B> ret -= 2 * B;
    <B><FONT COLOR="#A020F0">while</FONT></B>(ret &gt; upperBound){
        <B><FONT COLOR="#A020F0">if</FONT></B>(B &gt; 0) ret -= B; 
        <B><FONT COLOR="#A020F0">else</FONT></B> ret += B;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// Chinese remainder theorem (special case): find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % x = a, z % y = b.  Here, z is unique modulo M = lcm(x,y).
</FONT></I><I><FONT COLOR="#B22222">// Return (z,M).  On failure, M = -1.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
pair&lt;T, T&gt; chinese_remainder_theorem(T x, T a, T y, T b) {
    T s, t;
    T d = extended_euclid(x, y, s, t);
    <B><FONT COLOR="#A020F0">if</FONT></B> (a%d != b%d) <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(0, -1);
    <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(mod(s*b*x+t*a*y,x*y)/d, x*y/d);
}

<I><FONT COLOR="#B22222">// Chinese remainder theorem: find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % x[i] = a[i] for all i.  Note that the solution is
</FONT></I><I><FONT COLOR="#B22222">// unique modulo M = lcm_i (x[i]).  Return (z,M).  On 
</FONT></I><I><FONT COLOR="#B22222">// failure, M = -1.  Note that we do not require the a[i]'s
</FONT></I><I><FONT COLOR="#B22222">// to be relatively prime.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
pair&lt;T, T&gt; chinese_remainder_theorem(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;T&gt; &amp;x, <B><FONT COLOR="#228B22">const</FONT></B> vector&lt;T&gt; &amp;a) {
    PII ret = make_pair(a[0], x[0]);
    <B><FONT COLOR="#A020F0">for</FONT></B> (T i = 1; i &lt; x.size(); i++) {
        ret = chinese_remainder_theorem(ret.second, ret.first, x[i], a[i]);
        <B><FONT COLOR="#A020F0">if</FONT></B> (ret.second == -1) <B><FONT COLOR="#A020F0">break</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// computes x and y such that ax + by = c; on failure, x = y =-1
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">linear_diophantine</FONT></B>(T a, T b, T c, T &amp;x, T &amp;y) {
    T d = gcd(a, b);
    <B><FONT COLOR="#A020F0">if</FONT></B> (c % d) {
        x = y = -1;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
        x = c / d * mod_inverse(a / d, b / d);
        y = (c - a * x) / b;
    }
}

<I><FONT COLOR="#B22222">///////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  GaussJordan
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">// Gauss-Jordan elimination with full pivoting.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Uses:
</FONT></I><I><FONT COLOR="#B22222">//   (1) solving systems of linear equations (AX=B)
</FONT></I><I><FONT COLOR="#B22222">//   (2) inverting matrices (AX=I)
</FONT></I><I><FONT COLOR="#B22222">//   (3) computing determinants of square matrices
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    a[][] = an nxn matrix
</FONT></I><I><FONT COLOR="#B22222">//           b[][] = an nxm matrix
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   X      = an nxm matrix (stored in b[][])
</FONT></I><I><FONT COLOR="#B22222">//           A^{-1} = an nxn matrix (stored in a[][])
</FONT></I><I><FONT COLOR="#B22222">//           returns determinant of a[][]
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-10;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

T GaussJordan(VVT &amp;a, VVT &amp;b) {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = a.size();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = b[0].size();
    VI irow(n), icol(n), ipiv(n);
    T det = 1;
    
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> pj = -1, pk = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) 
            <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[j])
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) 
                    <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[k])
                        <B><FONT COLOR="#A020F0">if</FONT></B> (pj == -1 || fabs(a[j][k]) &gt; fabs(a[pj][pk])) { pj = j; pk = k; }
        <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[pj][pk]) &lt; EPS) { cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Matrix is singular.&quot;</FONT></B> &lt;&lt; endl; exit(0); }
        ipiv[pk]++;
        swap(a[pj], a[pk]);
        swap(b[pj], b[pk]);
        <B><FONT COLOR="#A020F0">if</FONT></B> (pj != pk) det *= -1;
        irow[i] = pj;
        icol[i] = pk;

        T c = 1.0 / a[pk][pk];
        det *= a[pk][pk];
        a[pk][pk] = 1.0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++) a[pk][p] *= c;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; m; p++) b[pk][p] *= c;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++) 
            <B><FONT COLOR="#A020F0">if</FONT></B> (p != pk) {
                c = a[p][pk];
                a[p][pk] = 0;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; n; q++) a[p][q] -= a[pk][q] * c;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; m; q++) b[p][q] -= b[pk][q] * c;      
            }
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = n-1; p &gt;= 0; p--) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (irow[p] != icol[p]) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) 
                swap(a[k][irow[p]], a[k][icol[p]]);
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> det;
}

<I><FONT COLOR="#B22222">//////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  ReducedRowEchelonForm/ Find Rank
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  can be modified to find a normal rank of an nxn matrix
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////
</FONT></I>
<B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">findRank</FONT></B>(vector&lt;vector&lt;T&gt; &gt; &amp;a, vector&lt;T&gt; &amp;b, T p) {
    <I><FONT COLOR="#B22222">// M equations, N variables, modulo p
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> M = a.size();
    <B><FONT COLOR="#228B22">int</FONT></B> N = a[0].size();
    <B><FONT COLOR="#228B22">int</FONT></B> ans = 0;     
     
    <I><FONT COLOR="#B22222">// Using Gauss-Jordan in [ A : b ] to make it in row-echellon form.
</FONT></I>    <I><FONT COLOR="#B22222">// So that we can find the rank. We also need to make sure that the
</FONT></I>    <I><FONT COLOR="#B22222">// rank of [ A ] is equal to the rank of [A : b], else there are
</FONT></I>    <I><FONT COLOR="#B22222">// no solutions
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> c = 0; c &lt; N; c++) {
        <B><FONT COLOR="#228B22">int</FONT></B> j = ans;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = ans + 1; i &lt; M; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (a[i][c]) {
                j = i;
                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (a[j][c] == 0) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        swap(a[j], a[ans]);
        swap(b[j], b[ans]);
        <I><FONT COLOR="#B22222">// s = 1 / a[ans][c] (in mod p)
</FONT></I>        T s = mod_inverse(a[ans][c], p);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; N; k++) 
            a[ans][k] = (a[ans][k] * s) % p;
        b[ans] = (b[ans] * s) % p;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = ans + 1; k &lt; M; k++) {
            <B><FONT COLOR="#228B22">int</FONT></B> coef = -a[k][c];
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> l = 0; l &lt; N; l++) 
                a[k][l] = ((a[k][l] + a[ans][l] * coef) % p + p) % p;
            b[k] = (b[k] + b[ans] * coef) % p;
        }
        ans++;
    }
    
    <I><FONT COLOR="#B22222">// If rank of [A] is not equal to the rank of [A : b]
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = ans; i &lt; M; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (b[i]) {
            <B><FONT COLOR="#A020F0">return</FONT></B> -1;
        }
    }
          
    <B><FONT COLOR="#A020F0">return</FONT></B> ans;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = 4;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = 2;
    <B><FONT COLOR="#228B22">double</FONT></B> A[n][n] = { {1,2,3,4},{1,0,1,0},{5,3,2,4},{6,1,4,6} };
    <B><FONT COLOR="#228B22">double</FONT></B> B[n][m] = { {1,2},{4,3},{5,6},{8,7} };
    VVT a(n), b(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        a[i] = VT(A[i], A[i] + n);
        b[i] = VT(B[i], B[i] + m);
    }
  
    <B><FONT COLOR="#228B22">double</FONT></B> det = GaussJordan(a, b);
  
    <I><FONT COLOR="#B22222">// expected: 60  
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Determinant: &quot;</FONT></B> &lt;&lt; det &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: -0.233333 0.166667 0.133333 0.0666667
</FONT></I>    <I><FONT COLOR="#B22222">//           0.166667 0.166667 0.333333 -0.333333
</FONT></I>    <I><FONT COLOR="#B22222">//           0.233333 0.833333 -0.133333 -0.0666667
</FONT></I>    <I><FONT COLOR="#B22222">//           0.05 -0.75 -0.1 0.2
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Inverse: &quot;</FONT></B> &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
            cout &lt;&lt; a[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
        cout &lt;&lt; endl;
    }
    
    <I><FONT COLOR="#B22222">// expected: 1.63333 1.3
</FONT></I>    <I><FONT COLOR="#B22222">//           -0.166667 0.5
</FONT></I>    <I><FONT COLOR="#B22222">//           2.36667 1.7
</FONT></I>    <I><FONT COLOR="#B22222">//           -1.85 -1.35
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Solution: &quot;</FONT></B> &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++)
            cout &lt;&lt; b[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
        cout &lt;&lt; endl;
    }

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= 10; i++) cout &lt;&lt; catalan_number(i) &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

}
</PRE>
<HR>
<A NAME="file38">
<H1>number/Matrix.cpp 38/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file37">prev</A>][<A HREF="#file39">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Matrix
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> Matrix {
<B><FONT COLOR="#228B22">public</FONT></B>:
    vector&lt;vector&lt;T&gt;&gt; a;
    <B><FONT COLOR="#228B22">int</FONT></B> N, M;
    Matrix() {}
    Matrix (<B><FONT COLOR="#228B22">int</FONT></B> n, <B><FONT COLOR="#228B22">int</FONT></B> m) {
        N = n; M = m;
        a = vector&lt;vector&lt;T&gt;&gt;(N, vector&lt;T&gt;(M));
    }
    Matrix mult(<B><FONT COLOR="#228B22">const</FONT></B> Matrix &amp;o) {
        assert(M == o.N);
        Matrix ret = Matrix(N, o.M);
        REP(i, N) REP(j, o.M) REP(k, M)
            ret[i][j] += a[i][k] * o.a[k][j];
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    Matrix power(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ex) {
        assert(N == M);
        Matrix ret = identity(), b = *<B><FONT COLOR="#A020F0">this</FONT></B>;
        <B><FONT COLOR="#A020F0">while</FONT></B> (ex) { <B><FONT COLOR="#A020F0">if</FONT></B> (ex &amp; 1) ret = ret.mult(b); b = b.mult(b); ex &gt;&gt;= 1; }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    Matrix identity() {
        assert(N == M);
        Matrix ret = Matrix(N, N);
        REP(i, N) ret[i][i] = 1;
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    vector&lt;T&gt; &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>[](<B><FONT COLOR="#228B22">int</FONT></B> ind) {
        assert(ind &gt;= 0 &amp;&amp; ind &lt; N);
        <B><FONT COLOR="#A020F0">return</FONT></B> a[ind];
    }
    <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">friend</FONT></B> ostream&amp; <B><FONT COLOR="#A020F0">operator</FONT></B> &lt;&lt; (ostream &amp;out, Matrix m) {
        REP(i, m.N) { out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;|&quot;</FONT></B>; REP(j, m.M) out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; m.a[i][j]; out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; |&quot;</FONT></B> &lt;&lt; endl; }
        <B><FONT COLOR="#A020F0">return</FONT></B> out;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    Matrix&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; start = Matrix&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(2, 2);
    start[0][1] = start[1][0] = start[1][1] = 1;
    cout &lt;&lt; start &lt;&lt; endl;
    Matrix&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; now = start;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; 10; i++) {
        cout &lt;&lt; now &lt;&lt; endl;
        now = now.mult(start);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; 10; i++) {
        cout &lt;&lt; start.power(i) &lt;&lt; endl;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file39">
<H1>number/ModInt.cpp 39/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file38">prev</A>][<A HREF="#file40">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Modulo Integer
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;typename Int,Int mod&gt;
<B><FONT COLOR="#228B22">class</FONT></B> ModInt {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> Int Mod = mod;
    Int x;
    ModInt() { x = 0; }
    ModInt(<B><FONT COLOR="#228B22">int</FONT></B> a) { Int t = a % mod; <B><FONT COLOR="#A020F0">if</FONT></B>(t &lt; 0) t += mod; x = t; }
    ModInt(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> a) { Int t = a % mod; <B><FONT COLOR="#A020F0">if</FONT></B>(t &lt; 0) t += mod; x = t; }
    Int get() <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> x; }
    
    ModInt &amp;<B><FONT COLOR="#A020F0">operator</FONT></B> += (ModInt that) { <B><FONT COLOR="#A020F0">if</FONT></B>((x += that.x) &gt;= mod) x -= mod; <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>; }
    ModInt &amp;<B><FONT COLOR="#A020F0">operator</FONT></B> -= (ModInt that) { <B><FONT COLOR="#A020F0">if</FONT></B>((x += mod - that.x) &gt;= mod) x -= mod; <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>; }
    ModInt &amp;<B><FONT COLOR="#A020F0">operator</FONT></B> *= (ModInt that) { x = (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>)(x) * that.x % mod; <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>; }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> == (ModInt that) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> x == that.x; }
    ModInt <B><FONT COLOR="#A020F0">operator</FONT></B> + (ModInt that) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> ModInt(*<B><FONT COLOR="#A020F0">this</FONT></B>) += that; }
    ModInt <B><FONT COLOR="#A020F0">operator</FONT></B> - (ModInt that) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> ModInt(*<B><FONT COLOR="#A020F0">this</FONT></B>) -= that; }
    ModInt <B><FONT COLOR="#A020F0">operator</FONT></B> * (ModInt that) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> ModInt(*<B><FONT COLOR="#A020F0">this</FONT></B>) *= that; }
    ModInt <B><FONT COLOR="#A020F0">operator</FONT></B> - () <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> ModInt(-<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;x); }
    <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">friend</FONT></B> ostream&amp; <B><FONT COLOR="#A020F0">operator</FONT></B> &lt;&lt; (ostream &amp;out, ModInt m) {<B><FONT COLOR="#A020F0">return</FONT></B> out &lt;&lt; m.x;}
    
    ModInt power(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> k) <B><FONT COLOR="#228B22">const</FONT></B> {
        ModInt r(1); ModInt b = *<B><FONT COLOR="#A020F0">this</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (k &lt;= 0) <B><FONT COLOR="#A020F0">return</FONT></B> r; <B><FONT COLOR="#A020F0">while</FONT></B> (k) { <B><FONT COLOR="#A020F0">if</FONT></B> (k &amp; 1) r *= b; b *= b; k &gt;&gt;= 1; }
        <B><FONT COLOR="#A020F0">return</FONT></B> r;
    }
    ModInt inverse() <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> a = x, b = mod, u = 1, v = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B>(b) { <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }
        <B><FONT COLOR="#A020F0">return</FONT></B> ModInt(u);
    }
};

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MOD</FONT> (1000000007)
<B><FONT COLOR="#228B22">typedef</FONT></B> ModInt&lt;<B><FONT COLOR="#228B22">int</FONT></B>, MOD&gt; Mint;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    Mint a(7);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = -10; i &lt; 10; i++) {
        cout &lt;&lt; a &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; power of &quot;</FONT></B> &lt;&lt; i &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; : &quot;</FONT></B> &lt;&lt; a.power(i) &lt;&lt; endl;
        Mint t(i);
        cout &lt;&lt; t &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; (inverse): &quot;</FONT></B> &lt;&lt; t.inverse() &lt;&lt; endl;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file40">
<H1>number/Rational.cpp 40/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file39">prev</A>][<A HREF="#file41">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII; <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;PII, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII2;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI; <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">class</FONT></B> Rational {
<B><FONT COLOR="#228B22">public</FONT></B>:
    LL p, q;
    Rational() {}
    Rational(LL p_): p(p_), q(1) {}
    Rational(LL p_, LL q_): p(p_), q(q_) { reduce(); }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> == (<B><FONT COLOR="#228B22">const</FONT></B> Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> p == rhs.p &amp;&amp; q == rhs.q; }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> != (<B><FONT COLOR="#228B22">const</FONT></B> Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> p != rhs.p || q != rhs.q; }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> &lt; (<B><FONT COLOR="#228B22">const</FONT></B> Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> p * rhs.q &lt; rhs.p * q; }
    Rational <B><FONT COLOR="#A020F0">operator</FONT></B> + (<B><FONT COLOR="#228B22">const</FONT></B> Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Rational(p * rhs.q + q * rhs.p, q * rhs.q); }
    Rational <B><FONT COLOR="#A020F0">operator</FONT></B> - (<B><FONT COLOR="#228B22">const</FONT></B> Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Rational(p * rhs.q - q * rhs.p, q * rhs.q); }
    Rational <B><FONT COLOR="#A020F0">operator</FONT></B> * (<B><FONT COLOR="#228B22">const</FONT></B> Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Rational(p * rhs.p, q * rhs.q); }
    Rational <B><FONT COLOR="#A020F0">operator</FONT></B> / (<B><FONT COLOR="#228B22">const</FONT></B> Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Rational(p * rhs.q, q * rhs.p); }
    <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">friend</FONT></B> ostream&amp; <B><FONT COLOR="#A020F0">operator</FONT></B> &lt;&lt; (ostream &amp;out, Rational m) { <B><FONT COLOR="#A020F0">return</FONT></B> out &lt;&lt; m.p &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;/&quot;</FONT></B> &lt;&lt; m.q; }
<B><FONT COLOR="#228B22">private</FONT></B>:
    LL gcd(LL a, LL b) { <B><FONT COLOR="#A020F0">if</FONT></B> (b == 0) <B><FONT COLOR="#A020F0">return</FONT></B> a; <B><FONT COLOR="#A020F0">return</FONT></B> gcd(b, a % b); }
    <B><FONT COLOR="#228B22">void</FONT></B> reduce() {
        <B><FONT COLOR="#A020F0">if</FONT></B> (q &lt; 0) { p *= -1; q *= -1; }
        LL t = gcd((p &gt;= 0 ? p : -p), q);
        p /= t; q /= t;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    Rational x(4, 6);
    Rational y(5, 6);
    cout &lt;&lt; x &lt;&lt; endl;
    cout &lt;&lt; y &lt;&lt; endl;
    cout &lt;&lt; x + y &lt;&lt; endl;
    cout &lt;&lt; x - y &lt;&lt; endl;
    Rational z(0, -1);
    cout &lt;&lt; z &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file41">
<H1>string/AhoCorasickAlgorithm.cpp 41/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file40">prev</A>][<A HREF="#file42">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Aho-Corasick Algorithm
</FONT></I><I><FONT COLOR="#B22222">//  Prefix tree with suffix link
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://acm.timus.ru/problem.aspx?space=1&amp;num=1269
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)(x).size())
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PB</FONT></B>(x) push_back(x)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MEMSET</FONT></B>(x,v) memset(x,v,sizeof(x))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (0x3f3f3f3f)

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; P2;
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> A, <B><FONT COLOR="#228B22">class</FONT></B> B&gt; <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> mina(A &amp;x, B y) {<B><FONT COLOR="#A020F0">return</FONT></B> (x &gt; y)?(x=y,1):0;}
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> A, <B><FONT COLOR="#228B22">class</FONT></B> B&gt; <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> maxa(A &amp;x, B y) {<B><FONT COLOR="#A020F0">return</FONT></B> (x &lt; y)?(x=y,1):0;}

<B><FONT COLOR="#228B22">class</FONT></B> Node {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">char</FONT></B> c;
    <B><FONT COLOR="#228B22">int</FONT></B> parent;
    <B><FONT COLOR="#228B22">bool</FONT></B> isWord;
    <B><FONT COLOR="#228B22">int</FONT></B> suffLink;
    <B><FONT COLOR="#228B22">int</FONT></B> num_child;
    <B><FONT COLOR="#228B22">int</FONT></B> *children;
    <B><FONT COLOR="#228B22">int</FONT></B> len = 0;
    Node () {
        parent = -1;
        isWord = false;
        suffLink = -1;
        num_child = 0;
        children = NULL;
        len = -1;
    }
};

<B><FONT COLOR="#228B22">class</FONT></B> AhoCorasick {
<B><FONT COLOR="#228B22">public</FONT></B>:
    Node *nodes;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    AhoCorasick (<B><FONT COLOR="#228B22">int</FONT></B> maxNode) {
        N = 1;
        nodes = <B><FONT COLOR="#A020F0">new</FONT></B> Node[maxNode];
        nodes[0].suffLink = 0;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> add_string(<B><FONT COLOR="#228B22">char</FONT></B> *s) {
        <B><FONT COLOR="#228B22">int</FONT></B> cur = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> len = strlen(s);
        REP(i, len) {
            <B><FONT COLOR="#228B22">int</FONT></B> nxt = -1;
            REP(j, nodes[cur].num_child) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (nodes[nodes[cur].children[j]].c == s[i]) {
                    nxt = nodes[cur].children[j];
                    <B><FONT COLOR="#A020F0">break</FONT></B>;
                }
            }
            <B><FONT COLOR="#A020F0">if</FONT></B> (nxt == -1) {
                <B><FONT COLOR="#228B22">int</FONT></B> *nc = <B><FONT COLOR="#A020F0">new</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>[nodes[cur].num_child + 1];
                REP(j, nodes[cur].num_child) nc[j] = nodes[cur].children[j];
                nc[nodes[cur].num_child] = N++;
                <B><FONT COLOR="#A020F0">delete</FONT></B> [] nodes[cur].children;
                nodes[cur].children = nc;
                nodes[cur].num_child++;
                nodes[N - 1].parent = cur;
                nodes[N - 1].c = s[i];
                nxt = N - 1;
            }
            cur = nxt;
        }
        nodes[cur].isWord = true;
        nodes[cur].len = len;
    }

    <B><FONT COLOR="#228B22">int</FONT></B> find_suffix_link(<B><FONT COLOR="#228B22">int</FONT></B> cur) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (nodes[cur].suffLink == -1) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (nodes[cur].parent == 0) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
            <B><FONT COLOR="#A020F0">return</FONT></B> nodes[cur].suffLink = transition(find_suffix_link(nodes[cur].parent), nodes[cur].c);
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> nodes[cur].suffLink;
    }
    <B><FONT COLOR="#228B22">int</FONT></B> transition(<B><FONT COLOR="#228B22">int</FONT></B> cur, <B><FONT COLOR="#228B22">char</FONT></B> c) {
        REP(i, nodes[cur].num_child) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (nodes[nodes[cur].children[i]].c == c) {
                <B><FONT COLOR="#A020F0">return</FONT></B> nodes[cur].children[i];
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur == 0) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
        <B><FONT COLOR="#A020F0">return</FONT></B> transition(find_suffix_link(cur), c);
    }
    <I><FONT COLOR="#B22222">// Find the first word in the tree that matches the given string s
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> find(<B><FONT COLOR="#228B22">char</FONT></B> *s) {
        <B><FONT COLOR="#228B22">int</FONT></B> ans = -1;
        <B><FONT COLOR="#228B22">int</FONT></B> cur = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> len = strlen(s);
        REP(i, len) {
            cur = transition(cur, s[i]);
            <I><FONT COLOR="#B22222">// Check if this word is a substring of the given text
</FONT></I>            <B><FONT COLOR="#228B22">int</FONT></B> temp = cur;
            <B><FONT COLOR="#A020F0">while</FONT></B> (temp &amp;&amp; nodes[temp].suffLink == -1) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (nodes[temp].isWord) {
                    <B><FONT COLOR="#228B22">int</FONT></B> dd = i - nodes[temp].len + 1;
                    <B><FONT COLOR="#A020F0">if</FONT></B> (ans == -1 || dd &lt; ans) {
                        ans = dd;
                    }
                }
                temp = find_suffix_link(temp);
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> ans;
    }
};

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MAXL = 1e6 + 5;
<B><FONT COLOR="#228B22">char</FONT></B> S[MAXL];

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;N);
    AhoCorasick aho(110000);
    gets(S);
    REP(i, N) {
        gets(S);
        aho.add_string(S);
    }
   <I><FONT COLOR="#B22222">// REP(i, aho.N) {
</FONT></I>   <I><FONT COLOR="#B22222">//     cout &lt;&lt; i &lt;&lt; &quot;#&quot; &lt;&lt; aho.find_suffix_link(i) &lt;&lt; endl;
</FONT></I>   <I><FONT COLOR="#B22222">// }
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> M;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;M);
    gets(S);
    REP(i, M) {
        gets(S);
        <B><FONT COLOR="#228B22">int</FONT></B> temp = aho.find(S);
        <B><FONT COLOR="#A020F0">if</FONT></B> (temp != -1) {
            printf(<B><FONT COLOR="#BC8F8F">&quot;%d %d\n&quot;</FONT></B>, i + 1, temp + 1);
            <B><FONT COLOR="#A020F0">return</FONT></B> 0;
        }
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;Passed\n&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file42">
<H1>string/ManacherAlgorithm.cpp 42/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file41">prev</A>][<A HREF="#file43">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Manacher's algorithm
</FONT></I><I><FONT COLOR="#B22222">//  - Finding the longest substring that is also a palindrome in linear time
</FONT></I><I><FONT COLOR="#B22222">//  - It also finds the length of longest palindrome &quot;centered&quot; at each position
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">// Transform S into T.
</FONT></I><I><FONT COLOR="#B22222">// For example, S = &quot;abba&quot;, T = &quot;^#a#b#b#a#$&quot;.
</FONT></I><I><FONT COLOR="#B22222">// ^ and $ signs are sentinels appended to each end to avoid bounds checking
</FONT></I><I><FONT COLOR="#B22222">// 
</FONT></I><I><FONT COLOR="#B22222">// For example: S = &quot;abaaba&quot;, T = &quot;^#a#b#a#a#b#a#$&quot;.
</FONT></I><I><FONT COLOR="#B22222">// T = ^ # a # b # a # a # b # a # $
</FONT></I><I><FONT COLOR="#B22222">// P = 0 0 1 0 3 0 1 6 1 0 3 0 1 0 0
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstring&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> ManacherAlgorithm {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">char</FONT></B> *T;
    string s;
    
    ManacherAlgorithm(string _s) {
        s = _s;
        <B><FONT COLOR="#228B22">int</FONT></B> n = s.size();
        <B><FONT COLOR="#228B22">int</FONT></B> n2 = 0;
        T = <B><FONT COLOR="#A020F0">new</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>[2 * n + 5];
        T[n2++] = <B><FONT COLOR="#BC8F8F">'^'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>(n == 0){
            T[n2++] = <B><FONT COLOR="#BC8F8F">'$'</FONT></B>;
            T[n2] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++ ){
                T[n2++] = <B><FONT COLOR="#BC8F8F">'#'</FONT></B>;
                T[n2++] = s[i];
            }
            T[n2++] = <B><FONT COLOR="#BC8F8F">'#'</FONT></B>;
            T[n2++] = <B><FONT COLOR="#BC8F8F">'$'</FONT></B>;
            T[n2] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
        }
    }
 
    string get_longest_palindrome() {
        <B><FONT COLOR="#228B22">int</FONT></B> n = strlen(T);
        <B><FONT COLOR="#228B22">int</FONT></B> *P = <B><FONT COLOR="#A020F0">new</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>[n];
        <B><FONT COLOR="#228B22">int</FONT></B> C = 0, R = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; n - 1; i++ ){
            <B><FONT COLOR="#228B22">int</FONT></B> i_mirror = 2 * C - i; <I><FONT COLOR="#B22222">// equals to i' = C - (i-C)
</FONT></I>    
            P[i] = (R &gt; i) ? min(R-i, P[i_mirror]) : 0;
    
            <I><FONT COLOR="#B22222">// Attempt to expand palindrome centered at i
</FONT></I>            <B><FONT COLOR="#A020F0">while</FONT></B>(T[i + 1 + P[i]] == T[i - 1 - P[i]])
                P[i]++;
 
            <I><FONT COLOR="#B22222">// If palindrome centered at i expand past R,
</FONT></I>            <I><FONT COLOR="#B22222">// adjust center based on expanded palindrome.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(i + P[i] &gt; R){
                C = i;
                R = i + P[i];
            }
        }
 
        <I><FONT COLOR="#B22222">// Find the maximum element in P.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> maxLen = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> centerIndex = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; n-1; i++){
            <B><FONT COLOR="#A020F0">if</FONT></B> (P[i] &gt; maxLen){
                maxLen = P[i];
                centerIndex = i;
            }
        }

        <B><FONT COLOR="#A020F0">delete</FONT></B>[] P;
        <B><FONT COLOR="#A020F0">return</FONT></B> s.substr((centerIndex - 1 - maxLen)/2, maxLen);
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    ManacherAlgorithm solver(<B><FONT COLOR="#BC8F8F">&quot;abaaba&quot;</FONT></B>);
    cout &lt;&lt; solver.get_longest_palindrome() &lt;&lt; endl;

    solver = ManacherAlgorithm(<B><FONT COLOR="#BC8F8F">&quot;abba&quot;</FONT></B>);
    cout &lt;&lt; solver.get_longest_palindrome() &lt;&lt; endl;

    solver = ManacherAlgorithm(<B><FONT COLOR="#BC8F8F">&quot;xabac&quot;</FONT></B>);
    cout &lt;&lt; solver.get_longest_palindrome() &lt;&lt; endl;

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file43">
<H1>string/StringMatching.cpp 43/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file42">prev</A>][<A HREF="#file44">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Z-functions
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////// 
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<I><FONT COLOR="#B22222">// z-functions: return z, z[i] is the length of the longest substring
</FONT></I><I><FONT COLOR="#B22222">//              starting from S[i] which is also a prefix of S
</FONT></I>
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; get_ZFunction(string s){
    <B><FONT COLOR="#228B22">int</FONT></B> len = s.length();
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; z(len);
    <B><FONT COLOR="#228B22">int</FONT></B> L = 0, R = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; len; i++ ){
        <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; R){
            L = R = i;
            <B><FONT COLOR="#A020F0">while</FONT></B> (R &lt; len &amp;&amp; s[R-L] == s[R]) R++;
            z[i] = R - L; R--;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> k = i - L;
            <B><FONT COLOR="#A020F0">if</FONT></B>(z[k] &lt; R - i + 1) z[i] = z[k];
            <B><FONT COLOR="#A020F0">else</FONT></B> {
                L = i;
                <B><FONT COLOR="#A020F0">while</FONT></B> (R &lt; len &amp;&amp; s[R - L] == s[R]) R++;
                z[i] = R - L; R--;
            }
        }
    }
    z[0] = len;
    <B><FONT COLOR="#A020F0">return</FONT></B> z;
}


<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Knuth-Morris-Pratt
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">/* 
  Searches for the string key in the string s (of length k). Returns the 
  0-based index of the first match (k if no match is found). Algorithm 
  runs in O(k) time. 
*/</FONT></I> 

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;

<B><FONT COLOR="#228B22">class</FONT></B> KnuthMorrisPratt {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> build_table(string&amp; key, VI&amp; t){
        <B><FONT COLOR="#228B22">int</FONT></B> sz = key.size();
        t = VI(sz);
        <B><FONT COLOR="#228B22">int</FONT></B> i = 2, j = 0;
        t[0] = -1; t[1] = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (i &lt; sz) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (key[i - 1] == key[j]) { t[i] = j + 1; i++; j++; }
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (j &gt; 0) j = t[j];
            <B><FONT COLOR="#A020F0">else</FONT></B> { t[i] = 0; i++; }
        }
    }

    <I><FONT COLOR="#B22222">// return the index of the first match, or the length of s if key is not found
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> KMP(string s, string key){
        <B><FONT COLOR="#228B22">int</FONT></B> m = 0, i = 0;
        VI t;
        build_table(key, t);
        <B><FONT COLOR="#228B22">int</FONT></B> sz_s = s.size();
        <B><FONT COLOR="#228B22">int</FONT></B> sz_w = key.size();
        <B><FONT COLOR="#A020F0">while</FONT></B> (m+i &lt; sz_s) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (key[i] == s[m+i]) {
                i++;
                <B><FONT COLOR="#A020F0">if</FONT></B> (i == sz_w) <B><FONT COLOR="#A020F0">return</FONT></B> m;
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                m += i - t[i];
                <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; 0) i = t[i];
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> s.length();
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    KnuthMorrisPratt solve;
    assert(solve.KMP(<B><FONT COLOR="#BC8F8F">&quot;win&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;I wanna win.&quot;</FONT></B>) == 3);
    assert(solve.KMP(<B><FONT COLOR="#BC8F8F">&quot;I wanna win.&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;win&quot;</FONT></B>) == 8);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}  

<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Prefix Function
</FONT></I><I><FONT COLOR="#B22222">//  Given a string. Return an array of numbers, 
</FONT></I><I><FONT COLOR="#B22222">//  where is defined as follows: it is a maximum length of the longest 
</FONT></I><I><FONT COLOR="#B22222">//  proper suffix substring that matches the prefix (suffix own - so not 
</FONT></I><I><FONT COLOR="#B22222">//  the entire line). In particular, the value is set equal to zero.
</FONT></I><I><FONT COLOR="#B22222">//  For example, the string &quot;abcabcd&quot; prefix function is: [1, 0, 0, 1, 2, 3, 0]
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; prefix_function (string s){
    <B><FONT COLOR="#228B22">int</FONT></B> n = (<B><FONT COLOR="#228B22">int</FONT></B>) s.length();
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; pi (n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i=1; i&lt;n; ++i){
        <B><FONT COLOR="#228B22">int</FONT></B> j = pi[i-1];
        <B><FONT COLOR="#A020F0">while</FONT></B> (j &gt; 0 &amp;&amp; s[i] != s[j])
            j = pi[j-1];
        <B><FONT COLOR="#A020F0">if</FONT></B> (s[i] == s[j])  ++j;
        pi[i] = j;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> pi;
}
</PRE>
<HR>
<A NAME="file44">
<H1>string/SuffixArray.cpp 44/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file43">prev</A>][<A HREF="#file45">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Suffix Array
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  For example, s = &quot;banana&quot;
</FONT></I><I><FONT COLOR="#B22222">//  0 $(end of string)     0  1  2  3  4  5  6
</FONT></I><I><FONT COLOR="#B22222">//  1 a                    b  a  n  a  n  a  $
</FONT></I><I><FONT COLOR="#B22222">//  2 ana          RA[] = [4, 3, 6, 2, 5, 1, 0] (Rank array)
</FONT></I><I><FONT COLOR="#B22222">//  3 anana   -&gt;   SA[] = [6, 5, 3, 1, 0, 4, 2] (Suffix array)
</FONT></I><I><FONT COLOR="#B22222">//  4 banana      LCP[] = [0, 1, 3, 0, 0, 2]    (Longest Common Prefix array
</FONT></I><I><FONT COLOR="#B22222">//  5 na                                         LCP between pairs of consecutive suffixes)
</FONT></I><I><FONT COLOR="#B22222">//  6 nana
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstring&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII; <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;PII, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII2;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI; <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">class</FONT></B> SuffixArray {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    VI SA, RA, LCP;
    SuffixArray(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* S) : N(strlen(S)) {
        VI V; <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) V.push_back(S[i]); init(V);
    }
    SuffixArray(<B><FONT COLOR="#228B22">const</FONT></B> VI &amp;VV) : N(VV.size()) { VI V(VV); init(V); }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> init(VI&amp; V) {
        VI OV(V), C(N);
        compress(V, C); compute_sa(V, C);
        RA.resize(N + 1); <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= N; i++) RA[SA[i]] = i;
        compute_lcp(OV);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> compress(VI&amp; V, VI&amp; C) {
        copy(V.begin(), V.end(), C.begin());
        sort(C.begin(), C.end());
        <B><FONT COLOR="#5F9EA0">VI</FONT></B>::iterator cend = unique(C.begin(), C.end());
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) V[i] = lower_bound(C.begin(), cend, V[i]) - C.begin() + 1;
        V.push_back(0); C.push_back(0);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> compute_sa(VI&amp; V, VI&amp; C) {
        VI T(N + 1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= N; i++) SA.push_back(i);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> ski = 0; V[SA[N]] &lt; N; ski = ski ? ski &lt;&lt; 1 : 1) {
            fill(C.begin(), C.end(), 0);
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; ski; i++) T[i] = N - i;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0, p = ski; i &lt;= N; i++) <B><FONT COLOR="#A020F0">if</FONT></B>(SA[i] &gt;= ski) T[p++] = SA[i] - ski;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= N; i++) C[V[i]]++;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) C[i] += C[i - 1];
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = N; i &gt;= 0; i--) SA[--C[V[T[i]]]] = T[i];
            T[SA[0]] = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= N; j++) {
                <B><FONT COLOR="#228B22">int</FONT></B> a = SA[j];
                <B><FONT COLOR="#228B22">int</FONT></B> b = SA[j - 1];
                T[a] = T[b] + (a + ski &gt;= N || b + ski &gt;= N ||
                               V[a] != V[b] || V[a + ski] != V[b + ski]);
            }
            V.swap(T);
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> compute_lcp(<B><FONT COLOR="#228B22">const</FONT></B> VI&amp; OV) {
        LCP = VI(N);
        <B><FONT COLOR="#228B22">int</FONT></B> len = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++, len = max(0, len - 1)) {
            <B><FONT COLOR="#228B22">int</FONT></B> si = RA[i], j = SA[si - 1];
            <B><FONT COLOR="#A020F0">for</FONT></B> (; i + len &lt; N &amp;&amp; j + len &lt; N &amp;&amp; OV[i + len] == OV[j + len]; len++);
            LCP[si - 1] = len;
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    string s = <B><FONT COLOR="#BC8F8F">&quot;banana&quot;</FONT></B>;
    SuffixArray sa(s.c_str());
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= sa.N; i++) {
        printf(<B><FONT COLOR="#BC8F8F">&quot;%d &quot;</FONT></B>, sa.SA[i]);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file45">
<H1>string/SuffixArray_nlgn.cpp 45/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file44">prev</A>][<A HREF="#file46">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Suffix Array
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  For example, s = &quot;banana&quot;
</FONT></I><I><FONT COLOR="#B22222">//                         0  1  2  3  4  5
</FONT></I><I><FONT COLOR="#B22222">//  0 a                    b  a  n  a  n  a
</FONT></I><I><FONT COLOR="#B22222">//  1 ana         pos[] = [3, 2, 5, 1, 4, 0] (Position of each suffix)
</FONT></I><I><FONT COLOR="#B22222">//  2 anana   -&gt;   sa[] = [5, 3, 1, 0, 4, 2] (Suffix array)
</FONT></I><I><FONT COLOR="#B22222">//  3 banana      LCP[] = [1, 3, 0, 0, 2, 0] (Longest Common Prefix array
</FONT></I><I><FONT COLOR="#B22222">//  4 na                                      LCP between pairs of consecutive suffixes)
</FONT></I><I><FONT COLOR="#B22222">//  5 nana
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)(x).size())
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,n) for(int (i)=0;(i)&lt;(n);++(i))

namespace SuffixArray
{
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MAXN = 1 &lt;&lt; 21;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> * S;
    <B><FONT COLOR="#228B22">int</FONT></B> N, gap;
    <B><FONT COLOR="#228B22">int</FONT></B> sa[MAXN], pos[MAXN], tmp[MAXN], lcp[MAXN];
    <B><FONT COLOR="#228B22">bool</FONT></B> sufCmp(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (pos[i] != pos[j])
            <B><FONT COLOR="#A020F0">return</FONT></B> pos[i] &lt; pos[j];
        i += gap;
        j += gap;
        <B><FONT COLOR="#A020F0">return</FONT></B> (i &lt; N &amp;&amp; j &lt; N) ? pos[i] &lt; pos[j] : i &gt; j;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> buildSA(){
        N = strlen(S);
        REP(i, N) sa[i] = i, pos[i] = S[i];
        <B><FONT COLOR="#A020F0">for</FONT></B> (gap = 1;; gap *= 2) {
            sort(sa, sa + N, sufCmp);
            REP(i, N - 1) tmp[i + 1] = tmp[i] + sufCmp(sa[i], sa[i + 1]);
            REP(i, N) pos[sa[i]] = tmp[i];
            <B><FONT COLOR="#A020F0">if</FONT></B> (tmp[N - 1] == N - 1) <B><FONT COLOR="#A020F0">break</FONT></B>;
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> buildLCP() {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0, k = 0; i &lt; N; ++i) <B><FONT COLOR="#A020F0">if</FONT></B> (pos[i] != N - 1) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = sa[pos[i] + 1]; S[i + k] == S[j + k];)
            ++k;
            lcp[pos[i]] = k;
            <B><FONT COLOR="#A020F0">if</FONT></B> (k) --k;
        }
    }
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    string s = <B><FONT COLOR="#BC8F8F">&quot;banana&quot;</FONT></B>;
    <B><FONT COLOR="#5F9EA0">SuffixArray</FONT></B>::S = s.c_str();
    <B><FONT COLOR="#5F9EA0">SuffixArray</FONT></B>::buildSA();
    <B><FONT COLOR="#5F9EA0">SuffixArray</FONT></B>::buildLCP();
    <B><FONT COLOR="#228B22">int</FONT></B> N = SZ(s);
    REP(i, N) cout &lt;&lt; SuffixArray::sa[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cout &lt;&lt; endl;
    REP(i, N) cout &lt;&lt; SuffixArray::lcp[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cout &lt;&lt; endl;
    REP(i, N) cout &lt;&lt; SuffixArray::pos[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cout &lt;&lt; endl;

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}


</PRE>
<HR>
<A NAME="file46">
<H1>string/SuffixTree.cpp 46/46</H1>
[<A HREF="#top">top</A>][<A HREF="#file45">prev</A>][next]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Suffix Tree
</FONT></I><I><FONT COLOR="#B22222">//  by Ukkonen's algorithm in O(N * alphabetSize)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  There are 2 more methods added to solve this problem:
</FONT></I><I><FONT COLOR="#B22222">//  http://codeforces.com/contest/452/problem/E
</FONT></I><I><FONT COLOR="#B22222">//    - For each valid l, find the number of common substrings of lengh l
</FONT></I><I><FONT COLOR="#B22222">//      that are in all three given strings
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PB</FONT></B>(x) push_back(x);
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (0x3f3f3f3f)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MEMSET</FONT></B>(x,v) memset(x,v,sizeof(x));

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII; <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;PII, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII2;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI; <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;LL, LL&gt; PLL; <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;PLL, LL&gt; PLL2;
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MOD</FONT> (1000000007)

<I><FONT COLOR="#B22222">// The number of delimiters the class will use is equal to the number of strings added
</FONT></I><I><FONT COLOR="#B22222">// Please make sure that all the delimiters won't appear in the input strings
</FONT></I><I><FONT COLOR="#B22222">// Example of delimiters
</FONT></I><I><FONT COLOR="#B22222">// '\1' -&gt; '\1', '\2', '\3', '\4', ... (these characters are invisible)
</FONT></I><I><FONT COLOR="#B22222">// '#'  -&gt; '#', '$', '%', '&amp;', ...
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">char</FONT></B> FIRST_DELIMITER&gt;
<B><FONT COLOR="#228B22">class</FONT></B> SuffixTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">class</FONT></B> Node {
    <B><FONT COLOR="#228B22">public</FONT></B>:
        <B><FONT COLOR="#228B22">int</FONT></B> begin, end; <I><FONT COLOR="#B22222">// s[begin...end-1]
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> depth; <I><FONT COLOR="#B22222">// depth by chars from the root to this node
</FONT></I>        Node *parent;
        vector&lt;Node*&gt; children;
        Node *suffix_link;
        Node(<B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> e, <B><FONT COLOR="#228B22">int</FONT></B> d, Node *p, <B><FONT COLOR="#228B22">int</FONT></B> alpha_size) : begin(b), end(e), depth(d) , parent(p) {
            children = vector&lt;Node*&gt;(alpha_size);
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; alpha_size; i++) children[i] = NULL;
            suffix_link = NULL;
        }
        <B><FONT COLOR="#228B22">bool</FONT></B> contains(<B><FONT COLOR="#228B22">int</FONT></B> d) { <B><FONT COLOR="#A020F0">return</FONT></B> depth &lt;= d &amp;&amp; d &lt; depth + (end - begin); }
    };
    Node *root;
    vector&lt;string&gt; strings;
    set&lt;<B><FONT COLOR="#228B22">char</FONT></B>&gt; alphabets;
    string concat_s;
    SuffixTree() { root = NULL; concat_s = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>; }
    <B><FONT COLOR="#228B22">void</FONT></B> add_string(string s) {
        strings.PB(s); concat_s += s;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">char</FONT></B> c : s) { alphabets.insert(c); }
        concat_s += FIRST_DELIMITER + (SZ(strings) - 1); <I><FONT COLOR="#B22222">// added a delimiter in between strings
</FONT></I>        alphabets.insert(FIRST_DELIMITER + (SZ(strings) - 1));
    }
    <B><FONT COLOR="#228B22">void</FONT></B> build_suffix_tree() {
        <B><FONT COLOR="#228B22">int</FONT></B> alphabet_size = SZ(alphabets);
        <B><FONT COLOR="#228B22">int</FONT></B> N = SZ(concat_s);
        VI a(N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> j = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">char</FONT></B> c : alphabets) { <B><FONT COLOR="#A020F0">if</FONT></B> (concat_s[i] == c) { a[i] = j; <B><FONT COLOR="#A020F0">break</FONT></B>; } j++; }
        }
        root = <B><FONT COLOR="#A020F0">new</FONT></B> Node(0, 0, 0, NULL, alphabet_size);
        Node *cn = root; <I><FONT COLOR="#B22222">// root.suffixLink must be null, but that way it gets more convenient processing
</FONT></I>        root-&gt;suffix_link = root;
        Node *needs_suffix_link = NULL;
        <B><FONT COLOR="#228B22">int</FONT></B> last_rule = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> j = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = -1; i &lt; N - 1; i++) { <I><FONT COLOR="#B22222">// strings s[j..i] already in tree, add s[i+1] to it
</FONT></I>            <B><FONT COLOR="#228B22">int</FONT></B> cur = a[i + 1]; <I><FONT COLOR="#B22222">// last char of current string
</FONT></I>            <B><FONT COLOR="#A020F0">for</FONT></B> (; j &lt;= i + 1; j++) {
                <B><FONT COLOR="#228B22">int</FONT></B> cur_depth = i + 1 - j;
                <B><FONT COLOR="#A020F0">if</FONT></B> (last_rule != 3) {
                    cn = cn-&gt;suffix_link != NULL ? cn-&gt;suffix_link : cn-&gt;parent-&gt;suffix_link;
                    <B><FONT COLOR="#228B22">int</FONT></B> k = j + cn-&gt;depth;
                    <B><FONT COLOR="#A020F0">while</FONT></B> (cur_depth &gt; 0 &amp;&amp; !cn-&gt;contains(cur_depth - 1)) {
                        k += cn-&gt;end - cn-&gt;begin;
                        cn = cn-&gt;children[a[k]];
                    }
                }
                <B><FONT COLOR="#A020F0">if</FONT></B> (!cn-&gt;contains(cur_depth)) { <I><FONT COLOR="#B22222">// explicit node
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (needs_suffix_link != NULL) {
                        needs_suffix_link-&gt;suffix_link = cn;
                        needs_suffix_link = NULL;
                    }
                    <B><FONT COLOR="#A020F0">if</FONT></B> (cn-&gt;children[cur] == NULL) {
                        <I><FONT COLOR="#B22222">// no extension - add leaf
</FONT></I>                        cn-&gt;children[cur] = <B><FONT COLOR="#A020F0">new</FONT></B> Node(i + 1, N, cur_depth, cn, alphabet_size);
                        last_rule = 2;
                    } <B><FONT COLOR="#A020F0">else</FONT></B> {
                        cn = cn-&gt;children[cur];
                        last_rule = 3; <I><FONT COLOR="#B22222">// already exists
</FONT></I>                        <B><FONT COLOR="#A020F0">break</FONT></B>;
                    }
                } <B><FONT COLOR="#A020F0">else</FONT></B> { <I><FONT COLOR="#B22222">// implicit node
</FONT></I>                    <B><FONT COLOR="#228B22">int</FONT></B> end = cn-&gt;begin + cur_depth - cn-&gt;depth;
                    <B><FONT COLOR="#A020F0">if</FONT></B> (a[end] != cur) { <I><FONT COLOR="#B22222">// split implicit node here
</FONT></I>                        Node *newn = <B><FONT COLOR="#A020F0">new</FONT></B> Node(cn-&gt;begin, end, cn-&gt;depth, cn-&gt;parent, alphabet_size);
                        newn-&gt;children[cur] = <B><FONT COLOR="#A020F0">new</FONT></B> Node(i + 1, N, cur_depth, newn, alphabet_size);
                        newn-&gt;children[a[end]] = cn;
                        cn-&gt;parent-&gt;children[a[cn-&gt;begin]] = newn;
                        <B><FONT COLOR="#A020F0">if</FONT></B> (needs_suffix_link != NULL) {
                            needs_suffix_link-&gt;suffix_link = newn;
                        }
                        cn-&gt;begin = end;
                        cn-&gt;depth = cur_depth;
                        cn-&gt;parent = newn;
                        cn = needs_suffix_link = newn;
                        last_rule = 2;
                    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (cn-&gt;end != N || cn-&gt;begin - cn-&gt;depth &lt; j) {
                        last_rule = 3;
                        <B><FONT COLOR="#A020F0">break</FONT></B>;
                    } <B><FONT COLOR="#A020F0">else</FONT></B> {
                        last_rule = 1;
                    }
                }

            }
        }
        root-&gt;suffix_link = NULL;
    }
    
    <I><FONT COLOR="#B22222">////////////////////////////////////////////////
</FONT></I>    <I><FONT COLOR="#B22222">// Just examples of how to use the tree
</FONT></I>    <I><FONT COLOR="#B22222">////////////////////////////////////////////////
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> print_preorder() {
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Preorder Traversal: &quot;</FONT></B> &lt;&lt; endl;
        print_preorder(root);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> print_suffix_array() {
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Suffix Array: &quot;</FONT></B> &lt;&lt; endl;
        print_suffix_array(root);
    }

    <B><FONT COLOR="#228B22">int</FONT></B> max_common_len;
    <B><FONT COLOR="#228B22">int</FONT></B> max_common_begin;
    <I><FONT COLOR="#B22222">// Maximum Common Substring of the first two strings added
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> find_max_common_substring() {
        assert(SZ(strings) &gt;= 2);
        max_common_len = -1;
        <B><FONT COLOR="#228B22">int</FONT></B> len1 = SZ(strings[0]);
        <B><FONT COLOR="#228B22">int</FONT></B> len2 = SZ(strings[1]);
        find_max_common_substring(root, len1, len1 + len2 + 1);
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Max Common Substring Length: &quot;</FONT></B> &lt;&lt; max_common_len &lt;&lt; endl;
        <B><FONT COLOR="#A020F0">if</FONT></B> (max_common_len) {
            cout &lt;&lt; concat_s.substr(max_common_begin, max_common_len) &lt;&lt; endl;
        }
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    pair&lt;<B><FONT COLOR="#228B22">bool</FONT></B>, <B><FONT COLOR="#228B22">bool</FONT></B>&gt; find_max_common_substring(Node *cur, <B><FONT COLOR="#228B22">int</FONT></B> i1, <B><FONT COLOR="#228B22">int</FONT></B> i2) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;begin &lt;= i1 &amp;&amp; i1 &lt; cur-&gt;end) {
            <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(true, false); <I><FONT COLOR="#B22222">// found a suffix of the first string
</FONT></I>        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;begin &lt;= i2 &amp;&amp; i2 &lt; cur-&gt;end) {
            <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(false, true); <I><FONT COLOR="#B22222">// found a suffix of the second string
</FONT></I>        }
        pair&lt;<B><FONT COLOR="#228B22">bool</FONT></B>, <B><FONT COLOR="#228B22">bool</FONT></B>&gt; ret = make_pair(false, false);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(alphabets); i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;children[i]) {
                pair&lt;<B><FONT COLOR="#228B22">bool</FONT></B>, <B><FONT COLOR="#228B22">bool</FONT></B>&gt; temp = find_max_common_substring(cur-&gt;children[i], i1, i2);
                ret.x |= temp.x;
                ret.y |= temp.y;
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (ret.x &amp;&amp; ret.y) { <I><FONT COLOR="#B22222">// found a common substring
</FONT></I>            <B><FONT COLOR="#228B22">int</FONT></B> len = cur-&gt;depth + cur-&gt;end - cur-&gt;begin;
            <B><FONT COLOR="#A020F0">if</FONT></B> (len &gt; max_common_len) {
                max_common_len = len;
                max_common_begin = cur-&gt;begin - cur-&gt;depth; <I><FONT COLOR="#B22222">// give the starting position of the suffix
</FONT></I>            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> print_preorder(Node *cur) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur == root) cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;ROOT&quot;</FONT></B> &lt;&lt; endl;
        <B><FONT COLOR="#A020F0">else</FONT></B> cout &lt;&lt; concat_s.substr(cur-&gt;begin, cur-&gt;end - cur-&gt;begin) &lt;&lt; endl;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(alphabets); i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;children[i] != NULL) {
                print_preorder(cur-&gt;children[i]);
            }
        }
    }

    <B><FONT COLOR="#228B22">void</FONT></B> print_suffix_array(Node *cur) {
       <B><FONT COLOR="#228B22">bool</FONT></B> is_leaf = true;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(alphabets); i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;children[i] != NULL) {
                print_suffix_array(cur-&gt;children[i]);
                is_leaf = false;
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (is_leaf) {
            cout &lt;&lt; concat_s.substr(cur-&gt;begin - cur-&gt;depth, cur-&gt;end - (cur-&gt;begin - cur-&gt;depth)) &lt;&lt; endl;
        }
    }
<B><FONT COLOR="#228B22">public</FONT></B>:
    <I><FONT COLOR="#B22222">// Add more methods below
</FONT></I>    PII2 dfs(Node *cur, <B><FONT COLOR="#228B22">int</FONT></B> i1, <B><FONT COLOR="#228B22">int</FONT></B> i2, <B><FONT COLOR="#228B22">int</FONT></B> i3, vector&lt;LL&gt; &amp;ans) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;begin &lt;= i1 &amp;&amp; i1 &lt; cur-&gt;end) {
            <B><FONT COLOR="#A020F0">return</FONT></B> PLL2(PLL(1, 0), 0);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;begin &lt;= i2 &amp;&amp; i2 &lt; cur-&gt;end) {
            <B><FONT COLOR="#A020F0">return</FONT></B> PLL2(PLL(0, 1), 0);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;begin &lt;= i3 &amp;&amp; i3 &lt; cur-&gt;end) {
            <B><FONT COLOR="#A020F0">return</FONT></B> PLL2(PLL(0, 0), 1);
        }
        PLL2 ret = PLL2(PLL(0, 0), 0);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(alphabets); i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;children[i]) {
                PLL2 temp = dfs(cur-&gt;children[i], i1, i2, i3, ans);
                ret.x.x += temp.x.x;
                ret.x.y += temp.x.y;
                ret.y += temp.y;
                ret.x.x %= MOD; ret.x.y %= MOD; ret.y %= MOD;
            }
        }
        LL x = (((ret.x.x * ret.x.y) % MOD) * ret.y) % MOD;
        <B><FONT COLOR="#228B22">int</FONT></B> len = cur-&gt;depth + cur-&gt;end - cur-&gt;begin;
        ans[cur-&gt;depth] += x; ans[cur-&gt;depth] %= MOD;
        ans[len] -= x; <B><FONT COLOR="#A020F0">if</FONT></B> (ans[len] &lt; 0) ans[len] += MOD;
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    
    <B><FONT COLOR="#228B22">void</FONT></B> solve() {
        vector&lt;LL&gt; ans(SZ(concat_s), 0);
        <B><FONT COLOR="#228B22">int</FONT></B> len1 = SZ(strings[0]), len2 = SZ(strings[1]), len3 = SZ(strings[2]);
        dfs(root, len1, len1 + len2 + 1, len1 + len2 + len3 + 2, ans);
        <B><FONT COLOR="#228B22">int</FONT></B> min_len = min(len1, min(len2, len3));
        <B><FONT COLOR="#228B22">int</FONT></B> res = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; min_len; i++) {
            res += ans[i]; res %= MOD;
            printf(<B><FONT COLOR="#BC8F8F">&quot;%d &quot;</FONT></B>, (<B><FONT COLOR="#228B22">int</FONT></B>)res);
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    string s1, s2, s3;
    SuffixTree&lt;<B><FONT COLOR="#BC8F8F">'#'</FONT></B>&gt; tree;
    cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;
    tree.add_string(s1);
    tree.add_string(s2);
    tree.add_string(s3);
    tree.build_suffix_tree();
    tree.solve();
    <I><FONT COLOR="#B22222">/*
    {
        SuffixTree&lt;'#'&gt; tree;
        tree.add_string(&quot;baab&quot;);
        tree.build_suffix_tree();
        tree.print_preorder();
        tree.print_suffix_array();
    }

    {
        SuffixTree&lt;'#'&gt; tree;
        tree.add_string(&quot;banana&quot;);
        tree.add_string(&quot;xana&quot;);
        tree.build_suffix_tree();
        tree.find_max_common_substring();
    }
    */</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.6</A>.</ADDRESS>
</BODY>
</HTML>
