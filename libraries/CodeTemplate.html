<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>CodeTemplate for Competitive Programming</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<H1>Contents</H1>
<OL>
  <LI><A HREF="#file1">About.cpp</A>
  <LI><A HREF="#file2">DefaultCode.cpp</A>
  <LI><A HREF="#file3">Note.cpp</A>
  <LI><A HREF="#file4">algorithms/IntervalSet.cpp</A>
  <LI><A HREF="#file5">algorithms/MaxRecUnderHistogram.cpp</A>
  <LI><A HREF="#file6">algorithms/RangeMinimumQuery.cpp</A>
  <LI><A HREF="#file7">data_structure/CentroidDecomposition.cpp</A>
  <LI><A HREF="#file8">data_structure/FenwickTree.cpp</A>
  <LI><A HREF="#file9">data_structure/HeavyLightDecomposition.cpp</A>
  <LI><A HREF="#file10">data_structure/LazySegmentTree.cpp</A>
  <LI><A HREF="#file11">data_structure/SegmentTree.cpp</A>
  <LI><A HREF="#file12">data_structure/Treap.cpp</A>
  <LI><A HREF="#file13">dp/ConvexHullOptimization.cpp</A>
  <LI><A HREF="#file14">geometry/ClosestPair.cpp</A>
  <LI><A HREF="#file15">geometry/EarthCoordinates.cpp</A>
  <LI><A HREF="#file16">geometry/Line.cpp</A>
  <LI><A HREF="#file17">geometry/Util.cpp</A>
  <LI><A HREF="#file18">graph/BiconnectedComponent.cpp</A>
  <LI><A HREF="#file19">graph/Dinic.cpp</A>
  <LI><A HREF="#file20">graph/EulerCircuit.cpp</A>
  <LI><A HREF="#file21">graph/FordFulkerson.cpp</A>
  <LI><A HREF="#file22">graph/GlobalMinCut.cpp</A>
  <LI><A HREF="#file23">graph/LCA.cpp</A>
  <LI><A HREF="#file24">graph/MaximumBipartiteMatching.cpp</A>
  <LI><A HREF="#file25">graph/MinCostFlow.cpp</A>
  <LI><A HREF="#file26">graph/MinCostFlow_required_flow.cpp</A>
  <LI><A HREF="#file27">graph/MinimumPathCoverDAG.cpp</A>
  <LI><A HREF="#file28">graph/MinimumSpanningTree.cpp</A>
  <LI><A HREF="#file29">graph/ShortestPath.cpp</A>
  <LI><A HREF="#file30">graph/StronglyConnectedComponent.cpp</A>
  <LI><A HREF="#file31">number/LinearAlgebra.cpp</A>
  <LI><A HREF="#file32">number/Matrix.cpp</A>
  <LI><A HREF="#file33">number/ModInt.cpp</A>
  <LI><A HREF="#file34">number/PrimeGenerator.cpp</A>
  <LI><A HREF="#file35">number/Rational.cpp</A>
  <LI><A HREF="#file36">string/ManacherAlgorithm.cpp</A>
  <LI><A HREF="#file37">string/StringMatching.cpp</A>
  <LI><A HREF="#file38">string/SuffixArray.cpp</A>
  <LI><A HREF="#file39">string/SuffixTree.cpp</A>
</OL>
<HR>
<A NAME="file1">
<H1>About.cpp 1/39</H1>
[<A HREF="#top">top</A>][prev][<A HREF="#file2">next</A>]
<PRE>
<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Code Templates for Programming Contests
</FONT></I><I><FONT COLOR="#B22222">//    by Siwakorn Srisakaokul - ping128
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  The codes are from what I coded during programming contests 
</FONT></I><I><FONT COLOR="#B22222">//  and practice. Some codes are from Stanford University ACM Team 
</FONT></I><I><FONT COLOR="#B22222">//  Notebook (2011-12) (http://www.stanford.edu/~liszt90/acm/notebook.pdf) 
</FONT></I><I><FONT COLOR="#B22222">//  and http://e-maxx.ru/algo/
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  (gen command: enscript -tCodeTemplate\ for\ Competitive\ Programming -E
</FONT></I><I><FONT COLOR="#B22222">//                --color -whtml --toc -pCodeTemplate.html *.cpp */*.cpp)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////////
</FONT></I></PRE>
<HR>
<A NAME="file2">
<H1>DefaultCode.cpp 2/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file1">prev</A>][<A HREF="#file3">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PB</FONT></B>(x) push_back(x);
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (0x3f3f3f3f)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MEMSET</FONT></B>(x,v) memset(x,v,sizeof(x));

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII; <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;PII, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII2;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI; <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    
    
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file3">
<H1>Note.cpp 3/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file2">prev</A>][<A HREF="#file4">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  C++ Syntax
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Note:
</FONT></I><I><FONT COLOR="#B22222">//    alias g++=&quot;g++ -O2 -std=gnu++0x -Wall -Wshadow&quot;
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstring&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sstream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;set&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stack&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;list&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;map&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;time.h&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<I><FONT COLOR="#B22222">// Set Compare Function Example
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> shape_st {
    PII points[4];
    shape_st(){}
    shape_st(PII in[4]){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 4; i++ )
            points[i] = in[i];
        sort(points, points + 4);
    }

}Shape;

<B><FONT COLOR="#228B22">struct</FONT></B> ShapeCompare{
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>() (<B><FONT COLOR="#228B22">const</FONT></B> Shape s1, <B><FONT COLOR="#228B22">const</FONT></B> Shape s2) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 4; i++ ){
            <B><FONT COLOR="#A020F0">if</FONT></B>(s1.points[i] != s2.points[i])
                <B><FONT COLOR="#A020F0">return</FONT></B> s1.points[i] &lt; s2.points[i];
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
};

set&lt;Shape, ShapeCompare&gt; setShape;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {

    <B><FONT COLOR="#228B22">char</FONT></B> temp[100];
    string temp2;
    
    <I><FONT COLOR="#B22222">// scan until reaching \n
</FONT></I>    scanf(<B><FONT COLOR="#BC8F8F">&quot;%[^\n]&quot;</FONT></B>, temp);

    <I><FONT COLOR="#B22222">// scan until reaching :
</FONT></I>    scanf(<B><FONT COLOR="#BC8F8F">&quot;%[^:]&quot;</FONT></B>, temp);

    <I><FONT COLOR="#B22222">// get a line for string
</FONT></I>    getline(cin, temp2);

    <I><FONT COLOR="#B22222">// get a line for char[]
</FONT></I>    gets(temp);

    <I><FONT COLOR="#B22222">// int to string
</FONT></I>    cout &lt;&lt; to_string(1) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// string to int, stod, stol, stold, stoll
</FONT></I>    <I><FONT COLOR="#B22222">// int stoi (const string&amp;  str, size_t* idx = 0, int base = 10);
</FONT></I>    cout &lt;&lt; stoi(<B><FONT COLOR="#BC8F8F">&quot;1&quot;</FONT></B>) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// 1000 (base 2) -&gt; 8
</FONT></I>    cout &lt;&lt; stoi(<B><FONT COLOR="#BC8F8F">&quot;1000&quot;</FONT></B>, NULL, 2) &lt;&lt; endl;
    
    <I><FONT COLOR="#B22222">// string to char[]
</FONT></I>    string s = <B><FONT COLOR="#BC8F8F">&quot;123&quot;</FONT></B>;
    strcpy(temp, s.c_str());
    cout &lt;&lt; temp &lt;&lt; endl;
    
    <I><FONT COLOR="#B22222">// char[] to string
</FONT></I>    <B><FONT COLOR="#228B22">char</FONT></B> t[100] = <B><FONT COLOR="#BC8F8F">&quot;123&quot;</FONT></B>;
    cout &lt;&lt; string(t) &lt;&lt; endl;

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file4">
<H1>algorithms/IntervalSet.cpp 4/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file3">prev</A>][<A HREF="#file5">next</A>]
<PRE>
<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Interval Set
</FONT></I><I><FONT COLOR="#B22222">//  All intervals are [a, b).
</FONT></I><I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;set&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;PII&gt; VP;

<B><FONT COLOR="#228B22">class</FONT></B> IntervalSet {
<B><FONT COLOR="#228B22">public</FONT></B>:
    set&lt;PII&gt; S;
    IntervalSet () {}
    IntervalSet (VP &amp;v) { <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : v) { assert(e.x &lt; e.y); S.insert(e); } }
    PII get_intersection() {
        assert(SZ(S) &gt; 0);
        PII ret = *S.begin();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : S) { ret.x = max(ret.x, e.x); ret.y = min(ret.y, e.y); }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> length() {
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ret = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : S) ret += e.y - e.x;
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> union_intervals() {
        VP events;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : S) { events.push_back(PII(e.x, -1)); events.push_back(PII(e.y, 1)); }
        S.clear();
        sort(events.begin(), events.end());
        <B><FONT COLOR="#228B22">int</FONT></B> open_interval = 1, last_open = events[0].x;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; SZ(events); i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (!open_interval) last_open = events[i].x;
            open_interval -= events[i].y;
            <B><FONT COLOR="#A020F0">if</FONT></B> (!open_interval) S.insert(PII(last_open, events[i].x));
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> add(PII inter) {
        assert(inter.x &lt; inter.y);
        <B><FONT COLOR="#A020F0">if</FONT></B> (!S.empty()) {
            <B><FONT COLOR="#228B22">auto</FONT></B> it1 = S.lower_bound(PII(inter.x, inter.x));
            <B><FONT COLOR="#A020F0">if</FONT></B> (it1 != S.begin()) {
                <B><FONT COLOR="#228B22">auto</FONT></B> it2 = it1; it2--;
                <B><FONT COLOR="#A020F0">if</FONT></B> (it2-&gt;y &gt;= inter.x) { inter = union_overlap(inter, *it2); S.erase(it2); }
            }
            <B><FONT COLOR="#A020F0">while</FONT></B> (it1 != S.end()) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (inter.y &lt; it1-&gt;x) <B><FONT COLOR="#A020F0">break</FONT></B>;
                inter = union_overlap(inter, *it1);
                <B><FONT COLOR="#228B22">auto</FONT></B> temp = it1; temp++; S.erase(it1); it1 = temp;
            }
        }
        S.insert(inter);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> print() {
        printf(<B><FONT COLOR="#BC8F8F">&quot;{&quot;</FONT></B>); <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : S) printf(<B><FONT COLOR="#BC8F8F">&quot; (%d,%d)&quot;</FONT></B>, e.x, e.y); printf(<B><FONT COLOR="#BC8F8F">&quot; }\n&quot;</FONT></B>);
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    PII union_overlap(PII a, PII b) { <B><FONT COLOR="#A020F0">return</FONT></B> PII(min(a.x, b.x), max(a.y, b.y)); }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B> () {
    IntervalSet myset;
    myset.add(PII(1, 2)); myset.print();
    
    myset.add(PII(2, 5)); myset.print();
    myset.add(PII(1, 2)); myset.print();
    myset.add(PII(5, 6)); myset.print();

    myset.add(PII(10, 12)); myset.print();
    myset.add(PII(7, 10)); myset.print();
    myset.add(PII(0, 20)); myset.print();
    myset.add(PII(20, 22)); myset.print();
    cout &lt;&lt; myset.length() &lt;&lt; endl;

    vector&lt;PII&gt; v{PII(1, 2), PII(3, 5), PII(5, 7), PII(12, 15), PII(10, 13), PII(5, 8)};
    IntervalSet myset2 (v);
    myset2.union_intervals();
    myset2.print();
    cout &lt;&lt; myset2.length() &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file5">
<H1>algorithms/MaxRecUnderHistogram.cpp 5/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file4">prev</A>][<A HREF="#file6">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">// Maximum Rectangle Under Histogram
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// # #    # # 
</FONT></I><I><FONT COLOR="#B22222">// ### -&gt; MMM -&gt; ans: 3
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stack&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> Value_t&gt;
<B><FONT COLOR="#228B22">class</FONT></B> MaxRecUnderHistogram {
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;Value_t, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PVI;
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">public</FONT></B>:
    Value_t get_max(vector&lt;Value_t&gt; &amp;h) {
        <B><FONT COLOR="#228B22">int</FONT></B> N = SZ(h); VI left(N), right(N);
        stack&lt;PVI&gt; l_sk;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> x = i;
            <B><FONT COLOR="#A020F0">while</FONT></B> (!l_sk.empty()) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (l_sk.top().x &gt;= h[i]) { x = l_sk.top().y; l_sk.pop(); }
                <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
            left[i] = x; l_sk.push(PVI(h[i], x));
        }
        stack&lt;PVI&gt; r_sk;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = N - 1; i &gt;= 0; i--) {
            <B><FONT COLOR="#228B22">int</FONT></B> x = i;
            <B><FONT COLOR="#A020F0">while</FONT></B> (!r_sk.empty()) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (r_sk.top().x &gt;= h[i]) { x = r_sk.top().y; r_sk.pop(); }
                <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
            right[i] = x; r_sk.push(PVI(h[i], x));
        }
        Value_t ret = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            ret = max(ret, h[i] * (right[i] - left[i] + 1));
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
};


<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    MaxRecUnderHistogram&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; max_his;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;({2, 1, 2});
    assert(max_his.get_max(v) == 3);

    v = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;({4, 2, 1, 2, 1, 4, 2, 3, 2, 2, 1, 9});
    assert(max_his.get_max(v) == 12);

    v = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;({4, 2, 1, 2, 0, 4, 2, 3, 2, 2, 1, 9});
    assert(max_his.get_max(v) == 10);

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file6">
<H1>algorithms/RangeMinimumQuery.cpp 6/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file5">prev</A>][<A HREF="#file7">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Range Minimum Query
</FONT></I><I><FONT COLOR="#B22222">//  &lt;O(N lg N, lg N or O(1)&gt;
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> RangeMinimumQuery {
<B><FONT COLOR="#228B22">public</FONT></B>:
    vector&lt;vector&lt;T&gt; &gt; M;
    vector&lt;T&gt; A;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    RangeMinimumQuery(T in[], <B><FONT COLOR="#228B22">int</FONT></B> n) {
        N = n;
        M = vector&lt;vector&lt;T&gt; &gt;(N + 5);
        A = vector&lt;T&gt; (N + 5);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N + 5; i++)
            M[i] = vector&lt;T&gt; (25);

        <I><FONT COLOR="#B22222">//initialize M for the intervals with length 1
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            M[i][0] = i;
            A[i] = in[i];
        }
        <I><FONT COLOR="#B22222">//compute values from smaller to bigger intervals
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; 1&lt;&lt;j &lt;= N; j++){
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i + (1&lt;&lt;j) - 1 &lt; N; i++)
                <B><FONT COLOR="#A020F0">if</FONT></B> (A[M[i][j - 1]] &lt; A[M[i + (1 &lt;&lt; (j - 1))][j - 1]]) M[i][j] = M[i][j - 1];
                <B><FONT COLOR="#A020F0">else</FONT></B> M[i][j] = M[i + (1 &lt;&lt; (j - 1))][j - 1];
        }
    }

    <I><FONT COLOR="#B22222">// returns min(A[left...right])
</FONT></I>    <I><FONT COLOR="#B22222">// also can be modified to return the index
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> get_min(<B><FONT COLOR="#228B22">int</FONT></B> left, <B><FONT COLOR="#228B22">int</FONT></B> right) {
        <B><FONT COLOR="#228B22">int</FONT></B> num = right - left + 1;
        <B><FONT COLOR="#228B22">int</FONT></B> e = 1, k = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (e * 2 &lt;= num) e *= 2, k++;
        <B><FONT COLOR="#228B22">int</FONT></B> temp = right - e + 1;
        <B><FONT COLOR="#A020F0">if</FONT></B> (A[M[left][k]] &lt;= A[M[temp][k]]) <B><FONT COLOR="#A020F0">return</FONT></B> A[M[left][k]];
        <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> A[M[temp][k]];
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">bruteforce_rmq</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> *a, <B><FONT COLOR="#228B22">int</FONT></B> left, <B><FONT COLOR="#228B22">int</FONT></B> right) {
    <B><FONT COLOR="#228B22">int</FONT></B> ret = a[left];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = left + 1; i &lt;= right; i++) {
        ret = min(ret, a[i]);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N = 15;
    <B><FONT COLOR="#228B22">int</FONT></B> in[] = {-1, 4, 1, 6, 2, -10, 11, 3, 7, 100, 4, -123123123, 19, 1, -5};
    RangeMinimumQuery&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; rmq(in, N);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i; j &lt; N; j++) {
            assert(rmq.get_min(i, j) == bruteforce_rmq(in, i, j));
        }
    }
    <I><FONT COLOR="#B22222">/*
    assert(rmq.get_min(0, 0) == -1);
    assert(rmq.get_min(0, 9) == -10);
    assert(rmq.get_min(0, 2) == -1);
    assert(rmq.get_min(4, 9) == -10);
    assert(rmq.get_min(3, 3) == 6);
    assert(rmq.get_min(6, 8) == 3);
    */</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file7">
<H1>data_structure/CentroidDecomposition.cpp 7/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file6">prev</A>][<A HREF="#file8">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Centroid Decomposition
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://codeforces.com/contest/321/problem/C
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;


<B><FONT COLOR="#228B22">class</FONT></B> CentroidDecomposition {
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">private</FONT></B>:
    vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; removed;
    VI tree_size;
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    <B><FONT COLOR="#228B22">int</FONT></B> cd_root;
    VI cd_depths, cd_parents;
    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>    CentroidDecomposition (VVI &amp;graph) {
        N = graph.size(); cd_depths.resize(N); removed.resize(N);
        tree_size.resize(N); cd_parents.resize(N);
        cd_root = decompose(0, 0, graph); cd_parents[cd_root] = -1;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <I><FONT COLOR="#B22222">// Returns the centroid of the current subtree
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> decompose(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> dep, VVI &amp;adj) {
        <B><FONT COLOR="#228B22">int</FONT></B> center = find_center(at, adj);
        cd_depths[center] = dep; removed[center] = true;
        <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[center].size();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = adj[center][i];
            <B><FONT COLOR="#A020F0">if</FONT></B> (!removed[v]) {
                <B><FONT COLOR="#228B22">int</FONT></B> subroot = decompose(v, dep + 1, adj);
                cd_parents[subroot] = center;
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> center;
    }

    <I><FONT COLOR="#B22222">// Center node is the node whose all subtrees' size is not greater than half of the whole tree
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> find_center(<B><FONT COLOR="#228B22">int</FONT></B> at, VVI &amp;adj) {
        <B><FONT COLOR="#228B22">int</FONT></B> par = -1; cal_size(at, -1, adj);
        <B><FONT COLOR="#228B22">int</FONT></B> limit = tree_size[at] / 2;
        <B><FONT COLOR="#A020F0">while</FONT></B> (1) {
            <B><FONT COLOR="#228B22">bool</FONT></B> found = true; <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[at].size();
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
                <B><FONT COLOR="#228B22">int</FONT></B> v = adj[at][i];
                <B><FONT COLOR="#A020F0">if</FONT></B> (!removed[v] &amp;&amp; v != par &amp;&amp; tree_size[v] &gt; limit) {
                    found = false; par = at; at = v; <B><FONT COLOR="#A020F0">break</FONT></B>;
                }
            }
            <B><FONT COLOR="#A020F0">if</FONT></B> (found) <B><FONT COLOR="#A020F0">return</FONT></B> at;
        }
    }

    <B><FONT COLOR="#228B22">void</FONT></B> cal_size(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> par, VVI &amp;adj) {
        tree_size[at] = 1; <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[at].size();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = adj[at][i];
            <B><FONT COLOR="#A020F0">if</FONT></B> (!removed[v] &amp;&amp; par != v) {
                cal_size(v, at, adj); tree_size[at] += tree_size[v];
            }
        }
    }
};

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    VVI adj;
    <B><FONT COLOR="#228B22">int</FONT></B> u, v;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;N);
    adj.resize(N);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N - 1; i++ ){
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;u, &amp;v); u--, v--;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    CentroidDecomposition cd(adj);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        printf(<B><FONT COLOR="#BC8F8F">&quot;%c &quot;</FONT></B>, cd.cd_depths[i] + <B><FONT COLOR="#BC8F8F">'A'</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file8">
<H1>data_structure/FenwickTree.cpp 8/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file7">prev</A>][<A HREF="#file9">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Fenwick Tree
</FONT></I><I><FONT COLOR="#B22222">//  An example of sum fenwick tree
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Note: use map&lt;int, T&gt; instead of vector&lt;T&gt; for Sparse Fenwick Tree
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> FenwickTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    vector&lt;T&gt; data;
    <B><FONT COLOR="#228B22">int</FONT></B> N;

    <I><FONT COLOR="#B22222">// Indices are 1-based.
</FONT></I>    FenwickTree(<B><FONT COLOR="#228B22">int</FONT></B> n) {
        N = n;
        data = vector&lt;T&gt;(N + 5);
    }

    <I><FONT COLOR="#B22222">// Return the prefix sum XXXXXXat....
</FONT></I>    T query(<B><FONT COLOR="#228B22">int</FONT></B> at) {
        T res = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = at; i; i -= (i &amp; (-i)))
            res += data[i];
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }

    <I><FONT COLOR="#B22222">// Add a value to a single element
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> at, T value) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = at; i &lt;= N; i += (i &amp; (-i)))
            data[i] += value;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    FenwickTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; tree(10);
    <B><FONT COLOR="#228B22">int</FONT></B> sum = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++) tree.update(i, i);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++) {
        sum += i;
        assert(tree.query(i) == sum);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++) tree.update(i, i * i);
    sum = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++) {
        sum += i * i + i;
        assert(tree.query(i) == sum);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
    
    

</PRE>
<HR>
<A NAME="file9">
<H1>data_structure/HeavyLightDecomposition.cpp 9/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file8">prev</A>][<A HREF="#file10">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Heavy Light Decompostion (only support a single tree node updating)
</FONT></I><I><FONT COLOR="#B22222">//  An example of how to solve a problem where there are 2 types of queries
</FONT></I><I><FONT COLOR="#B22222">//      1. change an edge's weight
</FONT></I><I><FONT COLOR="#B22222">//      2. find the max weight among all edges alone the path (u, v)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://www.spoj.com/problems/QTREE/
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstring&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Value_t&gt;
<B><FONT COLOR="#228B22">class</FONT></B> SegmentTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> segment_st {
        Value_t value;
        <B><FONT COLOR="#228B22">int</FONT></B> left, right;
    } TreeNode;

    vector&lt;TreeNode&gt; tree;
    <B><FONT COLOR="#228B22">int</FONT></B> N; <I><FONT COLOR="#B22222">// the number of data
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> tree_size; <I><FONT COLOR="#B22222">// the number of tree nodes
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; leaves; <I><FONT COLOR="#B22222">// leaves' indices
</FONT></I>    SegmentTree(<B><FONT COLOR="#228B22">int</FONT></B> n) { vector&lt;Value_t&gt; v(n); build_tree(n, v); }
    SegmentTree(<B><FONT COLOR="#228B22">int</FONT></B> n, vector&lt;Value_t&gt; &amp;v) { build_tree(n, v); }
    Value_t query(<B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr) { <B><FONT COLOR="#A020F0">return</FONT></B> query(1, ll, rr); }
    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t val) { internal_update(at, val); }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> build_tree(<B><FONT COLOR="#228B22">int</FONT></B> n, vector&lt;Value_t&gt; &amp;v){
        N = n; <B><FONT COLOR="#228B22">int</FONT></B> base = 1; <B><FONT COLOR="#A020F0">while</FONT></B> (base &lt; N) base *= 2; tree_size = base * 2;
        leaves.resize(N + 1); tree = vector&lt;TreeNode&gt; (tree_size);
        init(1, 1, n, v);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> init(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr, vector&lt;Value_t&gt; &amp;v) {
        tree[at].left = ll; tree[at].right = rr;
        <B><FONT COLOR="#A020F0">if</FONT></B>(ll == rr) { tree[at].value = v[ll - 1]; leaves[ll] = at; }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = (tree[at].left + tree[at].right) / 2;
            init(at * 2, tree[at].left, mid, v);
            init(at * 2 + 1, mid + 1, tree[at].right, v);
            update_up(at);
        }
    }

    <I><FONT COLOR="#B22222">// Return the node's value
</FONT></I>    Value_t node_to_value(<B><FONT COLOR="#228B22">int</FONT></B> at) {
        <B><FONT COLOR="#A020F0">return</FONT></B> tree[at].value;
    }

    <I><FONT COLOR="#B22222">// Recalculate the parent's value
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_up(<B><FONT COLOR="#228B22">int</FONT></B> at){
        tree[at].value = max(node_to_value(at * 2), node_to_value(at * 2 + 1));
    }

    <I><FONT COLOR="#B22222">// Update the result
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_result(Value_t &amp;res, Value_t val) {
        res = max(res, val);
    }

    <I><FONT COLOR="#B22222">// Update leaf's value for internal update
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_leaf_value(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t val) {
        tree[at].value = val;
    }

    Value_t query(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr){
        <B><FONT COLOR="#A020F0">if</FONT></B>(tree[at].left == ll &amp;&amp; tree[at].right == rr){
            <B><FONT COLOR="#A020F0">return</FONT></B> node_to_value(at);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = (tree[at].left + tree[at].right) / 2;
            Value_t res = 0;
            <B><FONT COLOR="#A020F0">if</FONT></B>(ll &lt;= mid) update_result(res, query(at * 2, ll, min(rr, mid)));
            <B><FONT COLOR="#A020F0">if</FONT></B>(rr &gt; mid) update_result(res, query(at * 2 + 1, max(mid + 1, ll), rr));
            <B><FONT COLOR="#A020F0">return</FONT></B> res;
        }
    }

    <B><FONT COLOR="#228B22">void</FONT></B> internal_update(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t val) {
        at = leaves[at];
        update_leaf_value(at, val);
        at /= 2;
        <B><FONT COLOR="#A020F0">while</FONT></B> (at) { update_up(at); at /= 2; }
    }
};


<I><FONT COLOR="#B22222">// Value's type, Max number of nodes, true if values on vertices
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">class</FONT></B> Value_t, <B><FONT COLOR="#228B22">int</FONT></B> MN, <B><FONT COLOR="#228B22">bool</FONT></B> VALUE_ON_VERTICES&gt;
<B><FONT COLOR="#228B22">class</FONT></B> HeavyLightDecompositon {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> ON_VERTICES = VALUE_ON_VERTICES;
    <B><FONT COLOR="#228B22">int</FONT></B> N, M; <I><FONT COLOR="#B22222">// number of vertices, edges
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> head[MN], weight[MN*2], to[MN*2], nxt[MN*2], ecnt;
    <B><FONT COLOR="#228B22">int</FONT></B> edge_id[MN]; <I><FONT COLOR="#B22222">// i-th edge (u,v,c) = (to[id], to[id^1], weight[id]), id = edge_id[i]
</FONT></I>    Value_t node_value[MN]; <I><FONT COLOR="#B22222">// node value is initialized in tree_setup
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> tree_size[MN], parent[MN], dep[MN], heaviest_child[MN];
    <B><FONT COLOR="#228B22">int</FONT></B> chain_head[MN], dfs_clock, num_chain;
    <B><FONT COLOR="#228B22">int</FONT></B> pos_on_base_array[MN]; <I><FONT COLOR="#B22222">// 1-based
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> vertex_on_base_array[MN]; <I><FONT COLOR="#B22222">// 1-based
</FONT></I>    vector&lt;Value_t&gt; base_array_value; <I><FONT COLOR="#B22222">// 0-based
</FONT></I>    <I><FONT COLOR="#B22222">// Vertices and Edges are 1-based indexed.
</FONT></I>    HeavyLightDecompositon(<B><FONT COLOR="#228B22">int</FONT></B> n) {
        N = n; ecnt = 2, M = 0; base_array_value.resize(N+5);
        memset(head, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(head));
    }
    <I><FONT COLOR="#B22222">// Returns base_array_value
</FONT></I>    vector&lt;Value_t&gt; decompose() {
        initialize_node_value(1, -1);
        internal_tree_setup(1, 0, 0);
        dfs_clock = 0; num_chain = 1;
        internal_dfs_heavy_edge(1, 1);
        <B><FONT COLOR="#A020F0">return</FONT></B> base_array_value;
    }
    <I><FONT COLOR="#B22222">// Initialize node's value ***
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> initialize_node_value(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> par) {
        node_value[u] = 1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = head[u]; p; p = nxt[p]) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = to[p]; <B><FONT COLOR="#A020F0">if</FONT></B> (v == par) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            initialize_node_value(v, u);
            <B><FONT COLOR="#A020F0">if</FONT></B> (ON_VERTICES) {  <I><FONT COLOR="#B22222">// Value on vertices case
</FONT></I>                node_value[u] += node_value[v];
            } <B><FONT COLOR="#A020F0">else</FONT></B> {            <I><FONT COLOR="#B22222">// Value on edges case
</FONT></I>                node_value[v] = weight[p];
            }
        }
    }
    <I><FONT COLOR="#B22222">// Set base_array_value[ind] by considering the current node
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> set_base_array_value(<B><FONT COLOR="#228B22">int</FONT></B> ind, <B><FONT COLOR="#228B22">int</FONT></B> cur_node) {
        base_array_value[ind] = node_value[cur_node];
    }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, <B><FONT COLOR="#228B22">int</FONT></B> c) {
        edge_id[++M] = ecnt;
        to[ecnt] = v; weight[ecnt] = c; nxt[ecnt] = head[u]; head[u] = ecnt++;
        to[ecnt] = u; weight[ecnt] = c; nxt[ecnt] = head[v]; head[v] = ecnt++;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> internal_tree_setup(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> par, <B><FONT COLOR="#228B22">int</FONT></B> depth) {
        <B><FONT COLOR="#228B22">int</FONT></B> maxsize = 0;
        parent[u] = par; dep[u] = depth;
        tree_size[u] = 1; heaviest_child[u] = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = head[u]; p; p = nxt[p]) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = to[p]; <B><FONT COLOR="#A020F0">if</FONT></B> (v == par) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            internal_tree_setup(v, u, depth + 1);
            tree_size[u] += tree_size[v];
            <B><FONT COLOR="#A020F0">if</FONT></B> (tree_size[v] &gt; maxsize) { maxsize = tree_size[v]; heaviest_child[u] = v; }
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> internal_dfs_heavy_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> chain_head_id) {
        pos_on_base_array[u] = ++dfs_clock; chain_head[u] = chain_head_id;
        vertex_on_base_array[dfs_clock] = u;
        set_base_array_value(dfs_clock - 1, u);
        <B><FONT COLOR="#A020F0">if</FONT></B>(heaviest_child[u])
            internal_dfs_heavy_edge(heaviest_child[u], chain_head_id); <I><FONT COLOR="#B22222">// Expand the chain
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> p = head[u]; p; p = nxt[p]) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = to[p]; <B><FONT COLOR="#A020F0">if</FONT></B>(v == parent[u] || v == heaviest_child[u]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            num_chain++; <I><FONT COLOR="#B22222">// Create a new chain
</FONT></I>            internal_dfs_heavy_edge(v, v);
        }
    }
};

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MAXN = 10010;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> INF = 0x7fffffff;
<B><FONT COLOR="#228B22">typedef</FONT></B> HeavyLightDecompositon&lt;<B><FONT COLOR="#228B22">int</FONT></B>, MAXN, false&gt; HLD;
<B><FONT COLOR="#228B22">typedef</FONT></B> SegmentTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; SegTree;

<I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">// Using HLD and Segment tree to process query and update
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////
</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">update_result</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> &amp;res, <B><FONT COLOR="#228B22">int</FONT></B> val) {
    res = max(res, val);
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">query</FONT></B>(SegTree &amp;seg_tree, HLD &amp;hld, <B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y) {
    <B><FONT COLOR="#228B22">int</FONT></B> res = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B>(hld.chain_head[x] != hld.chain_head[y]) {
        <B><FONT COLOR="#228B22">int</FONT></B> head_x = hld.chain_head[x], head_y = hld.chain_head[y];
        <B><FONT COLOR="#A020F0">if</FONT></B>(hld.dep[head_x] &lt; hld.dep[head_y]) swap(x, y), swap(head_x, head_y);
        update_result(res, seg_tree.query(hld.pos_on_base_array[head_x],
                                          hld.pos_on_base_array[x]));
        x = hld.parent[head_x];
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(hld.dep[x] &gt; hld.dep[y]) swap(x, y);
    <B><FONT COLOR="#228B22">int</FONT></B> from = hld.pos_on_base_array[x] + (hld.ON_VERTICES == false);
    <B><FONT COLOR="#228B22">int</FONT></B> to = hld.pos_on_base_array[y];
    update_result(res, seg_tree.query(from, to));
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">update</FONT></B>(SegTree &amp;seg_tree, HLD &amp;hld, <B><FONT COLOR="#228B22">int</FONT></B> e, <B><FONT COLOR="#228B22">int</FONT></B> y) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (hld.ON_VERTICES) { <I><FONT COLOR="#B22222">// Value on vertices
</FONT></I>        seg_tree.update(hld.pos_on_base_array[e], y);
    } <B><FONT COLOR="#A020F0">else</FONT></B> {               <I><FONT COLOR="#B22222">// Value on edges
</FONT></I>        e = hld.edge_id[e];
        <B><FONT COLOR="#228B22">int</FONT></B> u = hld.to[e], v = hld.to[e ^ 1];
        <B><FONT COLOR="#A020F0">if</FONT></B>(hld.parent[v] == u) swap(u, v);
        <I><FONT COLOR="#B22222">// Update the lower end of this edge e
</FONT></I>        seg_tree.update(hld.pos_on_base_array[u], y);
    }
}

<B><FONT COLOR="#228B22">char</FONT></B> str[15];
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> n;
    <B><FONT COLOR="#228B22">int</FONT></B> T; scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;T);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> t = 1; t &lt;= T; ++t) {
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;n);
        HLD hld(n);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; n; ++i) {
            <B><FONT COLOR="#228B22">int</FONT></B> u, v, c;
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %d&quot;</FONT></B>, &amp;u, &amp;v, &amp;c);
            hld.add_edge(u, v, c);
        }
        vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; base_array_value = hld.decompose();
        SegTree seg_tree(n, base_array_value);
        <B><FONT COLOR="#A020F0">while</FONT></B>(scanf(<B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, str) &amp;&amp; *str != <B><FONT COLOR="#BC8F8F">'D'</FONT></B>) {
            <B><FONT COLOR="#228B22">int</FONT></B> x, y;
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;x, &amp;y);
            <B><FONT COLOR="#A020F0">if</FONT></B>(*str == <B><FONT COLOR="#BC8F8F">'C'</FONT></B>) update(seg_tree, hld, x, y);
            <B><FONT COLOR="#A020F0">else</FONT></B> printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, query(seg_tree, hld, x, y));
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file10">
<H1>data_structure/LazySegmentTree.cpp 10/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file9">prev</A>][<A HREF="#file11">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Lazy Segment Tree (lazy propagation)
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Value_t, <B><FONT COLOR="#228B22">class</FONT></B> Lazy_t&gt;
<B><FONT COLOR="#228B22">class</FONT></B> LazySegmentTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> tree_st {
        Value_t value;
        Lazy_t lazy;
        <B><FONT COLOR="#228B22">int</FONT></B> left, right;
    } TreeNode;

    vector&lt;TreeNode&gt; tree;
    <B><FONT COLOR="#228B22">int</FONT></B> N; <I><FONT COLOR="#B22222">// the number of data
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> tree_size; <I><FONT COLOR="#B22222">// the number of tree nodes
</FONT></I>    LazySegmentTree(<B><FONT COLOR="#228B22">int</FONT></B> n) { vector&lt;Value_t&gt; v(n); build_tree(n, v); }
    LazySegmentTree(<B><FONT COLOR="#228B22">int</FONT></B> n, vector&lt;Value_t&gt; &amp;v) { build_tree(n, v); }
    Value_t query(<B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr) { <B><FONT COLOR="#A020F0">return</FONT></B> query(1, ll, rr); }
    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr, Value_t val) { update(1, ll, rr, val); }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> build_tree(<B><FONT COLOR="#228B22">int</FONT></B> n, vector&lt;Value_t&gt; &amp;v){
        N = n; <B><FONT COLOR="#228B22">int</FONT></B> base = 1; <B><FONT COLOR="#A020F0">while</FONT></B> (base &lt; N) base *= 2; tree_size = base * 2;
        tree = vector&lt;TreeNode&gt; (tree_size);
        init(1, 1, n, v);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> init(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr, vector&lt;Value_t&gt; &amp;v) {
        tree[at].left = ll; tree[at].right = rr;
        initialize_laziness(at);
        <B><FONT COLOR="#A020F0">if</FONT></B>(ll == rr) tree[at].value = v[ll - 1];
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = (tree[at].left + tree[at].right) / 2;
            init(at * 2, tree[at].left, mid, v);
            init(at * 2 + 1, mid + 1, tree[at].right, v);
            update_up(at);
        }
    }

    <I><FONT COLOR="#B22222">// Initialize node's laziness
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> initialize_laziness (<B><FONT COLOR="#228B22">int</FONT></B> at) {
        tree[at].lazy = 0;
    }    
    
    <I><FONT COLOR="#B22222">// Return the node's value (considering the given node's value and laziness)
</FONT></I>    Value_t node_to_value(<B><FONT COLOR="#228B22">int</FONT></B> at) {
        <B><FONT COLOR="#A020F0">return</FONT></B> tree[at].value + (tree[at].right - tree[at].left + 1) * tree[at].lazy;
    }

    <I><FONT COLOR="#B22222">// Update the node laziness
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_laziness(<B><FONT COLOR="#228B22">int</FONT></B> at, Lazy_t lazy) {
        tree[at].lazy += lazy;
    }
    
    <I><FONT COLOR="#B22222">// Recalculate the parent's value without considering the parent's laziness
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_up(<B><FONT COLOR="#228B22">int</FONT></B> at){
        tree[at].value = node_to_value(at * 2) + node_to_value(at * 2 + 1);
    }

    <I><FONT COLOR="#B22222">// Update the childrens' laziness
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_down(<B><FONT COLOR="#228B22">int</FONT></B> at){
        <B><FONT COLOR="#A020F0">if</FONT></B> (tree[at].lazy == 0) <B><FONT COLOR="#A020F0">return</FONT></B> ; <I><FONT COLOR="#B22222">// no need to update
</FONT></I>        update_laziness(at * 2, tree[at].lazy);
        update_laziness(at * 2 + 1, tree[at].lazy);
        tree[at].lazy = 0;
    }

    <I><FONT COLOR="#B22222">// Update the result
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_result(Value_t &amp;res, Value_t val) {
        res += val;
    }
    
    Value_t query(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr){
        <B><FONT COLOR="#A020F0">if</FONT></B>(tree[at].left == ll &amp;&amp; tree[at].right == rr){
            <B><FONT COLOR="#A020F0">return</FONT></B> node_to_value(at);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            update_down(at);
            <B><FONT COLOR="#228B22">int</FONT></B> mid = (tree[at].left + tree[at].right) / 2;
            Value_t res = 0;
            <B><FONT COLOR="#A020F0">if</FONT></B>(ll &lt;= mid) update_result(res, query(at * 2, ll, min(rr, mid)));
            <B><FONT COLOR="#A020F0">if</FONT></B>(rr &gt; mid) update_result(res, query(at * 2 + 1, max(mid + 1, ll), rr));
            update_up(at);
            <B><FONT COLOR="#A020F0">return</FONT></B> res;
        }
    }

    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr, Value_t val){
        <B><FONT COLOR="#A020F0">if</FONT></B>(tree[at].left == ll &amp;&amp; tree[at].right == rr){
            update_laziness(at, val);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            update_down(at);
            <B><FONT COLOR="#228B22">int</FONT></B> mid = (tree[at].left + tree[at].right) / 2;
            <B><FONT COLOR="#A020F0">if</FONT></B>(ll &lt;= mid) update(at * 2, ll, min(rr, mid), val);
            <B><FONT COLOR="#A020F0">if</FONT></B>(rr &gt; mid) update(at * 2 + 1, max(mid + 1, ll), rr, val);
            update_up(at);
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    <B><FONT COLOR="#228B22">int</FONT></B> N = 7;
    LazySegmentTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; tree(N);
    tree.update(1, 7, 4);
    assert(tree.query(1, 7) == 28);
    tree.update(3, 5, 2);
    assert(tree.query(3, 3) == 6);
    assert(tree.query(1, 7) == 34);
    assert(tree.query(5, 6) == 10);
    assert(tree.query(1, 4) == 20);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file11">
<H1>data_structure/SegmentTree.cpp 11/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file10">prev</A>][<A HREF="#file12">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Segment Tree
</FONT></I><I><FONT COLOR="#B22222">//  Only work for single element updating
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Value_t&gt;
<B><FONT COLOR="#228B22">class</FONT></B> SegmentTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> segment_st {
        Value_t value;
        <B><FONT COLOR="#228B22">int</FONT></B> left, right;
    } TreeNode;

    vector&lt;TreeNode&gt; tree;
    <B><FONT COLOR="#228B22">int</FONT></B> N; <I><FONT COLOR="#B22222">// the number of data
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> tree_size; <I><FONT COLOR="#B22222">// the number of tree nodes
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; leaves; <I><FONT COLOR="#B22222">// leaves' indices
</FONT></I>    SegmentTree(<B><FONT COLOR="#228B22">int</FONT></B> n) { vector&lt;Value_t&gt; v(n); build_tree(n, v); }
    SegmentTree(<B><FONT COLOR="#228B22">int</FONT></B> n, vector&lt;Value_t&gt; &amp;v) { build_tree(n, v); }
    Value_t query(<B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr) { <B><FONT COLOR="#A020F0">return</FONT></B> query(1, ll, rr); }
    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t val) { internal_update(at, val); }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> build_tree(<B><FONT COLOR="#228B22">int</FONT></B> n, vector&lt;Value_t&gt; &amp;v){
        N = n; <B><FONT COLOR="#228B22">int</FONT></B> base = 1; <B><FONT COLOR="#A020F0">while</FONT></B> (base &lt; N) base *= 2; tree_size = base * 2;
        leaves.resize(N + 1); tree = vector&lt;TreeNode&gt; (tree_size);
        init(1, 1, n, v);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> init(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr, vector&lt;Value_t&gt; &amp;v) {
        tree[at].left = ll; tree[at].right = rr;
        <B><FONT COLOR="#A020F0">if</FONT></B>(ll == rr) { tree[at].value = v[ll - 1]; leaves[ll] = at; }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = (tree[at].left + tree[at].right) / 2;
            init(at * 2, tree[at].left, mid, v);
            init(at * 2 + 1, mid + 1, tree[at].right, v);
            update_up(at);
        }
    }
    <I><FONT COLOR="#B22222">// Set the initial value
</FONT></I>    Value_t initial_value() {
        <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
    <I><FONT COLOR="#B22222">// Return the node's value
</FONT></I>    Value_t node_to_value(<B><FONT COLOR="#228B22">int</FONT></B> at) {
        <B><FONT COLOR="#A020F0">return</FONT></B> tree[at].value;
    }
    <I><FONT COLOR="#B22222">// Recalculate the parent's value
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_up(<B><FONT COLOR="#228B22">int</FONT></B> at){
        tree[at].value = node_to_value(at * 2) + node_to_value(at * 2 + 1);
    }
    <I><FONT COLOR="#B22222">// Update the result
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_result(Value_t &amp;res, Value_t val) {
        res += val;
    }
    <I><FONT COLOR="#B22222">// Update leaf's value for internal update
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update_leaf_value(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t val) {
        tree[at].value += val;
    }
    Value_t query(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> ll, <B><FONT COLOR="#228B22">int</FONT></B> rr){
        <B><FONT COLOR="#A020F0">if</FONT></B>(tree[at].left == ll &amp;&amp; tree[at].right == rr){
            <B><FONT COLOR="#A020F0">return</FONT></B> node_to_value(at);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = (tree[at].left + tree[at].right) / 2;
            Value_t res = initial_value();
            <B><FONT COLOR="#A020F0">if</FONT></B>(ll &lt;= mid) update_result(res, query(at * 2, ll, min(rr, mid)));
            <B><FONT COLOR="#A020F0">if</FONT></B>(rr &gt; mid) update_result(res, query(at * 2 + 1, max(mid + 1, ll), rr));
            <B><FONT COLOR="#A020F0">return</FONT></B> res;
        }
    }

    <B><FONT COLOR="#228B22">void</FONT></B> internal_update(<B><FONT COLOR="#228B22">int</FONT></B> at, Value_t val) {
        at = leaves[at];
        update_leaf_value(at, val);
        at /= 2;
        <B><FONT COLOR="#A020F0">while</FONT></B> (at) { update_up(at); at /= 2; }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    <B><FONT COLOR="#228B22">int</FONT></B> N = 7;
    SegmentTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; tree(N);
    <B><FONT COLOR="#228B22">int</FONT></B> sum = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) {
        tree.update(i, i);
        sum += i;
        assert(tree.query(1, N) == sum);
        assert(tree.query(i, i) == i);
    }
    sum += 10;
    tree.update(4, 10);
    assert(tree.query(1, N) == sum);
    assert(tree.query(1, 3) == 6);
    assert(tree.query(4, 5) == 19);
    assert(tree.query(5, 6) == 11);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file12">
<H1>data_structure/Treap.cpp 12/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file11">prev</A>][<A HREF="#file13">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Treap - randomized binary search tree
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T1, <B><FONT COLOR="#228B22">class</FONT></B> T2&gt;
ostream&amp; <B><FONT COLOR="#A020F0">operator</FONT></B> &lt;&lt; (ostream &amp;out, pair&lt;T1, T2&gt; pair) { <B><FONT COLOR="#A020F0">return</FONT></B> out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> &lt;&lt; pair.first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B> &lt;&lt; pair.second &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>; }

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;

<I><FONT COLOR="#B22222">/*
 * Treap Class Declaration
 * 
 * DO NOT FORGET TO CALL SRAND IN MAIN: srand(time(NULL));
 */</FONT></I>
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> Treap {
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> Treapnode {
        T key; <I><FONT COLOR="#B22222">// (x = key, y = id) can differentiate the duplicate keys
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> fix;
        Treapnode *left, *right;
        <B><FONT COLOR="#228B22">int</FONT></B> subtree_size;

        LL sum; <I><FONT COLOR="#B22222">// sum of all keys
</FONT></I>        Treapnode() {
            left = right = NULL;
            subtree_size = 0;
            sum = 0;
        }
    } *Treapnode_ptr;
    
<B><FONT COLOR="#228B22">public</FONT></B>:
    Treapnode_ptr root;

    Treap() {
        root = NULL;
    }
    
    <B><FONT COLOR="#228B22">void</FONT></B> insert(T key) {
        insert(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root, key);
    }
    
    <B><FONT COLOR="#228B22">void</FONT></B> remove(T key) {
        remove(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root, key);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> display() {
        display(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root, 1);
    }

    <B><FONT COLOR="#228B22">bool</FONT></B> find(T key) {
        <B><FONT COLOR="#A020F0">return</FONT></B> find(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root, key);
    }

    T find_ksmallest(<B><FONT COLOR="#228B22">int</FONT></B> k) {
        assert(k &gt;= 1 &amp;&amp; k &lt;= <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root-&gt;subtree_size);
        <B><FONT COLOR="#A020F0">return</FONT></B> find_ksmallest(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root, k);
    }

    LL find_ksmallest_sum(<B><FONT COLOR="#228B22">int</FONT></B> k) {
        assert(k &gt;= 1 &amp;&amp; k &lt;= <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root-&gt;subtree_size);
        <B><FONT COLOR="#A020F0">return</FONT></B> find_ksmallest_sum(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root, k);
    }
        
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> insert(Treapnode_ptr &amp;node, T key) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node == NULL) {
            node = <B><FONT COLOR="#A020F0">new</FONT></B> Treapnode();
            node-&gt;left = node-&gt;right = NULL;
            node-&gt;key = key;
            node-&gt;fix = rand();
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;key == key) {
                <I><FONT COLOR="#B22222">// do nothing
</FONT></I>            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;key &gt; key) {
                insert(node-&gt;left, key);
                <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left-&gt;fix &gt; node-&gt;fix)
                    rotate_right(node);
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                insert(node-&gt;right, key);
                <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;right-&gt;fix &gt; node-&gt;fix)
                    rotate_left(node);
            }
        }
        update_size(node);
        update_sum(node);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> remove(Treapnode_ptr &amp;node, T key) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (key &gt; node-&gt;key) {
                remove(node-&gt;right, key);
                update_size(node);
                update_sum(node);
            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (key &lt; node-&gt;key) {
                remove(node-&gt;left, key);
                update_size(node);
                update_sum(node);
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) {
                    <B><FONT COLOR="#A020F0">delete</FONT></B> node;
                    node = NULL;
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left == NULL) {
                    Treapnode_ptr temp = node;
                    node = node-&gt;right;
                    <B><FONT COLOR="#A020F0">delete</FONT></B> temp;
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;right == NULL) {
                    Treapnode_ptr temp = node;
                    node = node-&gt;left;
                    <B><FONT COLOR="#A020F0">delete</FONT></B> temp;
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left-&gt;fix &lt; node-&gt;right-&gt;fix) {
                        rotate_left(node);
                        remove(node-&gt;left, key);
                    } <B><FONT COLOR="#A020F0">else</FONT></B> {
                        rotate_right(node);
                        remove(node-&gt;right, key);
                    }
                    update_size(node);
                    update_sum(node);
                }
            }
        }
    }

    <B><FONT COLOR="#228B22">bool</FONT></B> find(Treapnode_ptr node, T key) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;key == key) <B><FONT COLOR="#A020F0">return</FONT></B> true;
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (key &lt; node-&gt;key) <B><FONT COLOR="#A020F0">return</FONT></B> find(node-&gt;left, key);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> find(node-&gt;right, key);
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <B><FONT COLOR="#228B22">void</FONT></B> rotate_left(Treapnode_ptr &amp;node) {
        Treapnode_ptr temp;
        temp = node-&gt;right;
        node-&gt;right = temp-&gt;left;
        temp-&gt;left = node;
        node = temp;
        update_size(node-&gt;left);
        update_size(node);
        update_sum(node-&gt;left);
        update_sum(node);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> rotate_right(Treapnode_ptr &amp;node) {
        Treapnode_ptr temp;
        temp = node-&gt;left;
        node-&gt;left = temp-&gt;right;
        temp-&gt;right = node;
        node = temp;
        update_size(node-&gt;right);
        update_size(node);
        update_sum(node-&gt;right);
        update_sum(node);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> display(Treapnode_ptr node, <B><FONT COLOR="#228B22">int</FONT></B> level) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node) {
            display(node-&gt;right, level + 1);
            <B><FONT COLOR="#A020F0">if</FONT></B> (node == <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;root)
                cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Root-&gt;: &quot;</FONT></B>;
            <B><FONT COLOR="#A020F0">else</FONT></B>
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; level; i++)
                    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\t&quot;</FONT></B>;
            cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;key: &quot;</FONT></B> &lt;&lt; node-&gt;key &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, sz: &quot;</FONT></B> &lt;&lt; node-&gt;subtree_size &lt;&lt; endl;
            display(node-&gt;left, level + 1);
        }
    }

    <B><FONT COLOR="#228B22">void</FONT></B> update_size(Treapnode_ptr node) {
        node-&gt;subtree_size = 1;
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left) node-&gt;subtree_size += node-&gt;left-&gt;subtree_size;
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;right) node-&gt;subtree_size += node-&gt;right-&gt;subtree_size;            
    }

    <B><FONT COLOR="#228B22">void</FONT></B> update_sum(Treapnode_ptr node) {
        node-&gt;sum = node-&gt;key.first;
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left) node-&gt;sum += node-&gt;left-&gt;sum;
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;right) node-&gt;sum += node-&gt;right-&gt;sum;
    }

    T find_ksmallest(Treapnode_ptr node, <B><FONT COLOR="#228B22">int</FONT></B> k) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left == NULL) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (k == 1)
                <B><FONT COLOR="#A020F0">return</FONT></B> node-&gt;key;
            <B><FONT COLOR="#A020F0">return</FONT></B> find_ksmallest(node-&gt;right, k - 1);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> num_left = node-&gt;left-&gt;subtree_size;
            <B><FONT COLOR="#A020F0">if</FONT></B> (k &lt;= num_left)
                <B><FONT COLOR="#A020F0">return</FONT></B> find_ksmallest(node-&gt;left, k);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (k == num_left + 1)
                <B><FONT COLOR="#A020F0">return</FONT></B> node-&gt;key;
            <B><FONT COLOR="#A020F0">else</FONT></B>
                <B><FONT COLOR="#A020F0">return</FONT></B> find_ksmallest(node-&gt;right, k - num_left - 1);
        }
    }

    LL find_ksmallest_sum(Treapnode_ptr node, <B><FONT COLOR="#228B22">int</FONT></B> k) {
        LL res = 0;
        <B><FONT COLOR="#A020F0">if</FONT></B> (node &amp;&amp; k) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;left == NULL) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (k == node-&gt;subtree_size)
                    res = node-&gt;sum;
                <B><FONT COLOR="#A020F0">else</FONT></B>
                    res = node-&gt;key.first + find_ksmallest_sum(node-&gt;right, k - 1);
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                <B><FONT COLOR="#228B22">int</FONT></B> num_left = node-&gt;left-&gt;subtree_size;
                <B><FONT COLOR="#A020F0">if</FONT></B> (k &lt;= num_left)
                    res = find_ksmallest_sum(node-&gt;left, k);
                <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (k == num_left + 1)
                    res = node-&gt;key.first + node-&gt;left-&gt;sum;
                <B><FONT COLOR="#A020F0">else</FONT></B>
                    res = node-&gt;key.first + node-&gt;left-&gt;sum + find_ksmallest_sum(node-&gt;right, k - num_left - 1);
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
};


<I><FONT COLOR="#B22222">////////////////
</FONT></I><I><FONT COLOR="#B22222">//  USAGE
</FONT></I><I><FONT COLOR="#B22222">////////////////
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    srand(time(NULL));
    Treap&lt;PII&gt; tree;
    tree.insert(PII(1, 0));
    tree.insert(PII(5, 0));
    tree.insert(PII(2, 0));
    tree.insert(PII(3, 0));
    tree.insert(PII(10, 0));
    tree.insert(PII(8, 0));
    tree.insert(PII(4, 0));
    tree.insert(PII(7, 0));
    tree.insert(PII(6, 0));
    tree.insert(PII(9, 0));
    tree.display();

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= 11; i++) cout &lt;&lt; tree.find(PII(i, 0)) &lt;&lt; endl;

    cout &lt;&lt; endl;
    
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++) 
        cout &lt;&lt; tree.find_ksmallest(i) &lt;&lt; endl;

    cout &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 10; i++) 
        cout &lt;&lt; tree.find_ksmallest_sum(i) &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file13">
<H1>dp/ConvexHullOptimization.cpp 13/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file12">prev</A>][<A HREF="#file14">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Convex Hull Optimization
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  dp[i] = min(dp[j] + b[j] * a[i]), j &lt; i
</FONT></I><I><FONT COLOR="#B22222">//  y     = min(c     + m    * x)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Requires b[j] &gt;= b[j - 1] (lines are added in decreasing order of slopes
</FONT></I><I><FONT COLOR="#B22222">//  Requires for this implementation: a[i] &lt;= a[i + 1] (query x in increasing order)
</FONT></I><I><FONT COLOR="#B22222">// 
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://codeforces.com/contest/319/problem/C
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T, <B><FONT COLOR="#228B22">int</FONT></B> MAX_SIZE&gt;
<B><FONT COLOR="#228B22">class</FONT></B> ConvexHullOptimization {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> line_st {
        T c, m;
    } Line;
    vector&lt;Line&gt; sk;
    <B><FONT COLOR="#228B22">int</FONT></B> front, rear;
    ConvexHullOptimization () { front = rear = 0; sk.resize(MAX_SIZE); }
    <B><FONT COLOR="#228B22">void</FONT></B> add_line(T m, T c) {
        Line new_line = {c, m};
        <B><FONT COLOR="#A020F0">if</FONT></B> (front &lt; rear &amp;&amp; sk[rear - 1].m == new_line.m) {
            sk[rear - 1].c = min(sk[rear - 1].c, new_line.c);
            <B><FONT COLOR="#A020F0">return</FONT></B> ;
        }
        <B><FONT COLOR="#A020F0">while</FONT></B> (rear - front &gt;= 2 &amp;&amp; cross_left(sk[rear - 2], sk[rear - 1], new_line)) rear--;
        sk[rear++] = new_line;
    }
    <I><FONT COLOR="#B22222">// Returns the minimum value of y
</FONT></I>    T minimize(T x) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (front == rear) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (rear - front &gt;= 2 &amp;&amp; cal_y(sk[front], x) &gt; cal_y(sk[front + 1], x)) front++;
        <B><FONT COLOR="#A020F0">return</FONT></B> cal_y(sk[front], x);
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <I><FONT COLOR="#B22222">// Returns true if x_ab &gt; x_bc
</FONT></I>    <I><FONT COLOR="#B22222">//   x_ab = the x-coordinate of the intersection of A and B
</FONT></I>    <I><FONT COLOR="#B22222">//   x_bc = the x-coordinate of the intersection of B and new_line
</FONT></I>    <B><FONT COLOR="#228B22">bool</FONT></B> cross_left(Line A, Line B, Line new_line) {
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> x_ab = (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>)(B.c - A.c) / (A.m - B.m);
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> x_bc = (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>)(new_line.c - B.c) / (B.m - new_line.m);
        <B><FONT COLOR="#A020F0">return</FONT></B> x_ab &gt; x_bc;
    }
    T cal_y(Line A, T x) {
        <B><FONT COLOR="#A020F0">return</FONT></B> A.m * x + A.c;
    }
};
                              
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXN</FONT> (100005)
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">int</FONT></B> heights[MAXN];
<B><FONT COLOR="#228B22">int</FONT></B> costs[MAXN];
LL dp[MAXN];

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    <B><FONT COLOR="#228B22">int</FONT></B> n;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;n);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++ ) scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;heights[i]);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++ ) scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;costs[i]);
    
    <I><FONT COLOR="#B22222">// dp[i] = min({dp[k] + costs[k] * heights[i]})
</FONT></I>    <I><FONT COLOR="#B22222">// y = dp[i], c = dp[k], m = costs[k], x = heights[i]
</FONT></I>    <I><FONT COLOR="#B22222">// costs is decreasing, heights is increasing
</FONT></I>    ConvexHullOptimization&lt;LL, MAXN&gt; solver;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++ ) {
        dp[i] = solver.minimize(heights[i]);
        solver.add_line(costs[i], dp[i]);
    }
    cout &lt;&lt; dp[n] &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file14">
<H1>geometry/ClosestPair.cpp 14/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file13">prev</A>][<A HREF="#file15">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Closest Pair Example
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://www.spoj.com/problems/CLOPPAIR/
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;


<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (1LL&lt;&lt;62)

<B><FONT COLOR="#228B22">class</FONT></B> ClosestPair {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;LL, LL&gt; Point;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;Point, Point&gt; PPP;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">double</FONT></B>, pair&lt;Point, Point&gt; &gt; PDPP;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;LL, pair&lt;Point, Point&gt; &gt; PLPP;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;LL, LL&gt; PLL;
    vector&lt;Point&gt; all_points;
    <B><FONT COLOR="#228B22">int</FONT></B> N;

    ClosestPair () {
        N = 0;
    }
    
    <B><FONT COLOR="#228B22">void</FONT></B> add_point(Point p) {
        N++; all_points.push_back(p);
    }

    <I><FONT COLOR="#B22222">// Return the closest distance and the pair of the two points
</FONT></I>    PDPP get_closest_pair() {
        assert(N &gt;= 2);
        sort(all_points.begin(), all_points.end());
        PLPP ret = get_closest_pair(0, N - 1);
        <B><FONT COLOR="#A020F0">return</FONT></B> PDPP(sqrt(ret.first), ret.second);
    }

<B><FONT COLOR="#228B22">private</FONT></B>:
    LL dist2(<B><FONT COLOR="#228B22">int</FONT></B> id1, <B><FONT COLOR="#228B22">int</FONT></B> id2) {
        LL dx = all_points[id1].first - all_points[id2].first;
        LL dy = all_points[id1].second - all_points[id2].second;
        <B><FONT COLOR="#A020F0">return</FONT></B> dx * dx + dy * dy;
    }

    PLPP get_closest_pair(<B><FONT COLOR="#228B22">int</FONT></B> left, <B><FONT COLOR="#228B22">int</FONT></B> right) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (left &gt;= right) {
            <B><FONT COLOR="#A020F0">return</FONT></B> PLPP(INF, PPP(Point(0, 0), Point(0, 0)));
        }
        <B><FONT COLOR="#228B22">int</FONT></B> mid = (left + right) / 2;
        PLPP ret_left = get_closest_pair(left, mid);
        PLPP ret_right = get_closest_pair(mid + 1, right);
        LL minn = INF;

        PPP ret;
        <B><FONT COLOR="#A020F0">if</FONT></B> (ret_left.first &lt; minn) {
            minn = ret_left.first;
            ret = ret_left.second;
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (ret_right.first &lt; minn) {
            minn = ret_right.first;
            ret = ret_right.second;
        }
        <B><FONT COLOR="#228B22">double</FONT></B> minn2 = sqrt(minn);
        
        vector&lt;PLL&gt; left_part;
        vector&lt;PLL&gt; right_part;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = left; i &lt;= right; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (i &lt;= mid) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (all_points[mid].first - all_points[i].first &lt;= minn2) {
                    <I><FONT COLOR="#B22222">// ....|.X..|....|....
</FONT></I>                    left_part.push_back(PLL(all_points[i].second, i));
                }
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                <B><FONT COLOR="#A020F0">if</FONT></B> (all_points[i].first - all_points[mid].first &lt;= minn2) {
                    <I><FONT COLOR="#B22222">// ....|....|.X..|...
</FONT></I>                    right_part.push_back(PLL(all_points[i].second, i));
                }
            }
        }

        <I><FONT COLOR="#B22222">// sort by y-coordinates
</FONT></I>        sort(left_part.begin(), left_part.end());
        sort(right_part.begin(), right_part.end());
    
        <B><FONT COLOR="#228B22">int</FONT></B> left_sz = left_part.size();
        <B><FONT COLOR="#228B22">int</FONT></B> right_sz = right_part.size();
        <B><FONT COLOR="#228B22">int</FONT></B> lower = 0, upper = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; left_sz; i++) {
            <B><FONT COLOR="#A020F0">while</FONT></B> (upper &lt; right_sz &amp;&amp; all_points[right_part[upper].second].second - all_points[left_part[i].second].second &lt;= minn2) upper++;
            <B><FONT COLOR="#A020F0">while</FONT></B> (lower &lt; right_sz &amp;&amp; all_points[left_part[i].second].second - all_points[right_part[lower].second].second &gt; minn2) lower++;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = lower; j &lt; upper; j++) {
                LL temp = dist2(left_part[i].second, right_part[j].second);
                <B><FONT COLOR="#A020F0">if</FONT></B> (temp &lt; minn) {
                    minn = temp;
                    ret = PPP(all_points[left_part[i].second], all_points[right_part[j].second]);
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> PLPP(minn, ret);
    }
};
    
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXN</FONT> (50005)
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;LL, LL&gt; Point;

Point in[MAXN];
    
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    cin &gt;&gt; N;
    ClosestPair solver;
    <B><FONT COLOR="#228B22">int</FONT></B> x, y;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;x, &amp;y);
        in[i] = Point(x, y);
        solver.add_point(in[i]);
    }

    pair&lt;<B><FONT COLOR="#228B22">double</FONT></B>, pair&lt;Point, Point&gt; &gt; ret = solver.get_closest_pair();

    <B><FONT COLOR="#228B22">int</FONT></B> ans1, ans2;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (in[i] == ret.second.first) ans1 = i;
        <B><FONT COLOR="#A020F0">if</FONT></B> (in[i] == ret.second.second) ans2 = i;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (ans1 &gt; ans2) swap(ans1, ans2);
    printf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %.6lf\n&quot;</FONT></B>, ans1, ans2, ret.first);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file15">
<H1>geometry/EarthCoordinates.cpp 15/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file14">prev</A>][<A HREF="#file16">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Earth Coordinates
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">latitude_longitude_to_xyz</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> R, <B><FONT COLOR="#228B22">double</FONT></B> lat, <B><FONT COLOR="#228B22">double</FONT></B> lon, <B><FONT COLOR="#228B22">double</FONT></B> &amp;x, <B><FONT COLOR="#228B22">double</FONT></B> &amp;y, <B><FONT COLOR="#228B22">double</FONT></B> &amp;z) {
    x = -R * cos(lat) * cos(lon);
    y = R * sin(lat);
    z = R * cos(lat) * sin(lon);
}

<I><FONT COLOR="#B22222">// Return the distance between the two given points
</FONT></I><I><FONT COLOR="#B22222">// R = Earth's radius
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">cal_dist</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> R, <B><FONT COLOR="#228B22">double</FONT></B> lat1, <B><FONT COLOR="#228B22">double</FONT></B> long1, <B><FONT COLOR="#228B22">double</FONT></B> lat2, <B><FONT COLOR="#228B22">double</FONT></B> long2) {
    <B><FONT COLOR="#228B22">double</FONT></B> xi, yi, zi;
    latitude_longitude_to_xyz(R, lat1 * M_PI / 180.0, long1 * M_PI / 180.0, xi, yi, zi);
    <B><FONT COLOR="#228B22">double</FONT></B> xj, yj, zj;
    latitude_longitude_to_xyz(R, lat2 * M_PI / 180.0, long2 * M_PI / 180.0, xj, yj, zj);

    <B><FONT COLOR="#228B22">double</FONT></B> dot = xi * xj + yi * yj + zi * zj;
    <B><FONT COLOR="#228B22">double</FONT></B> dist_i = sqrt (xi * xi + yi * yi + zi * zi);
    <B><FONT COLOR="#228B22">double</FONT></B> dist_j = sqrt (xj * xj + yj * yj + zj * zj);
    <B><FONT COLOR="#228B22">double</FONT></B> angle = acos(dot / dist_i / dist_j);
    <B><FONT COLOR="#A020F0">return</FONT></B> min(R * angle, R * (2 * M_PI - angle));
}
</PRE>
<HR>
<A NAME="file16">
<H1>geometry/Line.cpp 16/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file15">prev</A>][<A HREF="#file17">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Line
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> Line {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
    LL a, b, c;
    Line() {}
    Line(LL a_, LL b_, LL c_) { init(a_, b_, c_); }
    Line(LL x1, LL y1, LL x2, LL y2) {
        <B><FONT COLOR="#A020F0">if</FONT></B>(x1 &gt; x2 || (x1 == x2 &amp;&amp; y1 &gt; y2)) swap(x1, x2), swap(y1, y2);
        LL A = y2 - y1, B = x1 - x2, C = -A * x1 - B * y1;
        init(A, B, C);
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> == (<B><FONT COLOR="#228B22">const</FONT></B> Line &amp;o) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> a == o.a &amp;&amp; b == o.b &amp;&amp; c == o.c; }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> != (<B><FONT COLOR="#228B22">const</FONT></B> Line &amp;o) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> !(*<B><FONT COLOR="#A020F0">this</FONT></B> == o); }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> &lt; (<B><FONT COLOR="#228B22">const</FONT></B> Line &amp;o) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B>(a != o.a) <B><FONT COLOR="#A020F0">return</FONT></B> a &lt; o.a;
        <B><FONT COLOR="#A020F0">if</FONT></B>(b != o.b) <B><FONT COLOR="#A020F0">return</FONT></B> b &lt; o.b;
        <B><FONT COLOR="#A020F0">return</FONT></B> c &lt; o.c;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> init(LL A, LL B, LL C){
        a = A, b = B, c = C;
        <B><FONT COLOR="#A020F0">if</FONT></B>(a &lt; 0) a = -a, b = -b, c = -c;
        <B><FONT COLOR="#A020F0">if</FONT></B>(a == 0 &amp;&amp; b &lt; 0) b = -b, c = -c;
        reduce();
    }
    <B><FONT COLOR="#228B22">void</FONT></B> reduce(){
        LL g = gcd(labs(a), gcd(labs(b), labs(c)));
        a /= g, b /= g, c /= g;       
    }
    LL gcd(LL x, LL y) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (x == 0 || y == 0) <B><FONT COLOR="#A020F0">return</FONT></B> x + y;
        <B><FONT COLOR="#A020F0">if</FONT></B> (x % y == 0) <B><FONT COLOR="#A020F0">return</FONT></B> y;
        <B><FONT COLOR="#A020F0">return</FONT></B> gcd(y, x % y);
    }
};
</PRE>
<HR>
<A NAME="file17">
<H1>geometry/Util.cpp 17/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file16">prev</A>][<A HREF="#file18">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Geometry
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))

<I><FONT COLOR="#B22222">// -- Adapted from Stanford ACM team notebook --
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> INF = 1e100;
<B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-12;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">struct</FONT></B> Point {
    T x, y;
    Point() {}
    Point(T x_, T y_) : x(x_), y(y_) {}
    Point(<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;p) : x(p.x), y(p.y) {}
    Point <B><FONT COLOR="#A020F0">operator</FONT></B> + (<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;p) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Point(x+p.x, y+p.y); }
    Point <B><FONT COLOR="#A020F0">operator</FONT></B> - (<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;p) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Point(x-p.x, y-p.y); }
    Point <B><FONT COLOR="#A020F0">operator</FONT></B> * (<B><FONT COLOR="#228B22">double</FONT></B> c) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Point(x*c, y*c ); }
    Point <B><FONT COLOR="#A020F0">operator</FONT></B> / (<B><FONT COLOR="#228B22">double</FONT></B> c) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Point(x/c, y/c ); }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> &lt; (<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(y,x) &lt; make_pair(rhs.y,rhs.x); }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> == (<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(y,x) == make_pair(rhs.y,rhs.x); }
};

T cross(Point p, Point q) { <B><FONT COLOR="#A020F0">return</FONT></B> p.x*q.y-p.y*q.x; }
T area2(Point a, Point b, Point c) { <B><FONT COLOR="#A020F0">return</FONT></B> cross(a,b) + cross(b,c) + cross(c,a); }
T dot(Point p, Point q) { <B><FONT COLOR="#A020F0">return</FONT></B> p.x*q.x+p.y*q.y; }
T dist2(Point p, Point q) { <B><FONT COLOR="#A020F0">return</FONT></B> dot(p-q,p-q); }

ostream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(ostream &amp;os, <B><FONT COLOR="#228B22">const</FONT></B> Point &amp;p) {
    <B><FONT COLOR="#A020F0">return</FONT></B> os &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> &lt;&lt; p.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B> &lt;&lt; p.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;
}
<I><FONT COLOR="#B22222">// rotate a point CCW or CW around the origin
</FONT></I>Point <B><FONT COLOR="#0000FF">RotateCCW90</FONT></B>(Point p) { <B><FONT COLOR="#A020F0">return</FONT></B> Point(-p.y,p.x); }
Point <B><FONT COLOR="#0000FF">RotateCW90</FONT></B>(Point p) { <B><FONT COLOR="#A020F0">return</FONT></B> Point(p.y,-p.x); }

Point <B><FONT COLOR="#0000FF">RotateCCW</FONT></B>(Point p, <B><FONT COLOR="#228B22">double</FONT></B> t) { <B><FONT COLOR="#A020F0">return</FONT></B> Point(p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)); }


<I><FONT COLOR="#B22222">////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  ConvexHull
</FONT></I><I><FONT COLOR="#B22222">////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">// Compute the 2D convex hull of a set of points using the monotone chain
</FONT></I><I><FONT COLOR="#B22222">// algorithm. Eliminate redundant points from the hull if REMOVE_REDUNDANT is
</FONT></I><I><FONT COLOR="#B22222">// #defined.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n log n)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: a vector of input points, unordered.
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT: a vector of points in the convex hull, counterclockwise, starting
</FONT></I><I><FONT COLOR="#B22222">// with bottommost/leftmost point
</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">between</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> Point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> Point &amp;b, <B><FONT COLOR="#228B22">const</FONT></B> Point &amp;c) {
    <B><FONT COLOR="#A020F0">return</FONT></B> (fabs(area2(a,b,c)) &lt; EPS &amp;&amp; (a.x-b.x)*(c.x-b.x) &lt;= 0 &amp;&amp; 
            (a.y-b.y)*(c.y-b.y) &lt;= 0);
}
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">ConvexHull</FONT></B>(vector&lt;Point&gt; &amp;pts) {
    sort(pts.begin(), pts.end());
    pts.erase(unique(pts.begin(), pts.end()), pts.end());
    vector&lt;Point&gt; up, dn;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; pts.size(); i++) {
        <B><FONT COLOR="#A020F0">while</FONT></B> (up.size() &gt; 1 &amp;&amp; area2(up[up.size()-2], up.back(), pts[i]) &gt;= 0) <I><FONT COLOR="#B22222">// concave down
</FONT></I>            up.pop_back();
        <B><FONT COLOR="#A020F0">while</FONT></B> (dn.size() &gt; 1 &amp;&amp; area2(dn[dn.size()-2], dn.back(), pts[i]) &lt;= 0) <I><FONT COLOR="#B22222">// concave up
</FONT></I>            dn.pop_back();
        up.push_back(pts[i]);
		dn.push_back(pts[i]);
    }
    pts = dn;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = (<B><FONT COLOR="#228B22">int</FONT></B>) up.size() - 2; i &gt;= 1; i--) pts.push_back(up[i]);
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>
    <B><FONT COLOR="#A020F0">if</FONT></B> (pts.size() &lt;= 2) <B><FONT COLOR="#A020F0">return</FONT></B>;
    dn.clear();
    dn.push_back(pts[0]);
    dn.push_back(pts[1]);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i &lt; pts.size(); i++){
        <B><FONT COLOR="#A020F0">if</FONT></B> (between(dn[dn.size()-2], dn[dn.size()-1], pts[i])) dn.pop_back();
		dn.push_back(pts[i]);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (dn.size() &gt;= 3 &amp;&amp; between(dn.back(), dn[0], dn[1])) {
        dn[0] = dn.back();
        dn.pop_back();
    }
    pts = dn;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
}

<I><FONT COLOR="#B22222">// project point c onto line through a and b
</FONT></I><I><FONT COLOR="#B22222">// assuming a != b
</FONT></I>Point <B><FONT COLOR="#0000FF">ProjectPointLine</FONT></B>(Point a, Point b, Point c) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);
}

<I><FONT COLOR="#B22222">// project point c onto line segment through a and b
</FONT></I>Point <B><FONT COLOR="#0000FF">ProjectPointSegment</FONT></B>(Point a, Point b, Point c) {
    <B><FONT COLOR="#228B22">double</FONT></B> r = dot(b-a,b-a);
    <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(r) &lt; EPS) <B><FONT COLOR="#A020F0">return</FONT></B> a;
    r = dot(c-a, b-a)/r;
    <B><FONT COLOR="#A020F0">if</FONT></B> (r &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> a;
    <B><FONT COLOR="#A020F0">if</FONT></B> (r &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> b;
    <B><FONT COLOR="#A020F0">return</FONT></B> a + (b-a)*r;
}

<I><FONT COLOR="#B22222">// compute distance from c to segment between a and b
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointSegment</FONT></B>(Point a, Point b, Point c) {
    <B><FONT COLOR="#A020F0">return</FONT></B> sqrt(dist2(c, ProjectPointSegment(a, b, c)));
}

<I><FONT COLOR="#B22222">// compute distance between point (x,y,z) and plane ax+by+cz=d
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointPlane</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y, <B><FONT COLOR="#228B22">double</FONT></B> z,
                          <B><FONT COLOR="#228B22">double</FONT></B> a, <B><FONT COLOR="#228B22">double</FONT></B> b, <B><FONT COLOR="#228B22">double</FONT></B> c, <B><FONT COLOR="#228B22">double</FONT></B> d){
    <B><FONT COLOR="#A020F0">return</FONT></B> fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);
}

<I><FONT COLOR="#B22222">// determine if lines from a to b and c to d are parallel or collinear
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesParallel</FONT></B>(Point a, Point b, Point c, Point d) {
    <B><FONT COLOR="#A020F0">return</FONT></B> fabs(cross(b-a, c-d)) &lt; EPS;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesCollinear</FONT></B>(Point a, Point b, Point c, Point d) {
    <B><FONT COLOR="#A020F0">return</FONT></B> LinesParallel(a, b, c, d) &amp;&amp; fabs(cross(a-b, a-c)) &lt; EPS &amp;&amp; 
        fabs(cross(c-d, c-a)) &lt; EPS;
}

<I><FONT COLOR="#B22222">// determine if line segment from a to b intersects with
</FONT></I><I><FONT COLOR="#B22222">// line segment from c to d
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">SegmentsIntersect</FONT></B>(Point a, Point b, Point c, Point d) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (LinesCollinear(a, b, c, d)) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(a, c) &lt; EPS || dist2(a, d) &lt; EPS || 
            dist2(b, c) &lt; EPS || dist2(b, d) &lt; EPS) 
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
        <B><FONT COLOR="#A020F0">if</FONT></B> (dot(c-a, c-b) &gt; 0 &amp;&amp; dot(d-a, d-b) &gt; 0 &amp;&amp; dot(c-b, d-b) &gt; 0)
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (cross(d-a, b-a) * cross(c-a, b-a) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B> (cross(a-c, d-c) * cross(b-c, d-c) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">// compute intersection of line passing through a and b
</FONT></I><I><FONT COLOR="#B22222">// with line passing through c and d, assuming that unique
</FONT></I><I><FONT COLOR="#B22222">// intersection exists; for segment intersection, check if
</FONT></I><I><FONT COLOR="#B22222">// segments intersect first
</FONT></I>Point <B><FONT COLOR="#0000FF">ComputeLineIntersection</FONT></B>(Point a, Point b, Point c, Point d) {
    b=b-a; d=c-d; c=c-a;
    assert(dot(b, b) &gt; EPS &amp;&amp; dot(d, d) &gt; EPS);
    <B><FONT COLOR="#A020F0">return</FONT></B> a + b*cross(c, d)/cross(b, d);
}

<I><FONT COLOR="#B22222">// compute center of circle given three points
</FONT></I>Point <B><FONT COLOR="#0000FF">ComputeCircleCenter</FONT></B>(Point a, Point b, Point c) {
    b=(a+b)/2;
    c=(a+c)/2;
    <B><FONT COLOR="#A020F0">return</FONT></B> ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));
}

<I><FONT COLOR="#B22222">// determine if point is in a possibly non-convex polygon (by William
</FONT></I><I><FONT COLOR="#B22222">// Randolph Franklin); returns 1 for strictly interior points, 0 for
</FONT></I><I><FONT COLOR="#B22222">// strictly exterior points, and 0 or 1 for the remaining points.
</FONT></I><I><FONT COLOR="#B22222">// Note that it is possible to convert this into an *exact* test using
</FONT></I><I><FONT COLOR="#B22222">// integer arithmetic by taking care of the division appropriately
</FONT></I><I><FONT COLOR="#B22222">// (making sure to deal with signs properly) and then by writing exact
</FONT></I><I><FONT COLOR="#B22222">// tests for checking point on polygon boundary
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointInPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p, Point q) {
    <B><FONT COLOR="#228B22">bool</FONT></B> c = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++){
        <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1)%p.size();
        <B><FONT COLOR="#A020F0">if</FONT></B> ((p[i].y &lt;= q.y &amp;&amp; q.y &lt; p[j].y || p[j].y &lt;= q.y &amp;&amp; q.y &lt; p[i].y) &amp;&amp;	
            q.x &lt; p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))
            c = !c;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> c;
}

<I><FONT COLOR="#B22222">// determine if point is on the boundary of a polygon
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointOnPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p, Point q) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++)
        <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(ProjectPointSegment(p[i], p[(i+1)%p.size()], q), q) &lt; EPS)
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<I><FONT COLOR="#B22222">// compute intersection of line through points a and b with
</FONT></I><I><FONT COLOR="#B22222">// circle centered at c with radius r &gt; 0
</FONT></I>vector&lt;Point&gt; CircleLineIntersection(Point a, Point b, Point c, <B><FONT COLOR="#228B22">double</FONT></B> r) {
    vector&lt;Point&gt; ret;
    b = b-a;
    a = a-c;
    <B><FONT COLOR="#228B22">double</FONT></B> A = dot(b, b);
    <B><FONT COLOR="#228B22">double</FONT></B> B = dot(a, b);
    <B><FONT COLOR="#228B22">double</FONT></B> C = dot(a, a) - r*r;
    <B><FONT COLOR="#228B22">double</FONT></B> D = B*B - A*C;
    <B><FONT COLOR="#A020F0">if</FONT></B> (D &lt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);
    <B><FONT COLOR="#A020F0">if</FONT></B> (D &gt; EPS)
	ret.push_back(c+a+b*(-B-sqrt(D))/A);
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// compute intersection of circle centered at a with radius r
</FONT></I><I><FONT COLOR="#B22222">// with circle centered at b with radius R
</FONT></I>vector&lt;Point&gt; CircleCircleIntersection(Point a, Point b, <B><FONT COLOR="#228B22">double</FONT></B> r, <B><FONT COLOR="#228B22">double</FONT></B> R) {
    vector&lt;Point&gt; ret;
    <B><FONT COLOR="#228B22">double</FONT></B> d = sqrt(dist2(a, b));
    <B><FONT COLOR="#A020F0">if</FONT></B> (d &gt; r+R || d+min(r, R) &lt; max(r, R)) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    <B><FONT COLOR="#228B22">double</FONT></B> x = (d*d-R*R+r*r)/(2*d);
    <B><FONT COLOR="#228B22">double</FONT></B> y = sqrt(r*r-x*x);
    Point v = (b-a)/d;
    ret.push_back(a+v*x + RotateCCW90(v)*y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (y &gt; 0)
        ret.push_back(a+v*x - RotateCCW90(v)*y);
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// This code computes the area or centroid of a (possibly nonconvex)
</FONT></I><I><FONT COLOR="#B22222">// polygon, assuming that the coordinates are listed in a clockwise or
</FONT></I><I><FONT COLOR="#B22222">// counterclockwise fashion. Note that the centroid is often known as
</FONT></I><I><FONT COLOR="#B22222">// the &quot;center of gravity&quot; or &quot;center of mass&quot;.
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeSignedArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p) {
    <B><FONT COLOR="#228B22">double</FONT></B> area = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
        area += p[i].x*p[j].y - p[j].x*p[i].y;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> area / 2.0;
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p) {
    <B><FONT COLOR="#A020F0">return</FONT></B> fabs(ComputeSignedArea(p));
}

Point <B><FONT COLOR="#0000FF">ComputeCentroid</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p) {
    Point c(0,0);
    <B><FONT COLOR="#228B22">double</FONT></B> scale = 6.0 * ComputeSignedArea(p);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++){
        <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
        c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> c / scale;
}

<I><FONT COLOR="#B22222">// tests whether or not a given polygon (in CW or CCW order) is simple
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">IsSimple</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;Point&gt; &amp;p) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = i+1; k &lt; p.size(); k++) {
            <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
            <B><FONT COLOR="#228B22">int</FONT></B> l = (k+1) % p.size();
            <B><FONT COLOR="#A020F0">if</FONT></B> (i == l || j == k) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (SegmentsIntersect(p[i], p[j], p[k], p[l]))
                <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
	<I><FONT COLOR="#B22222">// expected: (-5,2)
</FONT></I>	cerr &lt;&lt; RotateCCW90(Point(2,5)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (5,-2)
</FONT></I>	cerr &lt;&lt; RotateCW90(Point(2,5)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (-5,2)
</FONT></I>	cerr &lt;&lt; RotateCCW(Point(2,5),M_PI/2) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (5,2)
</FONT></I>	cerr &lt;&lt; ProjectPointLine(Point(-5,-2), Point(10,4), Point(3,7)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (5,2) (7.5,3) (2.5,1)
</FONT></I>	cerr &lt;&lt; ProjectPointSegment(Point(-5,-2), Point(10,4), Point(3,7)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; ProjectPointSegment(Point(7.5,3), Point(10,4), Point(3,7)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; ProjectPointSegment(Point(-5,-2), Point(2.5,1), Point(3,7)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: 6.78903
</FONT></I>	cerr &lt;&lt; DistancePointPlane(4,-4,3,2,-2,5,-8) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: 1 0 1
</FONT></I>	cerr &lt;&lt; LinesParallel(Point(1,1), Point(3,5), Point(2,1), Point(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; LinesParallel(Point(1,1), Point(3,5), Point(2,0), Point(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; LinesParallel(Point(1,1), Point(3,5), Point(5,9), Point(7,13)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: 0 0 1
</FONT></I>	cerr &lt;&lt; LinesCollinear(Point(1,1), Point(3,5), Point(2,1), Point(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; LinesCollinear(Point(1,1), Point(3,5), Point(2,0), Point(4,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; LinesCollinear(Point(1,1), Point(3,5), Point(5,9), Point(7,13)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: 1 1 1 0
</FONT></I>	cerr &lt;&lt; SegmentsIntersect(Point(0,0), Point(2,4), Point(3,1), Point(-1,3)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; SegmentsIntersect(Point(0,0), Point(2,4), Point(4,3), Point(0,5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; SegmentsIntersect(Point(0,0), Point(2,4), Point(2,-1), Point(-2,1)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; SegmentsIntersect(Point(0,0), Point(2,4), Point(5,5), Point(1,7)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (1,2)
</FONT></I>	cerr &lt;&lt; ComputeLineIntersection(Point(0,0), Point(2,4), Point(3,1), Point(-1,3)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (1,1)
</FONT></I>	cerr &lt;&lt; ComputeCircleCenter(Point(-3,4), Point(6,1), Point(4,5)) &lt;&lt; endl;
	vector&lt;Point&gt; v;
	v.push_back(Point(0,0));
	v.push_back(Point(5,0));
	v.push_back(Point(5,5));
	v.push_back(Point(0,5));
	<I><FONT COLOR="#B22222">// expected: 1 1 1 0 0
</FONT></I>	cerr &lt;&lt; PointInPolygon(v, Point(2,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointInPolygon(v, Point(2,0)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointInPolygon(v, Point(0,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointInPolygon(v, Point(5,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointInPolygon(v, Point(2,5)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: 0 1 1 1 1
</FONT></I>	cerr &lt;&lt; PointOnPolygon(v, Point(2,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointOnPolygon(v, Point(2,0)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointOnPolygon(v, Point(0,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointOnPolygon(v, Point(5,2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
	&lt;&lt; PointOnPolygon(v, Point(2,5)) &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// expected: (1,6)
</FONT></I>	<I><FONT COLOR="#B22222">// (5,4) (4,5)
</FONT></I>	<I><FONT COLOR="#B22222">// blank line
</FONT></I>	<I><FONT COLOR="#B22222">// (4,5) (5,4)
</FONT></I>	<I><FONT COLOR="#B22222">// blank line
</FONT></I>	<I><FONT COLOR="#B22222">// (4,5) (5,4)
</FONT></I>	vector&lt;Point&gt; u = CircleLineIntersection(Point(0,6), Point(2,6), Point(1,1), 5);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	u = CircleLineIntersection(Point(0,9), Point(9,0), Point(1,1), 5);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	u = CircleCircleIntersection(Point(1,1), Point(10,10), 5, 5);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	u = CircleCircleIntersection(Point(1,1), Point(8,8), 5, 5);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	u = CircleCircleIntersection(Point(1,1), Point(4.5,4.5), 10, sqrt(2.0)/2.0);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	u = CircleCircleIntersection(Point(1,1), Point(4.5,4.5), 5, sqrt(2.0)/2.0);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; cerr &lt;&lt; endl;
	<I><FONT COLOR="#B22222">// area should be 5.0
</FONT></I>	<I><FONT COLOR="#B22222">// centroid should be (1.1666666, 1.166666)
</FONT></I>	Point pa[] = { Point(0,0), Point(5,0), Point(1,1), Point(0,5) };
	vector&lt;Point&gt; p(pa, pa+4);
	Point c = ComputeCentroid(p);
	cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Area: &quot;</FONT></B> &lt;&lt; ComputeArea(p) &lt;&lt; endl;
	cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Centroid: &quot;</FONT></B> &lt;&lt; c &lt;&lt; endl;
	<B><FONT COLOR="#A020F0">return</FONT></B> 0;
}


<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Pick’s Theorem
</FONT></I><I><FONT COLOR="#B22222">//  On a simple polygon constructed on a grid of equal-distanced points,
</FONT></I><I><FONT COLOR="#B22222">//  for area A, the number of interior points I, number of boundary points B,
</FONT></I><I><FONT COLOR="#B22222">//  we have A = I + B / 2 - 1.
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">// Returns true if Rec(a, b) can fit in Rec(c, d)
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">can_ab_fit_in_cd</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> a, <B><FONT COLOR="#228B22">double</FONT></B> b, <B><FONT COLOR="#228B22">double</FONT></B> c, <B><FONT COLOR="#228B22">double</FONT></B> d){
	<B><FONT COLOR="#A020F0">if</FONT></B>(a * b &gt; c * d) <B><FONT COLOR="#A020F0">return</FONT></B> false;
	<B><FONT COLOR="#A020F0">if</FONT></B>(a &gt; b) swap(a, b);
	<B><FONT COLOR="#A020F0">if</FONT></B>(c &gt; d) swap(c, d);
	<B><FONT COLOR="#A020F0">if</FONT></B>(a &gt; c) <B><FONT COLOR="#A020F0">return</FONT></B> false;
	<B><FONT COLOR="#A020F0">if</FONT></B>(a &lt;= c &amp;&amp; b &lt;= d) <B><FONT COLOR="#A020F0">return</FONT></B> true;
	<B><FONT COLOR="#228B22">double</FONT></B> dis = sqrt(a * a + b * b);
	<B><FONT COLOR="#228B22">double</FONT></B> P = asin(c / dis);
	<B><FONT COLOR="#228B22">double</FONT></B> Q = asin(a / dis);
	<B><FONT COLOR="#228B22">double</FONT></B> theta = P - Q;
	<B><FONT COLOR="#228B22">double</FONT></B> dd = b * cos(theta) + a * sin(theta);
	<B><FONT COLOR="#A020F0">return</FONT></B> dd &lt;= d;
}

</PRE>
<HR>
<A NAME="file18">
<H1>graph/BiconnectedComponent.cpp 18/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file17">prev</A>][<A HREF="#file19">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Biconnected Component, Articulation points, Bridges
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3785
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> BiconnectedComponent {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N, M;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; adj;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; bicomponents; <I><FONT COLOR="#B22222">// biconnected component
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; bridges; <I><FONT COLOR="#B22222">// component whose all pairs are connected by exactly one simple path
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; dfs_numbers;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; low_numbers;
    vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; is_articulation_point;
    <B><FONT COLOR="#228B22">int</FONT></B> dfs_number;
    
    <I><FONT COLOR="#B22222">// Vertices are 1-based
</FONT></I>    BiconnectedComponent(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) {
        M = 0; adj.resize(N + 1); bicomponents.resize(N + 1); bridges.resize(N + 1);
        dfs_numbers.resize(N + 1); low_numbers.resize(N + 1);
        is_articulation_point.resize(N + 1); dfs_number = 0;
    }

    <B><FONT COLOR="#228B22">int</FONT></B> find_bicomponent(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> find_component(bicomponents, x); }
    <B><FONT COLOR="#228B22">int</FONT></B> find_bridge(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> find_component(bridges, x); }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { adj[u].push_back(v); }
    <B><FONT COLOR="#228B22">void</FONT></B> cal_components() {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) { bicomponents[i] = i; bridges[i] = i; }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (dfs_numbers[i] == 0) cal_components(i, -1);
        }
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> is_articulation(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> is_articulation_point[x]; }

<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> find_component(vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;com, <B><FONT COLOR="#228B22">int</FONT></B> x) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (com[x] == x) <B><FONT COLOR="#A020F0">return</FONT></B> x;
        <B><FONT COLOR="#A020F0">return</FONT></B> com[x] = find_component(com, com[x]);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> union_set(vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;com, <B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y) {
        <B><FONT COLOR="#228B22">int</FONT></B> a = find_component(com, x);
        <B><FONT COLOR="#228B22">int</FONT></B> b = find_component(com, y);
        com[a] = b;
    }

    <B><FONT COLOR="#228B22">void</FONT></B> cal_components(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> parent) {
        dfs_numbers[at] = low_numbers[at] = ++dfs_number;
        <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[at].size();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = adj[at][i];
            <B><FONT COLOR="#A020F0">if</FONT></B> (!dfs_numbers[v]) {
                cal_components(v, at);
                low_numbers[at] = min(low_numbers[at], low_numbers[v]);
                <B><FONT COLOR="#A020F0">if</FONT></B> (low_numbers[v] &gt; dfs_numbers[at]) {
                    <I><FONT COLOR="#B22222">// at is an articulation point separating v
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (at &gt; 1) is_articulation_point[at] = true;
                    union_set(bridges, v, at);
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    union_set(bicomponents, v, at);
                }
            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (v != parent) {
                low_numbers[at] = min(low_numbers[at], dfs_numbers[v]);
            }
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#A020F0">while</FONT></B> (1) {
        <B><FONT COLOR="#228B22">int</FONT></B> N, M, Q;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %d&quot;</FONT></B>, &amp;N, &amp;M, &amp;Q);
        <B><FONT COLOR="#A020F0">if</FONT></B> (N + M + Q == 0) <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        BiconnectedComponent solver(N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;u, &amp;v);
            solver.add_edge(u, v);
            solver.add_edge(v, u);
        }
        
        solver.cal_components();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; Q; q++) {
            <B><FONT COLOR="#228B22">int</FONT></B> start, finish;
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;start, &amp;finish);
            <B><FONT COLOR="#228B22">int</FONT></B> a = solver.find_bridge(start);
            <B><FONT COLOR="#228B22">int</FONT></B> b = solver.find_bridge(finish);
            <B><FONT COLOR="#A020F0">if</FONT></B> (a == b) printf(<B><FONT COLOR="#BC8F8F">&quot;Y\n&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">else</FONT></B> printf(<B><FONT COLOR="#BC8F8F">&quot;N\n&quot;</FONT></B>);
        }
        printf(<B><FONT COLOR="#BC8F8F">&quot;-\n&quot;</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file19">
<H1>graph/Dinic.cpp 19/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file18">prev</A>][<A HREF="#file20">next</A>]
<PRE>

<I><FONT COLOR="#B22222">////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Dinic algorithm
</FONT></I><I><FONT COLOR="#B22222">////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">// Adjacency list implementation of Dinic's blocking flow algorithm.
</FONT></I><I><FONT COLOR="#B22222">// This is very fast in practice, and only loses to push-relabel flow.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time:
</FONT></I><I><FONT COLOR="#B22222">//     O(|V|^2 |E|)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//     - source
</FONT></I><I><FONT COLOR="#B22222">//     - sink
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - maximum flow value
</FONT></I><I><FONT COLOR="#B22222">//     - To obtain the actual flow values, look at all edges with
</FONT></I><I><FONT COLOR="#B22222">//       capacity &gt; 0 (zero capacity edges are residual edges).
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> inf_flow = 2000000000;
<B><FONT COLOR="#228B22">class</FONT></B> Dinic {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">struct</FONT></B> Edge {
        <B><FONT COLOR="#228B22">int</FONT></B> from, to, cap, flow, index;
        Edge(<B><FONT COLOR="#228B22">int</FONT></B> from_, <B><FONT COLOR="#228B22">int</FONT></B> to_, <B><FONT COLOR="#228B22">int</FONT></B> cap_, <B><FONT COLOR="#228B22">int</FONT></B> flow_, <B><FONT COLOR="#228B22">int</FONT></B> index_) :
            from(from_), to(to_), cap(cap_), flow(flow_), index(index_) {}
    };

    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;vector&lt;Edge&gt; &gt; G;
    vector&lt;Edge *&gt; dad;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; Q;
  
    Dinic(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n), G(n), dad(n), Q(n) {}
  
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to, <B><FONT COLOR="#228B22">int</FONT></B> cap) {
        G[from].push_back(Edge(from, to, cap, 0, G[to].size()));
        <B><FONT COLOR="#A020F0">if</FONT></B> (from == to) G[from].back().index++;
        G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));
    }

    <B><FONT COLOR="#228B22">void</FONT></B> reset_flow() {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> sz = G[i].size();
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz; j++) {
                G[i][j].flow = 0;
            }
        }
    }
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> get_maxflow(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> totflow = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> flow = blocking_flow(s, t))
            totflow += flow;
        <B><FONT COLOR="#A020F0">return</FONT></B> totflow;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> blocking_flow(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
        fill(dad.begin(), dad.end(), (Edge *) NULL);
        dad[s] = &amp;G[0][0] - 1;
    
        <B><FONT COLOR="#228B22">int</FONT></B> head = 0, tail = 0;
        Q[tail++] = s;
        <B><FONT COLOR="#A020F0">while</FONT></B> (head &lt; tail) {
            <B><FONT COLOR="#228B22">int</FONT></B> x = Q[head++];
            <B><FONT COLOR="#228B22">int</FONT></B> sz = G[x].size();
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
                Edge &amp;e = G[x][i];
                <B><FONT COLOR="#A020F0">if</FONT></B> (!dad[e.to] &amp;&amp; e.cap - e.flow &gt; 0) {
                    dad[e.to] = &amp;G[x][i];
                    Q[tail++] = e.to;
                }
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (!dad[t]) <B><FONT COLOR="#A020F0">return</FONT></B> 0;

        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> totflow = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> sz = G[t].size();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
            Edge *start = &amp;G[G[t][i].to][G[t][i].index];
            <B><FONT COLOR="#228B22">int</FONT></B> amt = inf_flow;
            <B><FONT COLOR="#A020F0">for</FONT></B> (Edge *e = start; amt &amp;&amp; e != dad[s]; e = dad[e-&gt;from]) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (!e) { amt = 0; <B><FONT COLOR="#A020F0">break</FONT></B>; }
                amt = min(amt, e-&gt;cap - e-&gt;flow);
            }
            <B><FONT COLOR="#A020F0">if</FONT></B> (amt == 0) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            <B><FONT COLOR="#A020F0">for</FONT></B> (Edge *e = start; amt &amp;&amp; e != dad[s]; e = dad[e-&gt;from]) {
                e-&gt;flow += amt;
                G[e-&gt;to][e-&gt;index].flow -= amt;
            }
            totflow += amt;
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> totflow;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    Dinic mf(3);
    mf.add_edge(0, 1, 2);
    mf.add_edge(1, 2, 2);
    assert(mf.get_maxflow(0, 2) == 2);

    mf = Dinic(4);
    mf.add_edge(0, 1, 2);
    mf.add_edge(0, 2, 2);
    mf.add_edge(1, 3, 1);
    mf.add_edge(1, 2, 1);
    mf.add_edge(2, 3, 2);
    assert(mf.get_maxflow(0, 3) == 3);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file20">
<H1>graph/EulerCircuit.cpp 20/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file19">prev</A>][<A HREF="#file21">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Euler Circuit (undirected graph)
</FONT></I><I><FONT COLOR="#B22222">//  Considering the number of odd-degree nodes
</FONT></I><I><FONT COLOR="#B22222">//     if 0, there is an euler circuit
</FONT></I><I><FONT COLOR="#B22222">//        2, there is an euler path
</FONT></I><I><FONT COLOR="#B22222">//     otherwise, neither of them exists
</FONT></I><I><FONT COLOR="#B22222">//  To find an euler path
</FONT></I><I><FONT COLOR="#B22222">//     - Add one edge between the two odd-degree nodes,
</FONT></I><I><FONT COLOR="#B22222">//     - Find an euler circuit and then remove that edge later
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Implementation of Euler Circuit
</FONT></I><I><FONT COLOR="#B22222">//    procedure FindEuler (u)
</FONT></I><I><FONT COLOR="#B22222">//      Iterate over all edges (u, v):
</FONT></I><I><FONT COLOR="#B22222">//        remove edge(u, v) from the graph
</FONT></I><I><FONT COLOR="#B22222">//        FindEuler(v)
</FONT></I><I><FONT COLOR="#B22222">//      add vertex u in the result
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://www.spoj.com/KSTN/problems/EULER/
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stack&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> EulerCircuit {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII; <I><FONT COLOR="#B22222">// (v, id)
</FONT></I>    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;vector&lt;PII&gt; &gt; VVP;
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> edge_st {
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        edge_st () {}
        edge_st(<B><FONT COLOR="#228B22">int</FONT></B> u_, <B><FONT COLOR="#228B22">int</FONT></B> v_) : u(u_), v(v_) {}
    } Edge;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;Edge&gt; edges;
    VI deg; <I><FONT COLOR="#B22222">// need to run get_euler_circuit first
</FONT></I>    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>    EulerCircuit() { N = 0; }
    EulerCircuit(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) {}
    <I><FONT COLOR="#B22222">// Add an edge between u and v
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { edges.push_back(Edge(u, v)); }
    <I><FONT COLOR="#B22222">// Return an empty list if no an euler circuit
</FONT></I>    VI get_euler_circuit(<B><FONT COLOR="#228B22">int</FONT></B> start) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (N &lt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> VI();
        <B><FONT COLOR="#228B22">int</FONT></B> M = edges.size(); VVP adj (N); VI empty_ret, ret;
        <B><FONT COLOR="#A020F0">if</FONT></B> (M == 0) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (N &gt; 1) { <B><FONT COLOR="#A020F0">return</FONT></B> empty_ret; } <B><FONT COLOR="#A020F0">else</FONT></B> { ret.push_back(0); <B><FONT COLOR="#A020F0">return</FONT></B> ret; }
        }
        vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; removed (M);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
            adj[edges[i].u].push_back(PII(edges[i].v, i));
            adj[edges[i].v].push_back(PII(edges[i].u, i));
        }
        deg = VI (N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) { <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[i].size();
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz; j++) {
                deg[adj[i][j].first]++;
            }
        }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) { <B><FONT COLOR="#A020F0">if</FONT></B> (deg[i] % 2) <B><FONT COLOR="#A020F0">return</FONT></B> empty_ret; }
        stack&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; st; VI cur_pt(N);
        st.push(start);
        <B><FONT COLOR="#A020F0">while</FONT></B> (!st.empty()) {
            <B><FONT COLOR="#228B22">int</FONT></B> u = st.top(), v = -1, id = 0;
            <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[u].size();
            <B><FONT COLOR="#A020F0">while</FONT></B> (cur_pt[u] &lt; sz &amp;&amp; v == -1) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (!removed[adj[u][cur_pt[u]].second]) {
                    v = adj[u][cur_pt[u]].first;
                    id = adj[u][cur_pt[u]].second;
                }
                cur_pt[u]++;
            }

            <B><FONT COLOR="#A020F0">if</FONT></B> (v == -1) { ret.push_back(u); st.pop(); }
            <B><FONT COLOR="#A020F0">else</FONT></B> { removed[id] = true; st.push(v); }
        }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) { <B><FONT COLOR="#A020F0">if</FONT></B> (!removed[i]) <B><FONT COLOR="#A020F0">return</FONT></B> empty_ret; }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N, M;
    <B><FONT COLOR="#228B22">int</FONT></B> u, v;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;N, &amp;M);
    EulerCircuit solver(N);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;u, &amp;v);
        u--, v--;
        solver.add_edge(u, v);
    }
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; res = solver.get_euler_circuit(0);
    <B><FONT COLOR="#228B22">int</FONT></B> sz = res.size();

    <B><FONT COLOR="#A020F0">if</FONT></B> (sz) {
        <I><FONT COLOR="#B22222">// Print an euler curcuit
</FONT></I>        printf(<B><FONT COLOR="#BC8F8F">&quot;1&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; sz; i++) {
            printf(<B><FONT COLOR="#BC8F8F">&quot; %d&quot;</FONT></B>, res[i] + 1);
        }
        printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#228B22">bool</FONT></B> bad = false;
        u = -1, v = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (solver.deg[i] % 2) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (u == -1) u = i;
                <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (v == -1) v = i;
                <B><FONT COLOR="#A020F0">else</FONT></B> bad = true; <I><FONT COLOR="#B22222">// No euler path as well.
</FONT></I>            }
        }

        <B><FONT COLOR="#A020F0">if</FONT></B> (bad) {
            <I><FONT COLOR="#B22222">// Neither euler path nor euler curcuit exists.
</FONT></I>        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <I><FONT COLOR="#B22222">// Print euler path.
</FONT></I>            solver.add_edge(u, v);
            res = solver.get_euler_circuit(0);
            sz = res.size();
            sz--;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
                <B><FONT COLOR="#228B22">int</FONT></B> a = res[i];
                <B><FONT COLOR="#228B22">int</FONT></B> b = res[(i + 1) % sz];
                <B><FONT COLOR="#A020F0">if</FONT></B> ((a == u &amp;&amp; b == v) || (a == v &amp;&amp; b == u)) {
                    printf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, b + 1);
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz - 1; j++) {
                        printf(<B><FONT COLOR="#BC8F8F">&quot; %d&quot;</FONT></B>, res[(i + j + 2) % sz] + 1);
                    }
                    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
                    <B><FONT COLOR="#A020F0">break</FONT></B>;
                }
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">/* tests
int main() {
    EulerCircuit solver;
    assert(solver.get_euler_circuit(0).size() == 0);
    solver = EulerCircuit(2);
    solver.add_edge(0, 1);
    assert(solver.get_euler_circuit(0).size() == 0);
    solver = EulerCircuit(1);
    assert(solver.get_euler_circuit(0).size() == 1);
    solver.add_edge(0, 0);
    solver.add_edge(0, 0);
    vector&lt;int&gt; res = solver.get_euler_circuit(0);
    assert(res.size() &gt; 0);
    for (int i = 0; i &lt; (int)res.size(); i++) printf(&quot;%d &quot;, res[i]); printf(&quot;\n&quot;);
    solver = EulerCircuit(6);
    solver.add_edge(0, 1);
    solver.add_edge(0, 2);
    solver.add_edge(2, 1);
    solver.add_edge(0, 3);
    solver.add_edge(3, 4);
    solver.add_edge(4, 5);
    solver.add_edge(5, 3);
    assert(solver.get_euler_circuit(0).size() == 0);
    solver.add_edge(0, 3);
    res = solver.get_euler_circuit(0);
    assert(res.size() &gt; 0);
    for (int i = 0; i &lt; (int)res.size(); i++) printf(&quot;%d &quot;, res[i]); printf(&quot;\n&quot;);
    res = solver.get_euler_circuit(1);
    assert(res.size() &gt; 0);
    for (int i = 0; i &lt; (int)res.size(); i++) printf(&quot;%d &quot;, res[i]); printf(&quot;\n&quot;);
    return 0;
}
*/</FONT></I>
</PRE>
<HR>
<A NAME="file21">
<H1>graph/FordFulkerson.cpp 21/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file20">prev</A>][<A HREF="#file22">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  MaximumFlow by FordFulkerson (for sparse graph)
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> inf_flow = 2000000000;
<B><FONT COLOR="#228B22">class</FONT></B> FordFulkerson {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <I><FONT COLOR="#B22222">// runtime: O(E F), E = #edges, F = max flow values
</FONT></I>    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> edge {
        <B><FONT COLOR="#228B22">int</FONT></B> v;
        <B><FONT COLOR="#228B22">int</FONT></B> capacity; 
        <B><FONT COLOR="#228B22">int</FONT></B> flow; <I><FONT COLOR="#B22222">// current amount allowed to flow
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> rev_index; <I><FONT COLOR="#B22222">// store its reversed edge's index
</FONT></I>        edge(<B><FONT COLOR="#228B22">int</FONT></B> v_, <B><FONT COLOR="#228B22">int</FONT></B> c_, <B><FONT COLOR="#228B22">int</FONT></B> f_, <B><FONT COLOR="#228B22">int</FONT></B> rev) : v(v_), capacity(c_), flow(f_), rev_index(rev) {}
    } Edge;
    <B><FONT COLOR="#228B22">int</FONT></B> N; <I><FONT COLOR="#B22222">// node from 0 to N - 1
</FONT></I>    vector&lt;vector&lt;Edge&gt; &gt; maxFlowEdge;
    <B><FONT COLOR="#228B22">int</FONT></B> mark;   <I><FONT COLOR="#B22222">// global variable for checking if a node is already visited
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; seen;  <I><FONT COLOR="#B22222">// status of each node
</FONT></I>    FordFulkerson(<B><FONT COLOR="#228B22">int</FONT></B> numNode){
        N = numNode;
        maxFlowEdge = vector&lt;vector&lt;Edge&gt; &gt;(numNode);
        seen = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(numNode);
        mark = 0;
    }

    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to, <B><FONT COLOR="#228B22">int</FONT></B> cap){
        maxFlowEdge[from].push_back(Edge(to, cap, cap, maxFlowEdge[to].size()));
        maxFlowEdge[to].push_back(Edge(from, 0, 0, maxFlowEdge[from].size() - 1));
    }
 
    <B><FONT COLOR="#228B22">void</FONT></B> reset_flow(){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++ ){
            seen[i] = false;
            <B><FONT COLOR="#228B22">int</FONT></B> sz = maxFlowEdge[i].size();
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz; j++ ){
                maxFlowEdge[i][j].flow = maxFlowEdge[i][j].capacity;
            }
        }
    }
    
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> get_maxflow(<B><FONT COLOR="#228B22">int</FONT></B> S, <B><FONT COLOR="#228B22">int</FONT></B> T){
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> res = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B>(1){
            mark++;
            <B><FONT COLOR="#228B22">int</FONT></B> flow = find_augmenting_path(S, T, inf_flow);
            <B><FONT COLOR="#A020F0">if</FONT></B> (flow == 0) <B><FONT COLOR="#A020F0">break</FONT></B>;
            <B><FONT COLOR="#A020F0">else</FONT></B> res += flow;
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> find_augmenting_path(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> sink, <B><FONT COLOR="#228B22">int</FONT></B> val){
        <B><FONT COLOR="#228B22">int</FONT></B> sol = 0;
        seen[at] = mark;
        <B><FONT COLOR="#A020F0">if</FONT></B> (at == sink) <B><FONT COLOR="#A020F0">return</FONT></B> val;
        <B><FONT COLOR="#228B22">int</FONT></B> sz = maxFlowEdge[at].size();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++ ) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = maxFlowEdge[at][i].v;
            <B><FONT COLOR="#228B22">int</FONT></B> f = maxFlowEdge[at][i].flow;
            <B><FONT COLOR="#A020F0">if</FONT></B> (seen[v] != mark &amp;&amp; f &gt; 0){
                sol = find_augmenting_path(v, sink, min(f, val));
                <B><FONT COLOR="#A020F0">if</FONT></B> (sol) {
                    maxFlowEdge[at][i].flow -= sol;
                    <B><FONT COLOR="#228B22">int</FONT></B> rev = maxFlowEdge[at][i].rev_index;
                    maxFlowEdge[v][rev].flow += sol;
                    <B><FONT COLOR="#A020F0">return</FONT></B> sol;
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    FordFulkerson mf(3);
    mf.add_edge(0, 1, 2);
    mf.add_edge(1, 2, 2);
    assert(mf.get_maxflow(0, 2) == 2);

    mf = FordFulkerson(4);
    mf.add_edge(0, 1, 2);
    mf.add_edge(0, 2, 2);
    mf.add_edge(1, 3, 1);
    mf.add_edge(1, 2, 1);
    mf.add_edge(2, 3, 2);
    assert(mf.get_maxflow(0, 3) == 3);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file22">
<H1>graph/GlobalMinCut.cpp 22/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file21">prev</A>][<A HREF="#file23">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Global Minimum Cut
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">// Adjacency matrix implementation of Stoer-Wagner min cut algorithm.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time:
</FONT></I><I><FONT COLOR="#B22222">//     O(|V|^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph - adjacency matrix
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - (min cut value, nodes in half of min cut)
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Cost_t, Cost_t INF&gt;

<B><FONT COLOR="#228B22">class</FONT></B> GlobalMinCut {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;Cost_t&gt; VI;
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
    pair&lt;Cost_t, VI&gt; GetMinCut(VVI &amp;weights) {
        <B><FONT COLOR="#228B22">int</FONT></B> N = weights.size();
        VI used(N), cut, best_cut;
        <B><FONT COLOR="#228B22">int</FONT></B> best_weight = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> phase = N-1; phase &gt;= 0; phase--) {
            VI w = weights[0];
            VI added = used;
            <B><FONT COLOR="#228B22">int</FONT></B> prev, last = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; phase; i++) {
                prev = last;
                last = -1;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt; N; j++)
                    <B><FONT COLOR="#A020F0">if</FONT></B> (!added[j] &amp;&amp; (last == -1 || w[j] &gt; w[last])) last = j;
                <B><FONT COLOR="#A020F0">if</FONT></B> (i == phase-1) {
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++) weights[prev][j] += weights[last][j];
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++) weights[j][prev] = weights[prev][j];
                    used[last] = true;
                    cut.push_back(last);
                    <B><FONT COLOR="#A020F0">if</FONT></B> (best_weight == -1 || w[last] &lt; best_weight) {
                        best_cut = cut;
                        best_weight = w[last];
                    }
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++)
                        w[j] += weights[last][j];
                    added[last] = true;
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(best_weight, best_cut);
    }
};

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> INF = 1000000000;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N = 4;
    VVI graph (N);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) graph[i] = VI(N);
    <B><FONT COLOR="#228B22">int</FONT></B> in[4][4] = {{0, 4, 10, 0},
                    {0, 0, 1, 10},
                    {2, 0, 0, 2},
                    {0, 0, 0, 0}};
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++)
            graph[i][j] = in[i][j];
    GlobalMinCut&lt;<B><FONT COLOR="#228B22">int</FONT></B>, INF&gt; solver;
    pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, VI&gt; ret = solver.GetMinCut(graph);
    assert(ret.first == 1);
    cout &lt;&lt; ret.first &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>)ret.second.size(); i++) cout &lt;&lt; ret.second[i] &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
    

</PRE>
<HR>
<A NAME="file23">
<H1>graph/LCA.cpp 23/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file22">prev</A>][<A HREF="#file24">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Lowest Common Ancestor (LCA)
</FONT></I><I><FONT COLOR="#B22222">//  O(nlgn) per query
</FONT></I><I><FONT COLOR="#B22222">//  Link: http://www.spoj.com/status/LCA/
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> LCA {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
    VI depths;
    VVI parents;
    <B><FONT COLOR="#228B22">int</FONT></B> N, root, max_lvl;
    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>    LCA (<B><FONT COLOR="#228B22">int</FONT></B> root_, VVI graph) {
        root = root_; N = graph.size(); depths.resize(N);
        max_lvl = 1; <B><FONT COLOR="#A020F0">while</FONT></B> ((1&lt;&lt;max_lvl) &lt; N) max_lvl++;
        parents.resize(max_lvl, VI(N));
        build_lca(root, -1, graph, 0);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; max_lvl; i++)
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++)
                <B><FONT COLOR="#A020F0">if</FONT></B> (parents[i - 1][j] != -1)
                    parents[i][j] = parents[i - 1][parents[i - 1][j]];
    }
    <B><FONT COLOR="#228B22">int</FONT></B> lca(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (depths[u] &lt; depths[v]) swap(u, v);
        <B><FONT COLOR="#228B22">int</FONT></B> diff_dep = depths[u] - depths[v];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; max_lvl; i++)
            <B><FONT COLOR="#A020F0">if</FONT></B> ((1&lt;&lt;i) &amp; diff_dep)
                u = parents[i][u];
        <B><FONT COLOR="#A020F0">if</FONT></B> (u == v) <B><FONT COLOR="#A020F0">return</FONT></B> u;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = max_lvl - 1; i &gt;= 0; i--) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (parents[i][u] != parents[i][v]) {
                u = parents[i][u];
                v = parents[i][v];
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> parents[0][u];
    }
    <B><FONT COLOR="#228B22">int</FONT></B> get_depth(<B><FONT COLOR="#228B22">int</FONT></B> u) { <B><FONT COLOR="#A020F0">return</FONT></B> depths[u]; }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> build_lca(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> par, VVI &amp;adj, <B><FONT COLOR="#228B22">int</FONT></B> dep) {
        <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[at].size();
        depths[at] = dep;
        parents[0][at] = par;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; max_lvl; i++) parents[i][at] = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (adj[at][i] != par) build_lca(adj[at][i], at, adj, dep + 1);
        }
    }
};

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXN</FONT> 1005

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> test;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;test);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> tt = 0; tt &lt; test; tt++) {
        printf(<B><FONT COLOR="#BC8F8F">&quot;Case %d:\n&quot;</FONT></B>, tt + 1);
        <B><FONT COLOR="#228B22">int</FONT></B> N;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;N);
        VI parents (N, -1);
        VVI graph (N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> sz;
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;sz);
            <B><FONT COLOR="#228B22">int</FONT></B> v;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz; j++) {
                scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;v); v--;
                parents[v] = i;
                graph[i].push_back(v);
                graph[v].push_back(i);
            }
        }
        <B><FONT COLOR="#228B22">int</FONT></B> root = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (parents[root] != -1) root = parents[root];
        LCA solver(root, graph);
        <B><FONT COLOR="#228B22">int</FONT></B> Q;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;Q);
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; Q; i++) {
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;u, &amp;v); u--, v--;
            printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, solver.lca(u, v) + 1);
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file24">
<H1>graph/MaximumBipartiteMatching.cpp 24/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file23">prev</A>][<A HREF="#file25">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Maximum Bipartite Matching on undirected graph
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> MaximumBipartiteMatching {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; adj;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; pairs; <I><FONT COLOR="#B22222">// stores the previous node on the path
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> mark;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; seen;
    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>    MaximumBipartiteMatching() { N = 0; }
    MaximumBipartiteMatching(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) { adj.resize(N); pairs.resize(N); seen.resize(N); mark = 0; }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { adj[u].push_back(v); }
    <I><FONT COLOR="#B22222">// Requires the graph to be bipartite indirected.
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> maximum_matching() {
        assert(N &gt; 0);
        <B><FONT COLOR="#228B22">int</FONT></B> matching = 0;
        fill(pairs.begin(), pairs.end(), -1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) { mark++; matching += dfs(i); }
        <B><FONT COLOR="#A020F0">return</FONT></B> matching / 2; <I><FONT COLOR="#B22222">// return the number of pairs
</FONT></I>    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">bool</FONT></B> dfs(<B><FONT COLOR="#228B22">int</FONT></B> at){
        <B><FONT COLOR="#A020F0">if</FONT></B> (seen[at] == mark) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        seen[at] = mark;
        <B><FONT COLOR="#228B22">int</FONT></B> ss = adj[at].size();
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; ss; i++ ){
            <B><FONT COLOR="#228B22">int</FONT></B> v = adj[at][i];
            <B><FONT COLOR="#A020F0">if</FONT></B>(pairs[v] == -1 || dfs(pairs[v])){
                pairs[v] = at;
                <B><FONT COLOR="#A020F0">return</FONT></B> true;
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    MaximumBipartiteMatching solver(7);
    solver.add_edge(0, 3);
    solver.add_edge(3, 0);
    solver.add_edge(1, 4);
    solver.add_edge(4, 1);
    solver.add_edge(2, 4);
    solver.add_edge(4, 2);
    assert(solver.maximum_matching() == 2);
    solver.add_edge(2, 5);
    solver.add_edge(5, 2);
    assert(solver.maximum_matching() == 3);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
        
    

</PRE>
<HR>
<A NAME="file25">
<H1>graph/MinCostFlow.cpp 25/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file24">prev</A>][<A HREF="#file26">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Minimum Cost Flow Algorithm (example)
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">// Implementation of min cost max flow algorithm using adjacency
</FONT></I><I><FONT COLOR="#B22222">// matrix (Edmonds and Karp 1972).  This implementation keeps track of
</FONT></I><I><FONT COLOR="#B22222">// forward and reverse edges separately (so you can set cap[i][j] !=
</FONT></I><I><FONT COLOR="#B22222">// cap[j][i]).  For a regular max flow, set all edge costs to 0.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time, O(|V|^2) cost per augmentation
</FONT></I><I><FONT COLOR="#B22222">//     max flow:           O(|V|^3) augmentations
</FONT></I><I><FONT COLOR="#B22222">//     min cost max flow:  O(|V|^4 * MAX_EDGE_COST) augmentations
</FONT></I><I><FONT COLOR="#B22222">//     
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//     - source
</FONT></I><I><FONT COLOR="#B22222">//     - sink
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - (maximum flow value, minimum cost value)
</FONT></I><I><FONT COLOR="#B22222">//     - To obtain the actual flow, look at positive values only.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">inf_cost</FONT> (1000000000)
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> L&gt;
<B><FONT COLOR="#228B22">class</FONT></B> MinCostFlow {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector &lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector &lt;VI&gt; VVI;
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector &lt;L&gt; VL;
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector &lt;VL&gt; VVL;
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair &lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector &lt;PII&gt; VPII;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    VVL cap, flow, cost;
    VI found;
    VL dist, pi, width;
    VPII dad;
    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>    MinCostFlow(<B><FONT COLOR="#228B22">int</FONT></B> n):
        N(n), cap(n, VL(n)), flow(n, VL(n)), cost(N, VL(n)),
        found(n), dist(n), pi(n), width(n), dad(n) {}
	
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to, L cap_, L cost_){
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;cap[from][to] = cap_;
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;cost[from][to] = cost_;
    }
    
    <I><FONT COLOR="#B22222">// Return total max flow, total min cost
</FONT></I>    <I><FONT COLOR="#B22222">// TOTAL COST = sum of cost per each unit of flow
</FONT></I>    pair&lt;L, L&gt; get_maxflow(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t){
        L totflow = 0, totcost = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (L amt = dijkstra(s, t)) {
            totflow += amt;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> x = t; x != s; x = dad[x].first) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (dad[x].second == 1) {
                    flow[dad[x].first][x] += amt;
                    totcost += amt * cost[dad[x].first][x];
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    flow[x][dad[x].first] -= amt;
                    totcost -= amt * cost[x][dad[x].first];
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(totflow, totcost);
    }
<B><FONT COLOR="#228B22">private</FONT></B>:	
    <B><FONT COLOR="#228B22">void</FONT></B> relax(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> k, L cap_, L cost_, <B><FONT COLOR="#228B22">int</FONT></B> dir){
        L val = dist[s] + pi[s] - pi[k] + cost_;
        <B><FONT COLOR="#A020F0">if</FONT></B> (cap_ &amp;&amp; val &lt; dist[k]){
            dist[k] = val;
            dad[k] = make_pair(s, dir);
            width[k] = min(cap_, width[s]);
        }
    }
	
    L dijkstra(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t){
        fill(found.begin(), found.end(), false);
        fill(dist.begin(), dist.end(), inf_cost);
        fill(width.begin(), width.end(), 0);
        dist[s] = 0;
        width[s] = inf_cost;
        <B><FONT COLOR="#A020F0">while</FONT></B> (s != -1){
            <B><FONT COLOR="#228B22">int</FONT></B> best = -1;
            found[s] = true;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; N; k++){
                <B><FONT COLOR="#A020F0">if</FONT></B> (found[k])
                    <B><FONT COLOR="#A020F0">continue</FONT></B>;
                relax(s, k, cap[s][k] - flow[s][k], cost[s][k], 1);
                relax(s, k, flow[k][s], -cost[k][s], -1);
                <B><FONT COLOR="#A020F0">if</FONT></B> (best == -1 || dist[k] &lt; dist[best])
                    best = k;
            }
            s = best;
        }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; N; k++)
            pi[k] = min(pi[k] + dist[k], inf_cost);
        <B><FONT COLOR="#A020F0">return</FONT></B> width[t];
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    MinCostFlow&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; mcf(3);
    mcf.add_edge(0, 1, 2, 2);
    mcf.add_edge(1, 2, 2, 5);
    pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; res = mcf.get_maxflow(0, 2);
    assert(res == make_pair(2, 14));

    mcf = MinCostFlow&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(4);
    mcf.add_edge(0, 1, 2, 2);
    mcf.add_edge(0, 2, 2, 10);
    mcf.add_edge(1, 3, 1, 2);
    mcf.add_edge(1, 2, 1, 2);
    mcf.add_edge(2, 3, 2, 2);
    res = mcf.get_maxflow(0, 3);
    assert(res == make_pair(3, 22));
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file26">
<H1>graph/MinCostFlow_required_flow.cpp 26/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file25">prev</A>][<A HREF="#file27">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Minimum Cost Flow Algorithm (with required flow)
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">inf_cost</FONT> (1000000000000.0)
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Flow_t, <B><FONT COLOR="#228B22">class</FONT></B> Cost_t&gt;
<B><FONT COLOR="#228B22">class</FONT></B> MinCostFlow {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <I><FONT COLOR="#B22222">/* Min Cost Flow with a required flow (can be changed to normal by
     * a little modification
     * Using SPFA (Shortest Path Faster Algor) in case the cost is negative
     * If the cost is always positive, it can be replaced by Dijkstra
     */</FONT></I>
    <B><FONT COLOR="#228B22">struct</FONT></B> Edge {
        <B><FONT COLOR="#228B22">int</FONT></B> v, rev;
        Flow_t cap;
        Cost_t cost;
    };

    vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; visited;
    vector&lt;vector&lt;Edge&gt; &gt; edges;
    vector&lt;pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; prev; <I><FONT COLOR="#B22222">// for tracing back the path getting from the shortest path, prev[v] : (u, index of u in edges[v])
</FONT></I>    vector&lt;Cost_t&gt; dist;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.    
</FONT></I>    MinCostFlow(<B><FONT COLOR="#228B22">int</FONT></B> n) {
        N = n; visited.resize(N);
        edges.resize(N); prev.resize(N);
        dist.resize(N);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, Flow_t capacity, Cost_t cost){
        Edge e1 = {v, edges[v].size(), capacity, cost};
        Edge e2 = {u, edges[u].size(), 0, -cost};
        edges[u].push_back(e1);
        edges[v].push_back(e2);
    }

    <I><FONT COLOR="#B22222">// return the minimum cost for getting that required_flow
</FONT></I>    <I><FONT COLOR="#B22222">// return inf_cost if maxflow &lt; required_flow
</FONT></I>    Cost_t get_mincost(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t, Flow_t required_flow){
        Cost_t totalCost = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B>(required_flow &gt; 0){
            Flow_t flow = required_flow;
            <B><FONT COLOR="#A020F0">if</FONT></B>(!spfa(s, t)){ <I><FONT COLOR="#B22222">// can't reach
</FONT></I>                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }

            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = t; i != s; i = prev[i].first)
                flow = min(flow, edges[prev[i].first][prev[i].second].cap);

            <B><FONT COLOR="#A020F0">if</FONT></B>(flow == 0) <B><FONT COLOR="#A020F0">break</FONT></B>;
            required_flow -= flow;
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = t; i != s; i = prev[i].first){
                edges[prev[i].first][prev[i].second].cap -= flow;
                edges[i][edges[prev[i].first][prev[i].second].rev].cap += flow;
            }
            totalCost += flow * dist[t];
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> required_flow == 0 ? totalCost : inf_cost;
    }

<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">bool</FONT></B> spfa(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t){
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++ ) dist[i] = inf_cost;
        dist[s] = 0;
        queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; Q;
        Q.push(s);
        visited[s] = true;
        <B><FONT COLOR="#A020F0">while</FONT></B>(!Q.empty()){
            <B><FONT COLOR="#228B22">int</FONT></B> u = Q.front();
            Q.pop();
            visited[u] = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; edges[u].size(); i++ ){
                <B><FONT COLOR="#228B22">int</FONT></B> v = edges[u][i].v;
                <B><FONT COLOR="#A020F0">if</FONT></B>(edges[u][i].cap &gt; 0 &amp;&amp; dist[v] &gt; dist[u] + edges[u][i].cost){
                    dist[v] = dist[u] + edges[u][i].cost;
                    prev[v] = pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt;(u, i);
                    <B><FONT COLOR="#A020F0">if</FONT></B>(!visited[v]){
                        visited[v] = true;
                        Q.push(v);
                    }
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> dist[t] != inf_cost;
    }
};

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (1000000000)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXN</FONT> 55
<B><FONT COLOR="#228B22">int</FONT></B> caps[MAXN][MAXN];

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    <B><FONT COLOR="#228B22">int</FONT></B> N, K;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;N, &amp;K);

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++ )
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++ )
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;caps[i][j]);

    <B><FONT COLOR="#228B22">int</FONT></B> left = 0, right = 1000000000;
    <B><FONT COLOR="#A020F0">while</FONT></B>(left &lt;= right){
        <B><FONT COLOR="#228B22">int</FONT></B> mid = (left + right) / 2;
        MinCostFlow&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt; solver(N);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++ )
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++ ){
                <B><FONT COLOR="#A020F0">if</FONT></B>(caps[i][j] == 0) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                solver.add_edge(i, j, caps[i][j], 0);
                solver.add_edge(i, j, INF, 1);
            }

        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> cost = solver.get_mincost(0, N - 1, mid);
        <B><FONT COLOR="#A020F0">if</FONT></B>(cost &lt;= K) left = mid + 1;
        <B><FONT COLOR="#A020F0">else</FONT></B> right = mid - 1;
    }

    cout &lt;&lt; right &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

</PRE>
<HR>
<A NAME="file27">
<H1>graph/MinimumPathCoverDAG.cpp 27/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file26">prev</A>][<A HREF="#file28">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Minimum Path Cover on DAG (the minimum number of paths we need so that all nodes are
</FONT></I><I><FONT COLOR="#B22222">//  part of exactly one path)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  Notice: From the DAG with n points, we make a bipartite graph with n points on each side.
</FONT></I><I><FONT COLOR="#B22222">//  For each edge (u, v) in the DAG, we draw an edge between u on the left side and v on
</FONT></I><I><FONT COLOR="#B22222">//  the right side in the bipartite graph.
</FONT></I><I><FONT COLOR="#B22222">//  Then, the number of minimum path cover is just n - #max_matchings
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> MaximumBipartiteMatching {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; adj;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; pairs; <I><FONT COLOR="#B22222">// stores the previous node on the path
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> mark;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; seen;
    MaximumBipartiteMatching() { N = 0; }
    MaximumBipartiteMatching(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) { adj.resize(N); pairs.resize(N); seen.resize(N); mark = 0; }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { adj[u].push_back(v); }
    <I><FONT COLOR="#B22222">// Requires the graph to be bipartite indirected.
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> maximum_matching() {
        assert(N &gt; 0);
        <B><FONT COLOR="#228B22">int</FONT></B> matching = 0;
        fill(pairs.begin(), pairs.end(), -1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) { mark++; matching += dfs(i); }
        <B><FONT COLOR="#A020F0">return</FONT></B> matching / 2; <I><FONT COLOR="#B22222">// return the number of pairs
</FONT></I>    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">bool</FONT></B> dfs(<B><FONT COLOR="#228B22">int</FONT></B> at){
        <B><FONT COLOR="#A020F0">if</FONT></B> (seen[at] == mark) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        seen[at] = mark;
        <B><FONT COLOR="#228B22">int</FONT></B> ss = adj[at].size();
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; ss; i++ ){
            <B><FONT COLOR="#228B22">int</FONT></B> v = adj[at][i];
            <B><FONT COLOR="#A020F0">if</FONT></B>(pairs[v] == -1 || dfs(pairs[v])){
                pairs[v] = at;
                <B><FONT COLOR="#A020F0">return</FONT></B> true;
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
};

<B><FONT COLOR="#228B22">class</FONT></B> MinimumPathCoverDAG {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; adj;
    MaximumBipartiteMatching solver;
    <I><FONT COLOR="#B22222">// Vertices are 0-based indexed.
</FONT></I>    MinimumPathCoverDAG(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) { adj.resize(N); }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { adj[u].push_back(v); }
    <B><FONT COLOR="#228B22">int</FONT></B> minimum_path_cover() {
        solver = MaximumBipartiteMatching(2 * N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[i].size();
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; sz; j++) {
                solver.add_edge(i, adj[i][j] + N);
                solver.add_edge(adj[i][j] + N, i);
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> N - solver.maximum_matching();
    }
    <B><FONT COLOR="#228B22">void</FONT></B> print_path() {
        vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; seen (N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (!seen[i]) { seen[i] = true; <B><FONT COLOR="#228B22">int</FONT></B> now = i; <B><FONT COLOR="#228B22">bool</FONT></B> found = true;
                printf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, i);
                <B><FONT COLOR="#A020F0">while</FONT></B> (found) { found = false;
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = N; j &lt; 2 * N; j++) {
                        <B><FONT COLOR="#A020F0">if</FONT></B> (solver.pairs[j] == now) {
                            now = j - N; seen[now] = true; found = true; <B><FONT COLOR="#A020F0">break</FONT></B>;
                        }
                    }
                    <B><FONT COLOR="#A020F0">if</FONT></B> (found) printf(<B><FONT COLOR="#BC8F8F">&quot; -&gt; %d&quot;</FONT></B>, now);
                }
                printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
            }
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    MinimumPathCoverDAG solver(7);
    solver.add_edge(0, 1);
    solver.add_edge(3, 1);
    solver.add_edge(1, 6);
    solver.add_edge(4, 6);
    solver.add_edge(6, 2);
    solver.add_edge(6, 5);
    assert(solver.minimum_path_cover() == 4);
    solver.print_path();
    solver.add_edge(3, 2);
    assert(solver.minimum_path_cover() == 3);
    printf(<B><FONT COLOR="#BC8F8F">&quot;---------\n&quot;</FONT></B>);
    solver.print_path();
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file28">
<H1>graph/MinimumSpanningTree.cpp 28/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file27">prev</A>][<A HREF="#file29">next</A>]
<PRE>
<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  MinimumSpanningTree (by Kruskal
</FONT></I><I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Cost_t&gt;
<B><FONT COLOR="#228B22">class</FONT></B> MinimumSpanningTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> edge_st {
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        Cost_t c;
        <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> &lt; (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> edge_st &amp;o) <B><FONT COLOR="#228B22">const</FONT></B> {
            <B><FONT COLOR="#A020F0">return</FONT></B> c &lt; o.c;
        }
    } Edge;
    vector&lt;Edge&gt; edges;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; parents;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    <I><FONT COLOR="#B22222">// Vertices are 1-based indexed.
</FONT></I>    MinimumSpanningTree(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) { parents.resize(n + 5); }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, Cost_t c) { Edge e = {u, v, c}; edges.push_back(e); }
    Cost_t kruskal() {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) parents[i] = i;        
        <B><FONT COLOR="#228B22">int</FONT></B> sz = edges.size();
        sort(edges.begin(), edges.end());
        Cost_t res = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> need_edge = N - 1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz &amp;&amp; need_edge; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> pu = find_parent(edges[i].u);
            <B><FONT COLOR="#228B22">int</FONT></B> pv = find_parent(edges[i].v);
            <B><FONT COLOR="#A020F0">if</FONT></B> (pu != pv) { res += edges[i].c; need_edge--; parents[pu] = pv; }
        }
        assert(need_edge == 0);
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> find_parent(<B><FONT COLOR="#228B22">int</FONT></B> u) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (u == parents[u]) <B><FONT COLOR="#A020F0">return</FONT></B> u;
        <B><FONT COLOR="#A020F0">return</FONT></B> parents[u] = find_parent(parents[u]);
    }
};    
        
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    MinimumSpanningTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; mst(5);
    mst.add_edge(1, 4, 1);
    mst.add_edge(1, 4, 7);
    mst.add_edge(2, 3, 5);
    mst.add_edge(5, 3, 9);
    mst.add_edge(1, 3, 4);
    mst.add_edge(1, 2, 3);
    mst.add_edge(2, 5, 2);
    assert(mst.kruskal() == 10);
    mst.add_edge(1, 3, 1);
    assert(mst.kruskal() == 7);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file29">
<H1>graph/ShortestPath.cpp 29/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file28">prev</A>][<A HREF="#file30">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Shortest Path
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> Cost_t, Cost_t INF&gt;
<B><FONT COLOR="#228B22">class</FONT></B> ShortestPath {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;Cost_t, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PCI; <I><FONT COLOR="#B22222">// (cost, vertex)
</FONT></I>    vector&lt;vector&lt;PCI&gt; &gt; adj;
    vector&lt;Cost_t&gt; min_cost;
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    <I><FONT COLOR="#B22222">// Vertices are 1-based indexed.
</FONT></I>    ShortestPath(<B><FONT COLOR="#228B22">int</FONT></B> n) : N(n) { adj.resize(N + 5); min_cost.resize(N + 5); }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, Cost_t c) { adj[u].push_back(PCI(c, v)); }
    Cost_t dijkstra(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to) { dijkstra_algorithm(from, to); <B><FONT COLOR="#A020F0">return</FONT></B> min_cost[to]; }
    vector&lt;Cost_t&gt; dijkstra(<B><FONT COLOR="#228B22">int</FONT></B> from) { dijkstra_algorithm(from, -1); <B><FONT COLOR="#A020F0">return</FONT></B> min_cost; }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> dijkstra_algorithm(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to){
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        Cost_t c;
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++ ) { min_cost[i] = INF; }
        min_cost[from] = 0;
        priority_queue&lt;PCI, vector&lt;PCI&gt;, greater&lt;PCI&gt; &gt; Q;
        vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; seen (N + 5);
        Q.push(PCI(min_cost[from], from));
        <B><FONT COLOR="#A020F0">while</FONT></B> (!Q.empty()) {
            u = Q.top().second;
            Q.pop();
            <B><FONT COLOR="#A020F0">if</FONT></B> (u == to) <B><FONT COLOR="#A020F0">break</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (seen[u]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            seen[u] = true;
            <B><FONT COLOR="#228B22">int</FONT></B> sz = adj[u].size();
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz; i++) {
                v = adj[u][i].second;
                c = adj[u][i].first;
                <B><FONT COLOR="#A020F0">if</FONT></B> (!seen[v] &amp;&amp; min_cost[v] &gt; min_cost[u] + c) {
                    min_cost[v] = min_cost[u] + c;
                    Q.push(PCI(min_cost[v], v));
                }
            }
        }
    }
};

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (1000000000)

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    ShortestPath&lt;<B><FONT COLOR="#228B22">int</FONT></B>, INF&gt; solver(5);
    solver.add_edge(1, 2, 3);
    solver.add_edge(2, 1, 3);
    solver.add_edge(1, 3, 1);
    solver.add_edge(3, 1, 1);
    solver.add_edge(3, 2, 1);
    solver.add_edge(2, 3, 1);
    solver.add_edge(4, 2, 2);
    solver.add_edge(2, 4, 2);
    assert(solver.dijkstra(1, 4) == 4);
    assert(solver.dijkstra(1, 5) == INF);
    solver.add_edge(4, 5, 1);
    solver.add_edge(5, 4, 1);
    assert(solver.dijkstra(1, 5) == 5);
    solver.add_edge(1, 5, 2);
    solver.add_edge(5, 1, 2);
    assert(solver.dijkstra(1, 5) == 2);
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; dist = solver.dijkstra(5);
    assert(dist[1] == 2);
    assert(dist[2] == 3);
    assert(dist[3] == 3);
    assert(dist[4] == 1);
    assert(dist[5] == 0);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file30">
<H1>graph/StronglyConnectedComponent.cpp 30/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file29">prev</A>][<A HREF="#file31">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Strongly Connected Component
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstring&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> StronglyConnectedComponent {
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI; <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">struct</FONT></B> edge{
        <B><FONT COLOR="#228B22">int</FONT></B> e, nxt;
        edge() {}
        edge(<B><FONT COLOR="#228B22">int</FONT></B> _e, <B><FONT COLOR="#228B22">int</FONT></B> _nxt) : e(_e), nxt(_nxt) {}
    };  
    <B><FONT COLOR="#228B22">int</FONT></B> V, E;
    vector&lt;edge&gt; e, er;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; sp, spr, group_num, stk;
    <B><FONT COLOR="#228B22">int</FONT></B> group_cnt; VVI graph; <I><FONT COLOR="#B22222">// reduced graph
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; visited;
    <I><FONT COLOR="#B22222">// Vertices are 1-indexed based.
</FONT></I>    StronglyConnectedComponent(<B><FONT COLOR="#228B22">int</FONT></B> _V) {
        V = _V; E = 0; group_cnt = 0; group_num = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(V + 5);
        sp = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(V + 5); spr = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(V + 5); stk = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(V + 5);
        visited = vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt;(V + 5); e.push_back(edge()); er.push_back(edge());
    }
    <B><FONT COLOR="#228B22">void</FONT></B> fill_forward(<B><FONT COLOR="#228B22">int</FONT></B> x){
        visited[x] = true;
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = sp[x]; i; i = e[i].nxt) <B><FONT COLOR="#A020F0">if</FONT></B> (!visited[e[i].e]) fill_forward(e[i].e);
        stk[++stk[0]] = x;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> fill_backward(<B><FONT COLOR="#228B22">int</FONT></B> x){
        visited[x] = false;
        group_num[x] = group_cnt;
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = spr[x]; i; i = er[i].nxt) <B><FONT COLOR="#A020F0">if</FONT></B> (visited[er[i].e]) fill_backward(er[i].e);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> v1, <B><FONT COLOR="#228B22">int</FONT></B> v2){ <I><FONT COLOR="#B22222">// Add edge v1-&gt;v2
</FONT></I>        E++;
        e.push_back(edge(v2, sp[v1])); sp[v1] = E;
        er.push_back(edge(v1, spr[v2])); spr[v2] = E;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> cal_scc() {
        stk[0] = 0;
        fill(visited.begin(), visited.end(), false);
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= V; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (!visited[i]) fill_forward(i);
        group_cnt = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = stk[0]; i &gt;= 1; i--) <B><FONT COLOR="#A020F0">if</FONT></B> (visited[stk[i]]) { group_cnt++; fill_backward(stk[i]); }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> cal_reduced_graph() { <I><FONT COLOR="#B22222">// need to call cal_scc() before
</FONT></I>        graph = VVI(group_cnt + 1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= V; i++) { <B><FONT COLOR="#228B22">int</FONT></B> u = group_num[i];
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = sp[i]; j; j = e[j].nxt) {
                <B><FONT COLOR="#228B22">int</FONT></B> v = group_num[e[j].e];
                <B><FONT COLOR="#A020F0">if</FONT></B> (u != v) graph[u].push_back(v);
            }
            sort(graph[u].begin(), graph[u].end());
            graph[u].erase(unique(graph[u].begin(), graph[u].end()), graph[u].end());
        }
    }
};

<I><FONT COLOR="#B22222">///////////
</FONT></I><I><FONT COLOR="#B22222">//  2-SAT
</FONT></I><I><FONT COLOR="#B22222">///////////
</FONT></I>
<I><FONT COLOR="#B22222">/*
0. V = 2 * N (N = the number of variables)
1. Add edges:(a || b) -&gt; edge(~a, b), edge(~b, a)
2. SCC()
3. it's possible if a and ~a are in the difference components (different group_num[])
4. Ans: if group_num[a] &gt; group_num[~a], assign a to True
*/</FONT></I>
</PRE>
<HR>
<A NAME="file31">
<H1>number/LinearAlgebra.cpp 31/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file30">prev</A>][<A HREF="#file32">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Linear Algebra/ Solving a system of linear equation
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;

<I><FONT COLOR="#B22222">// Compute n choose m
</FONT></I>LL <B><FONT COLOR="#0000FF">binomial</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n, <B><FONT COLOR="#228B22">int</FONT></B> m) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (n &lt; m || n &lt; 0 || m &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    LL ans = 1, ans2 = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) {
        ans *= n - i;
        ans2 *= i + 1;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ans / ans2;
}

<I><FONT COLOR="#B22222">// compute catalan number (n &gt;= 0)
</FONT></I><I><FONT COLOR="#B22222">// 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, ...
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Ex. Number of ways to insert n pairs of parentheses in a word of n+1 letters.
</FONT></I><I><FONT COLOR="#B22222">//     E.g., for n=3 there are 5 ways: ((ab)(cd)), (((ab)c)d), ((a(bc))d), (a((bc)d)), (a(b(cd))).
</FONT></I>LL <B><FONT COLOR="#0000FF">catalan_number</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n) {
    <B><FONT COLOR="#A020F0">return</FONT></B> binomial(n * 2, n) / (n + 1);
}

<I><FONT COLOR="#B22222">// return a % b (positive value)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
T mod(T a, T b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> ((a%b)+b)%b;
}

<I><FONT COLOR="#B22222">// computes gcd(a,b)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
T gcd(T a, T b) {
    T tmp;
    <B><FONT COLOR="#A020F0">while</FONT></B> (b) {
        a%=b; tmp=a; a=b; b=tmp;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> a;
}

<I><FONT COLOR="#B22222">// computes lcm(a,b)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
T lcm(T a, T b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a / gcd(a,b) * b;
}

<I><FONT COLOR="#B22222">// returns d = gcd(a,b); finds x,y such that d = ax + by
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
T extended_euclid(T a, T b, T &amp;x, T &amp;y) {  
    T xx = y = 0;
    T yy = x = 1;
    <B><FONT COLOR="#A020F0">while</FONT></B> (b) {
        T q = a / b;
        T t = b; b = a % b; a = t;
        t = xx; xx = x - q * xx; x = t;
        t = yy; yy = y - q * yy; y = t;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> a;
}

<I><FONT COLOR="#B22222">// computes b such that ab = 1 (mod n), returns -1 on failure
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
T mod_inverse(T a, T n) {
    T x, y;
    T d = extended_euclid(a, n, x, y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (d &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> -1;
    <B><FONT COLOR="#A020F0">return</FONT></B> mod(x,n);
}

<I><FONT COLOR="#B22222">// finds all solutions to ax = b (mod n)
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
vector&lt;T&gt; modular_linear_equation_solver(T a, T b, T n) {
    T x, y;
    vector&lt;T&gt; solutions;
    T d = extended_euclid(a, n, x, y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(b%d)) {
        x = mod (x*(b/d), n);
        <B><FONT COLOR="#A020F0">for</FONT></B> (T i = 0; i &lt; d; i++)
            solutions.push_back(mod(x + i*(n/d), n));
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> solutions;
}


<I><FONT COLOR="#B22222">//  return the smallest value of x s.t x &gt;= lowerBound 
</FONT></I><I><FONT COLOR="#B22222">//  and ax = c (mod b) 
</FONT></I>LL <B><FONT COLOR="#0000FF">get_greater</FONT></B>(LL c, LL a, LL b, LL lowerBound){
    LL x, y;
    LL A = a, B = b, C = c;
    LL g = extended_euclid(A, B, x, y);
    x = (x + B) % B;
    LL key = (-C) * x / g;
    LL k = (lowerBound - key) / B;
    LL ret = key + B * k;
    <B><FONT COLOR="#A020F0">while</FONT></B>(ret &lt; lowerBound){
        <B><FONT COLOR="#A020F0">if</FONT></B>(B &gt; 0) ret += B; 
        <B><FONT COLOR="#A020F0">else</FONT></B> ret -= B;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">//  return the largest value of x s.t x &lt;= upperBound
</FONT></I><I><FONT COLOR="#B22222">//	and ax = c (mod b)
</FONT></I>LL <B><FONT COLOR="#0000FF">get_less</FONT></B>(LL c, LL a, LL b, LL upperBound){
    LL x, y;
    LL A = a, B = b, C = c;
    LL g = extended_euclid(A, B, x, y);
    x = (x + B) % B;
    LL key = (-C) * x / g;
    LL k = (upperBound - key) / B;
    LL ret = key + B * k;
    <I><FONT COLOR="#B22222">// for edge case
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(B &gt; 0) ret += 2 * B;
    <B><FONT COLOR="#A020F0">else</FONT></B> ret -= 2 * B;
    <B><FONT COLOR="#A020F0">while</FONT></B>(ret &gt; upperBound){
        <B><FONT COLOR="#A020F0">if</FONT></B>(B &gt; 0) ret -= B; 
        <B><FONT COLOR="#A020F0">else</FONT></B> ret += B;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// Chinese remainder theorem (special case): find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % x = a, z % y = b.  Here, z is unique modulo M = lcm(x,y).
</FONT></I><I><FONT COLOR="#B22222">// Return (z,M).  On failure, M = -1.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
pair&lt;T, T&gt; chinese_remainder_theorem(T x, T a, T y, T b) {
    T s, t;
    T d = extended_euclid(x, y, s, t);
    <B><FONT COLOR="#A020F0">if</FONT></B> (a%d != b%d) <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(0, -1);
    <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(mod(s*b*x+t*a*y,x*y)/d, x*y/d);
}

<I><FONT COLOR="#B22222">// Chinese remainder theorem: find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % x[i] = a[i] for all i.  Note that the solution is
</FONT></I><I><FONT COLOR="#B22222">// unique modulo M = lcm_i (x[i]).  Return (z,M).  On 
</FONT></I><I><FONT COLOR="#B22222">// failure, M = -1.  Note that we do not require the a[i]'s
</FONT></I><I><FONT COLOR="#B22222">// to be relatively prime.
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
pair&lt;T, T&gt; chinese_remainder_theorem(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;T&gt; &amp;x, <B><FONT COLOR="#228B22">const</FONT></B> vector&lt;T&gt; &amp;a) {
    PII ret = make_pair(a[0], x[0]);
    <B><FONT COLOR="#A020F0">for</FONT></B> (T i = 1; i &lt; x.size(); i++) {
        ret = chinese_remainder_theorem(ret.second, ret.first, x[i], a[i]);
        <B><FONT COLOR="#A020F0">if</FONT></B> (ret.second == -1) <B><FONT COLOR="#A020F0">break</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// computes x and y such that ax + by = c; on failure, x = y =-1
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">linear_diophantine</FONT></B>(T a, T b, T c, T &amp;x, T &amp;y) {
    T d = gcd(a, b);
    <B><FONT COLOR="#A020F0">if</FONT></B> (c % d) {
        x = y = -1;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
        x = c / d * mod_inverse(a / d, b / d);
        y = (c - a * x) / b;
    }
}

<I><FONT COLOR="#B22222">///////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  GaussJordan
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">// Gauss-Jordan elimination with full pivoting.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Uses:
</FONT></I><I><FONT COLOR="#B22222">//   (1) solving systems of linear equations (AX=B)
</FONT></I><I><FONT COLOR="#B22222">//   (2) inverting matrices (AX=I)
</FONT></I><I><FONT COLOR="#B22222">//   (3) computing determinants of square matrices
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    a[][] = an nxn matrix
</FONT></I><I><FONT COLOR="#B22222">//           b[][] = an nxm matrix
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   X      = an nxm matrix (stored in b[][])
</FONT></I><I><FONT COLOR="#B22222">//           A^{-1} = an nxn matrix (stored in a[][])
</FONT></I><I><FONT COLOR="#B22222">//           returns determinant of a[][]
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-10;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

T GaussJordan(VVT &amp;a, VVT &amp;b) {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = a.size();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = b[0].size();
    VI irow(n), icol(n), ipiv(n);
    T det = 1;
    
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> pj = -1, pk = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) 
            <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[j])
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) 
                    <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[k])
                        <B><FONT COLOR="#A020F0">if</FONT></B> (pj == -1 || fabs(a[j][k]) &gt; fabs(a[pj][pk])) { pj = j; pk = k; }
        <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[pj][pk]) &lt; EPS) { cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Matrix is singular.&quot;</FONT></B> &lt;&lt; endl; exit(0); }
        ipiv[pk]++;
        swap(a[pj], a[pk]);
        swap(b[pj], b[pk]);
        <B><FONT COLOR="#A020F0">if</FONT></B> (pj != pk) det *= -1;
        irow[i] = pj;
        icol[i] = pk;

        T c = 1.0 / a[pk][pk];
        det *= a[pk][pk];
        a[pk][pk] = 1.0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++) a[pk][p] *= c;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; m; p++) b[pk][p] *= c;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++) 
            <B><FONT COLOR="#A020F0">if</FONT></B> (p != pk) {
                c = a[p][pk];
                a[p][pk] = 0;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; n; q++) a[p][q] -= a[pk][q] * c;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; m; q++) b[p][q] -= b[pk][q] * c;      
            }
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = n-1; p &gt;= 0; p--) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (irow[p] != icol[p]) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) 
                swap(a[k][irow[p]], a[k][icol[p]]);
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> det;
}

<I><FONT COLOR="#B22222">//////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  ReducedRowEchelonForm/ Find Rank
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  can be modified to find a normal rank of an nxn matrix
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////
</FONT></I>
<B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">findRank</FONT></B>(vector&lt;vector&lt;T&gt; &gt; &amp;a, vector&lt;T&gt; &amp;b, T p) {
    <I><FONT COLOR="#B22222">// M equations, N variables, modulo p
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> M = a.size();
    <B><FONT COLOR="#228B22">int</FONT></B> N = a[0].size();
    <B><FONT COLOR="#228B22">int</FONT></B> ans = 0;     
     
    <I><FONT COLOR="#B22222">// Using Gauss-Jordan in [ A : b ] to make it in row-echellon form.
</FONT></I>    <I><FONT COLOR="#B22222">// So that we can find the rank. We also need to make sure that the
</FONT></I>    <I><FONT COLOR="#B22222">// rank of [ A ] is equal to the rank of [A : b], else there are
</FONT></I>    <I><FONT COLOR="#B22222">// no solutions
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> c = 0; c &lt; N; c++) {
        <B><FONT COLOR="#228B22">int</FONT></B> j = ans;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = ans + 1; i &lt; M; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (a[i][c]) {
                j = i;
                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (a[j][c] == 0) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        swap(a[j], a[ans]);
        swap(b[j], b[ans]);
        <I><FONT COLOR="#B22222">// s = 1 / a[ans][c] (in mod p)
</FONT></I>        T s = mod_inverse(a[ans][c], p);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; N; k++) 
            a[ans][k] = (a[ans][k] * s) % p;
        b[ans] = (b[ans] * s) % p;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = ans + 1; k &lt; M; k++) {
            <B><FONT COLOR="#228B22">int</FONT></B> coef = -a[k][c];
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> l = 0; l &lt; N; l++) 
                a[k][l] = ((a[k][l] + a[ans][l] * coef) % p + p) % p;
            b[k] = (b[k] + b[ans] * coef) % p;
        }
        ans++;
    }
    
    <I><FONT COLOR="#B22222">// If rank of [A] is not equal to the rank of [A : b]
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = ans; i &lt; M; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (b[i]) {
            <B><FONT COLOR="#A020F0">return</FONT></B> -1;
        }
    }
          
    <B><FONT COLOR="#A020F0">return</FONT></B> ans;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = 4;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = 2;
    <B><FONT COLOR="#228B22">double</FONT></B> A[n][n] = { {1,2,3,4},{1,0,1,0},{5,3,2,4},{6,1,4,6} };
    <B><FONT COLOR="#228B22">double</FONT></B> B[n][m] = { {1,2},{4,3},{5,6},{8,7} };
    VVT a(n), b(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        a[i] = VT(A[i], A[i] + n);
        b[i] = VT(B[i], B[i] + m);
    }
  
    <B><FONT COLOR="#228B22">double</FONT></B> det = GaussJordan(a, b);
  
    <I><FONT COLOR="#B22222">// expected: 60  
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Determinant: &quot;</FONT></B> &lt;&lt; det &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: -0.233333 0.166667 0.133333 0.0666667
</FONT></I>    <I><FONT COLOR="#B22222">//           0.166667 0.166667 0.333333 -0.333333
</FONT></I>    <I><FONT COLOR="#B22222">//           0.233333 0.833333 -0.133333 -0.0666667
</FONT></I>    <I><FONT COLOR="#B22222">//           0.05 -0.75 -0.1 0.2
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Inverse: &quot;</FONT></B> &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
            cout &lt;&lt; a[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
        cout &lt;&lt; endl;
    }
    
    <I><FONT COLOR="#B22222">// expected: 1.63333 1.3
</FONT></I>    <I><FONT COLOR="#B22222">//           -0.166667 0.5
</FONT></I>    <I><FONT COLOR="#B22222">//           2.36667 1.7
</FONT></I>    <I><FONT COLOR="#B22222">//           -1.85 -1.35
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Solution: &quot;</FONT></B> &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++)
            cout &lt;&lt; b[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
        cout &lt;&lt; endl;
    }

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= 10; i++) cout &lt;&lt; catalan_number(i) &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

}
</PRE>
<HR>
<A NAME="file32">
<H1>number/Matrix.cpp 32/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file31">prev</A>][<A HREF="#file33">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Matrix
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> Matrix {
<B><FONT COLOR="#228B22">public</FONT></B>:
    vector&lt;vector&lt;T&gt; &gt; mat;
    <B><FONT COLOR="#228B22">int</FONT></B> N, M;
    
    Matrix (<B><FONT COLOR="#228B22">int</FONT></B> n, <B><FONT COLOR="#228B22">int</FONT></B> m) {
        N = n;
        M = m;
        mat = vector&lt;vector&lt;T&gt; &gt;(N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++)
            mat[i] = vector&lt;T&gt; (M);
    }

    Matrix mult(<B><FONT COLOR="#228B22">const</FONT></B> Matrix &amp;a) {
        assert(M == a.N);
        Matrix ret = Matrix(N, a.M);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; a.M; j++) {
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; M; k++) {
                    ret.mat[i][j] += mat[i][k] * a.mat[k][j];
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }

    Matrix power(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ex) {
        assert(N == M);
        Matrix ret = identity(N), b = *<B><FONT COLOR="#A020F0">this</FONT></B>;
        <B><FONT COLOR="#A020F0">while</FONT></B> (ex) { <B><FONT COLOR="#A020F0">if</FONT></B> (ex &amp; 1) ret = ret.mult(b); b = b.mult(b); ex &gt;&gt;= 1; }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }

    Matrix identity(<B><FONT COLOR="#228B22">int</FONT></B> n) {
        Matrix ret = Matrix(n, n);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) ret.mat[i][i] = 1;
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    
    <B><FONT COLOR="#228B22">void</FONT></B> print() {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; M; j++) {
                cout &lt;&lt; mat[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
            }
            cout &lt;&lt; endl;
        }
    }
};
    

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    
    Matrix&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; start = Matrix&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(2, 2);
    start.mat[0][1] = start.mat[1][0] = start.mat[1][1] = 1;

    start.print();
    Matrix&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; now = start;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; 10; i++) {
        now.print();
        now = now.mult(start);
    }

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; 10; i++) {
        start.power(i).print();
    }
        
    
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file33">
<H1>number/ModInt.cpp 33/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file32">prev</A>][<A HREF="#file34">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Modulo Integer
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B>&lt;typename Int,Int mod&gt;
<B><FONT COLOR="#228B22">class</FONT></B> ModInt {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> Int Mod = mod;
    Int x;
    ModInt(): x(0) {}
    ModInt(<B><FONT COLOR="#228B22">int</FONT></B> a) { Int t = a % mod; <B><FONT COLOR="#A020F0">if</FONT></B>(t &lt; 0) t += mod; x = t; }
    ModInt(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> a) { Int t = a % mod; <B><FONT COLOR="#A020F0">if</FONT></B>(t &lt; 0) t += mod; x = t; }
    Int get() <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> x; }
    
    ModInt &amp;<B><FONT COLOR="#A020F0">operator</FONT></B> += (ModInt that) { <B><FONT COLOR="#A020F0">if</FONT></B>((x += that.x) &gt;= mod) x -= mod; <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>; }
    ModInt &amp;<B><FONT COLOR="#A020F0">operator</FONT></B> -= (ModInt that) { <B><FONT COLOR="#A020F0">if</FONT></B>((x += mod - that.x) &gt;= mod) x -= mod; <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>; }
    ModInt &amp;<B><FONT COLOR="#A020F0">operator</FONT></B> *= (ModInt that) { x = (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>)(x) * that.x % mod; <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>; }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> == (ModInt that) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> x == that.x; }
    ModInt <B><FONT COLOR="#A020F0">operator</FONT></B> + (ModInt that) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> ModInt(*<B><FONT COLOR="#A020F0">this</FONT></B>) += that; }
    ModInt <B><FONT COLOR="#A020F0">operator</FONT></B> - (ModInt that) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> ModInt(*<B><FONT COLOR="#A020F0">this</FONT></B>) -= that; }
    ModInt <B><FONT COLOR="#A020F0">operator</FONT></B> * (ModInt that) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> ModInt(*<B><FONT COLOR="#A020F0">this</FONT></B>) *= that; }
    ModInt <B><FONT COLOR="#A020F0">operator</FONT></B> - () <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> ModInt(-<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;x); }
    <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">friend</FONT></B> ostream&amp; <B><FONT COLOR="#A020F0">operator</FONT></B> &lt;&lt; (ostream &amp;out, ModInt m) {<B><FONT COLOR="#A020F0">return</FONT></B> out &lt;&lt; m.x;}
    
    ModInt power(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> k) <B><FONT COLOR="#228B22">const</FONT></B> {
        ModInt r(1); ModInt b = *<B><FONT COLOR="#A020F0">this</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (k &lt;= 0) <B><FONT COLOR="#A020F0">return</FONT></B> r; <B><FONT COLOR="#A020F0">while</FONT></B> (k) { <B><FONT COLOR="#A020F0">if</FONT></B> (k &amp; 1) r *= b; b *= b; k &gt;&gt;= 1; }
        <B><FONT COLOR="#A020F0">return</FONT></B> r;
    }
    ModInt inverse() <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> a = x, b = mod, u = 1, v = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B>(b) { <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }
        <B><FONT COLOR="#A020F0">return</FONT></B> ModInt(u);
    }
};

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MOD</FONT> (1000000007)
<B><FONT COLOR="#228B22">typedef</FONT></B> ModInt&lt;<B><FONT COLOR="#228B22">int</FONT></B>, MOD&gt; Mint;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    Mint a(7);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = -10; i &lt; 10; i++) {
        cout &lt;&lt; a &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; power of &quot;</FONT></B> &lt;&lt; i &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; : &quot;</FONT></B> &lt;&lt; a.power(i) &lt;&lt; endl;
        Mint t(i);
        cout &lt;&lt; t &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; (inverse): &quot;</FONT></B> &lt;&lt; t.inverse() &lt;&lt; endl;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file34">
<H1>number/PrimeGenerator.cpp 34/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file33">prev</A>][<A HREF="#file35">next</A>]
<PRE>
<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">// Prime Generator
</FONT></I><I><FONT COLOR="#B22222">// Use Sieve Eratosthenes - can find all the primes within range (1, 2^31 - 1)
</FONT></I><I><FONT COLOR="#B22222">// Reference: http://zobayer.blogspot.in/2009/09/segmented-sieve.html
</FONT></I><I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">template</FONT></B> &lt;<B><FONT COLOR="#228B22">int</FONT></B> MAX_RANGE&gt;
<B><FONT COLOR="#228B22">class</FONT></B> PrimeGenerator {
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SQ</FONT></B>(x) ((x)*(x))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MSET</FONT></B>(x,v) memset(x,v,sizeof(x))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">CHKC</FONT></B>(x,n) (x[n&gt;&gt;6]&amp;(1&lt;&lt;((n&gt;&gt;1)&amp;31)))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SETC</FONT></B>(x,n) (x[n&gt;&gt;6]|=(1&lt;&lt;((n&gt;&gt;1)&amp;31)))
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MAX = 46656; <I><FONT COLOR="#B22222">// around sqrt(2^31 - 1)
</FONT></I>    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> LMT = 216;  <I><FONT COLOR="#B22222">// sqrt(MAX)
</FONT></I>    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> LEN = 4830; <I><FONT COLOR="#B22222">// number of necessary primes (primes under MAX)
</FONT></I>    <B><FONT COLOR="#228B22">unsigned</FONT></B> base[MAX/64], segment[MAX_RANGE/64], primes[LEN];    
<B><FONT COLOR="#228B22">public</FONT></B>:
    PrimeGenerator() { internal_sieve(); }
    <I><FONT COLOR="#B22222">// Returns the number of primes within range [a, b] and marks them in segment[]
</FONT></I>    <I><FONT COLOR="#B22222">// Stores all the primes in the user array (it not NULL)
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> segmented_sieve(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> *user) {
        <B><FONT COLOR="#228B22">unsigned</FONT></B> i, j, k, cnt = (a &lt;= 2 &amp;&amp; 2 &lt;= b)? 1 : 0;
        <B><FONT COLOR="#A020F0">if</FONT></B> (a &lt;= 2 &amp;&amp; 2 &lt;= b) { <B><FONT COLOR="#A020F0">if</FONT></B> (user) user[cnt - 1] = 2; }
        <B><FONT COLOR="#A020F0">if</FONT></B> (b &lt; 2) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
        <B><FONT COLOR="#A020F0">if</FONT></B> (a &lt; 3) a = 3;
        <B><FONT COLOR="#A020F0">if</FONT></B> (a % 2 == 0) a++;
        MSET(segment, 0);
        <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; SQ(primes[i]) &lt;= b; i++) {
            j = primes[i] * ((a + primes[i] - 1) / primes[i]);
            <B><FONT COLOR="#A020F0">if</FONT></B> (j % 2 == 0) j += primes[i];
            <B><FONT COLOR="#A020F0">for</FONT></B> (k = primes[i]&lt;&lt;1; j &lt;= b; j += k)
                <B><FONT COLOR="#A020F0">if</FONT></B> (j != primes[i]) SETC(segment, (j - a));
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (b - a &gt;= 0) {
            <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt;= b - a; i += 2) {
                <B><FONT COLOR="#A020F0">if</FONT></B>(!CHKC(segment, i)) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (user) user[cnt] = i + a;
                    cnt++;
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> cnt;
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <I><FONT COLOR="#B22222">// Generates all the necessary prime numbers and marks them in base[]
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> internal_sieve() {
        <B><FONT COLOR="#228B22">unsigned</FONT></B> i, j, k;
        <B><FONT COLOR="#A020F0">for</FONT></B> (i = 3; i &lt; LMT; i += 2)
            <B><FONT COLOR="#A020F0">if</FONT></B> (!CHKC(base, i)) <B><FONT COLOR="#A020F0">for</FONT></B> (j = i * i, k = i&lt;&lt;1; j &lt; MAX; j += k) SETC(base, j);
        <B><FONT COLOR="#A020F0">for</FONT></B> (i = 3, j = 0; i &lt; MAX; i += 2) <B><FONT COLOR="#A020F0">if</FONT></B> (!CHKC(base, i)) primes[j++] = i;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> primes[1000005];

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    PrimeGenerator&lt;10000000&gt; pg; <I><FONT COLOR="#B22222">// range 10,000,000 for testing - might wanna change it
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> num_p = pg.segmented_sieve(1, 100, primes);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; num_p; i++) {
        cout &lt;&lt; primes[i] &lt;&lt; endl;
    }
    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;count: &quot;</FONT></B> &lt;&lt; num_p &lt;&lt; endl;    

    assert(pg.segmented_sieve(2, 2, NULL) == 1);
    assert(pg.segmented_sieve(2, 3, NULL) == 2);
    assert(pg.segmented_sieve(5, 10, NULL) == 2);
    assert(pg.segmented_sieve(1, 10, NULL) == 4);
    assert(pg.segmented_sieve(1, 50, NULL) == 15);
    assert(pg.segmented_sieve(1, 100, NULL) == 25);
    assert(pg.segmented_sieve(1, 1000000, NULL) == 78498);
    assert(pg.segmented_sieve(1, 10000000, NULL) == 664579);
    assert(pg.segmented_sieve(2000000000, 2000000000, NULL) == 0);
    assert(pg.segmented_sieve(2000000001, 2000000001, NULL) == 0);
    assert(pg.segmented_sieve(2000000000, 2010000000, NULL) == 467612);

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file35">
<H1>number/Rational.cpp 35/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file34">prev</A>][<A HREF="#file36">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII; <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;PII, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII2;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI; <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">class</FONT></B> Rational {
<B><FONT COLOR="#228B22">public</FONT></B>:
    LL p, q;
    Rational() {}
    Rational(LL p_): p(p_), q(1) {}
    Rational(LL p_, LL q_): p(p_), q(q_) { reduce(); }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> == (<B><FONT COLOR="#228B22">const</FONT></B> Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> p == rhs.p &amp;&amp; q == rhs.q; }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> != (<B><FONT COLOR="#228B22">const</FONT></B> Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> p != rhs.p || q != rhs.q; }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> &lt; (<B><FONT COLOR="#228B22">const</FONT></B> Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> p * rhs.q &lt; rhs.p * q; }
    Rational <B><FONT COLOR="#A020F0">operator</FONT></B> + (Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Rational(p * rhs.q + q * rhs.p, q * rhs.q); }
    Rational <B><FONT COLOR="#A020F0">operator</FONT></B> - (Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Rational(p * rhs.q - q * rhs.p, q * rhs.q); }
    Rational <B><FONT COLOR="#A020F0">operator</FONT></B> * (Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Rational(p * rhs.p, q * rhs.q); }
    Rational <B><FONT COLOR="#A020F0">operator</FONT></B> / (Rational&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> Rational(p * rhs.q, q * rhs.p); }
    <B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">friend</FONT></B> ostream&amp; <B><FONT COLOR="#A020F0">operator</FONT></B> &lt;&lt; (ostream &amp;out, Rational m) { <B><FONT COLOR="#A020F0">return</FONT></B> out &lt;&lt; m.p &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;/&quot;</FONT></B> &lt;&lt; m.q; }
<B><FONT COLOR="#228B22">private</FONT></B>:
    LL gcd(LL a, LL b) { <B><FONT COLOR="#A020F0">if</FONT></B> (b == 0) <B><FONT COLOR="#A020F0">return</FONT></B> a; <B><FONT COLOR="#A020F0">return</FONT></B> gcd(b, a % b); }
    <B><FONT COLOR="#228B22">void</FONT></B> reduce() {
        <B><FONT COLOR="#A020F0">if</FONT></B> (q &lt; 0) { p *= -1; q *= -1; }
        LL t = gcd((p &gt;= 0 ? p : -p), q);
        p /= t; q /= t;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    Rational x(4, 6);
    Rational y(5, 6);
    cout &lt;&lt; x &lt;&lt; endl;
    cout &lt;&lt; y &lt;&lt; endl;
    cout &lt;&lt; x + y &lt;&lt; endl;
    cout &lt;&lt; x - y &lt;&lt; endl;
    Rational z(0, -1);
    cout &lt;&lt; z &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file36">
<H1>string/ManacherAlgorithm.cpp 36/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file35">prev</A>][<A HREF="#file37">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Manacher's algorithm
</FONT></I><I><FONT COLOR="#B22222">//  - Finding the longest substring that is also a palindrome in linear time
</FONT></I><I><FONT COLOR="#B22222">//  - It also finds the length of longest palindrome &quot;centered&quot; at each position
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">// Transform S into T.
</FONT></I><I><FONT COLOR="#B22222">// For example, S = &quot;abba&quot;, T = &quot;^#a#b#b#a#$&quot;.
</FONT></I><I><FONT COLOR="#B22222">// ^ and $ signs are sentinels appended to each end to avoid bounds checking
</FONT></I><I><FONT COLOR="#B22222">// 
</FONT></I><I><FONT COLOR="#B22222">// For example: S = &quot;abaaba&quot;, T = &quot;^#a#b#a#a#b#a#$&quot;.
</FONT></I><I><FONT COLOR="#B22222">// T = ^ # a # b # a # a # b # a # $
</FONT></I><I><FONT COLOR="#B22222">// P = 0 0 1 0 3 0 1 6 1 0 3 0 1 0 0
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstring&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">class</FONT></B> ManacherAlgorithm {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">char</FONT></B> *T;
    string s;
    
    ManacherAlgorithm(string _s) {
        s = _s;
        <B><FONT COLOR="#228B22">int</FONT></B> n = s.size();
        <B><FONT COLOR="#228B22">int</FONT></B> n2 = 0;
        T = <B><FONT COLOR="#A020F0">new</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>[2 * n + 5];
        T[n2++] = <B><FONT COLOR="#BC8F8F">'^'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B>(n == 0){
            T[n2++] = <B><FONT COLOR="#BC8F8F">'$'</FONT></B>;
            T[n2] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++ ){
                T[n2++] = <B><FONT COLOR="#BC8F8F">'#'</FONT></B>;
                T[n2++] = s[i];
            }
            T[n2++] = <B><FONT COLOR="#BC8F8F">'#'</FONT></B>;
            T[n2++] = <B><FONT COLOR="#BC8F8F">'$'</FONT></B>;
            T[n2] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
        }
    }
 
    string get_longest_palindrome() {
        <B><FONT COLOR="#228B22">int</FONT></B> n = strlen(T);
        <B><FONT COLOR="#228B22">int</FONT></B> *P = <B><FONT COLOR="#A020F0">new</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>[n];
        <B><FONT COLOR="#228B22">int</FONT></B> C = 0, R = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; n - 1; i++ ){
            <B><FONT COLOR="#228B22">int</FONT></B> i_mirror = 2 * C - i; <I><FONT COLOR="#B22222">// equals to i' = C - (i-C)
</FONT></I>    
            P[i] = (R &gt; i) ? min(R-i, P[i_mirror]) : 0;
    
            <I><FONT COLOR="#B22222">// Attempt to expand palindrome centered at i
</FONT></I>            <B><FONT COLOR="#A020F0">while</FONT></B>(T[i + 1 + P[i]] == T[i - 1 - P[i]])
                P[i]++;
 
            <I><FONT COLOR="#B22222">// If palindrome centered at i expand past R,
</FONT></I>            <I><FONT COLOR="#B22222">// adjust center based on expanded palindrome.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B>(i + P[i] &gt; R){
                C = i;
                R = i + P[i];
            }
        }
 
        <I><FONT COLOR="#B22222">// Find the maximum element in P.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> maxLen = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> centerIndex = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; n-1; i++){
            <B><FONT COLOR="#A020F0">if</FONT></B> (P[i] &gt; maxLen){
                maxLen = P[i];
                centerIndex = i;
            }
        }

        <B><FONT COLOR="#A020F0">delete</FONT></B>[] P;
        <B><FONT COLOR="#A020F0">return</FONT></B> s.substr((centerIndex - 1 - maxLen)/2, maxLen);
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    ManacherAlgorithm solver(<B><FONT COLOR="#BC8F8F">&quot;abaaba&quot;</FONT></B>);
    cout &lt;&lt; solver.get_longest_palindrome() &lt;&lt; endl;

    solver = ManacherAlgorithm(<B><FONT COLOR="#BC8F8F">&quot;abba&quot;</FONT></B>);
    cout &lt;&lt; solver.get_longest_palindrome() &lt;&lt; endl;

    solver = ManacherAlgorithm(<B><FONT COLOR="#BC8F8F">&quot;xabac&quot;</FONT></B>);
    cout &lt;&lt; solver.get_longest_palindrome() &lt;&lt; endl;

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file37">
<H1>string/StringMatching.cpp 37/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file36">prev</A>][<A HREF="#file38">next</A>]
<PRE>
<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Z-functions
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////// 
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<I><FONT COLOR="#B22222">// z-functions: return z, z[i] is the length of the longest substring
</FONT></I><I><FONT COLOR="#B22222">//              starting from S[i] which is also a prefix of S
</FONT></I>
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; get_ZFunction(string s){
    <B><FONT COLOR="#228B22">int</FONT></B> len = s.length();
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; z(len);
    <B><FONT COLOR="#228B22">int</FONT></B> L = 0, R = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; len; i++ ){
        <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; R){
            L = R = i;
            <B><FONT COLOR="#A020F0">while</FONT></B> (R &lt; len &amp;&amp; s[R-L] == s[R]) R++;
            z[i] = R - L; R--;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> k = i - L;
            <B><FONT COLOR="#A020F0">if</FONT></B>(z[k] &lt; R - i + 1) z[i] = z[k];
            <B><FONT COLOR="#A020F0">else</FONT></B> {
                L = i;
                <B><FONT COLOR="#A020F0">while</FONT></B> (R &lt; len &amp;&amp; s[R - L] == s[R]) R++;
                z[i] = R - L; R--;
            }
        }
    }
    z[0] = len;
    <B><FONT COLOR="#A020F0">return</FONT></B> z;
}


<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Knuth-Morris-Pratt
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
<I><FONT COLOR="#B22222">/* 
  Searches for the string w in the string s (of length k). Returns the 
  0-based index of the first match (k if no match is found). Algorithm 
  runs in O(k) time. 
*/</FONT></I> 

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;

<B><FONT COLOR="#228B22">class</FONT></B> KnuthMorrisPratt {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> build_table(string&amp; w, VI&amp; t){
        <B><FONT COLOR="#228B22">int</FONT></B> sz = w.size();
        t = VI(sz);
        <B><FONT COLOR="#228B22">int</FONT></B> i = 2, j = 0;
        t[0] = -1; t[1] = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (i &lt; sz) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (w[i - 1] == w[j]) { t[i] = j + 1; i++; j++; }
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (j &gt; 0) j = t[j];
            <B><FONT COLOR="#A020F0">else</FONT></B> { t[i] = 0; i++; }
        }
    }

    <I><FONT COLOR="#B22222">// returh the index of the first match, or the length of s if w is not found
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> KMP(string s, string w){
        <B><FONT COLOR="#228B22">int</FONT></B> m = 0, i = 0;
        VI t;
        build_table(w, t);
        <B><FONT COLOR="#228B22">int</FONT></B> sz_s = s.size();
        <B><FONT COLOR="#228B22">int</FONT></B> sz_w = w.size();
        <B><FONT COLOR="#A020F0">while</FONT></B> (m+i &lt; sz_s) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (w[i] == s[m+i]) {
                i++;
                <B><FONT COLOR="#A020F0">if</FONT></B> (i == sz_w) <B><FONT COLOR="#A020F0">return</FONT></B> m;
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                m += i - t[i];
                <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; 0) i = t[i];
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> s.length();
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    KnuthMorrisPratt solve;
    assert(solve.KMP(<B><FONT COLOR="#BC8F8F">&quot;win&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;I wanna win.&quot;</FONT></B>) == 3);
    assert(solve.KMP(<B><FONT COLOR="#BC8F8F">&quot;I wanna win.&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;win&quot;</FONT></B>) == 8);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}  

<I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Prefix Function
</FONT></I><I><FONT COLOR="#B22222">//  Given a string. Return an array of numbers, 
</FONT></I><I><FONT COLOR="#B22222">//  where is defined as follows: it is a maximum length of the longest 
</FONT></I><I><FONT COLOR="#B22222">//  proper suffix substring that matches the prefix (suffix own - so not 
</FONT></I><I><FONT COLOR="#B22222">//  the entire line). In particular, the value is set equal to zero.
</FONT></I><I><FONT COLOR="#B22222">//  For example, the string &quot;abcabcd&quot; prefix function is: [1, 0, 0, 1, 2, 3, 0]
</FONT></I><I><FONT COLOR="#B22222">///////////////////////////////////////////////////////////////////////////////
</FONT></I>
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; prefix_function (string s){
    <B><FONT COLOR="#228B22">int</FONT></B> n = (<B><FONT COLOR="#228B22">int</FONT></B>) s.length();
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; pi (n);
    pi[0] = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i=1; i&lt;n; ++i){
        <B><FONT COLOR="#228B22">int</FONT></B> j = pi[i-1];
        <B><FONT COLOR="#A020F0">while</FONT></B> (j &gt; 0 &amp;&amp; s[i] != s[j])
            j = pi[j-1];
        <B><FONT COLOR="#A020F0">if</FONT></B> (s[i] == s[j])  ++j;
        pi[i] = j;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> pi;
}
</PRE>
<HR>
<A NAME="file38">
<H1>string/SuffixArray.cpp 38/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file37">prev</A>][<A HREF="#file39">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Suffix Array
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  For example, s = &quot;banana&quot;
</FONT></I><I><FONT COLOR="#B22222">//  0 $(end of string)     0  1  2  3  4  5  6
</FONT></I><I><FONT COLOR="#B22222">//  1 a                    b  a  n  a  n  a  $
</FONT></I><I><FONT COLOR="#B22222">//  2 ana          RA[] = [4, 3, 6, 2, 5, 1, 0] (Rank array)
</FONT></I><I><FONT COLOR="#B22222">//  3 anana   -&gt;   SA[] = [6, 5, 3, 1, 0, 4, 2] (Suffix array)
</FONT></I><I><FONT COLOR="#B22222">//  4 banana      LCP[] = [0, 1, 3, 0, 0, 2]    (Longest Common Prefix array
</FONT></I><I><FONT COLOR="#B22222">//  5 na                                         LCP between pairs of consecutive suffixes)
</FONT></I><I><FONT COLOR="#B22222">//  6 nana
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstring&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII; <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;PII, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII2;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI; <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">class</FONT></B> SuffixArray {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    VI SA, RA, LCP;
    SuffixArray(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* S) : N(strlen(S)) {
        VI V; <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) V.push_back(S[i]); init(V);
    }
    SuffixArray(<B><FONT COLOR="#228B22">const</FONT></B> VI &amp;VV) : N(VV.size()) { VI V(VV); init(V); }
<B><FONT COLOR="#228B22">private</FONT></B>:
    <B><FONT COLOR="#228B22">void</FONT></B> init(VI&amp; V) {
        VI OV(V), C(N);
        compress(V, C); compute_sa(V, C);
        RA.resize(N + 1); <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= N; i++) RA[SA[i]] = i;
        compute_lcp(OV);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> compress(VI&amp; V, VI&amp; C) {
        copy(V.begin(), V.end(), C.begin());
        sort(C.begin(), C.end());
        <B><FONT COLOR="#5F9EA0">VI</FONT></B>::iterator cend = unique(C.begin(), C.end());
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) V[i] = lower_bound(C.begin(), cend, V[i]) - C.begin() + 1;
        V.push_back(0); C.push_back(0);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> compute_sa(VI&amp; V, VI&amp; C) {
        VI T(N + 1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= N; i++) SA.push_back(i);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> ski = 0; V[SA[N]] &lt; N; ski = ski ? ski &lt;&lt; 1 : 1) {
            fill(C.begin(), C.end(), 0);
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; ski; i++) T[i] = N - i;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0, p = ski; i &lt;= N; i++) <B><FONT COLOR="#A020F0">if</FONT></B>(SA[i] &gt;= ski) T[p++] = SA[i] - ski;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= N; i++) C[V[i]]++;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= N; i++) C[i] += C[i - 1];
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = N; i &gt;= 0; i--) SA[--C[V[T[i]]]] = T[i];
            T[SA[0]] = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= N; j++) {
                <B><FONT COLOR="#228B22">int</FONT></B> a = SA[j];
                <B><FONT COLOR="#228B22">int</FONT></B> b = SA[j - 1];
                T[a] = T[b] + (a + ski &gt;= N || b + ski &gt;= N ||
                               V[a] != V[b] || V[a + ski] != V[b + ski]);
            }
            V.swap(T);
        }
    }
    <B><FONT COLOR="#228B22">void</FONT></B> compute_lcp(<B><FONT COLOR="#228B22">const</FONT></B> VI&amp; OV) {
        LCP = VI(N);
        <B><FONT COLOR="#228B22">int</FONT></B> len = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++, len = max(0, len - 1)) {
            <B><FONT COLOR="#228B22">int</FONT></B> si = RA[i], j = SA[si - 1];
            <B><FONT COLOR="#A020F0">for</FONT></B> (; i + len &lt; N &amp;&amp; j + len &lt; N &amp;&amp; OV[i + len] == OV[j + len]; len++);
            LCP[si - 1] = len;
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    string s = <B><FONT COLOR="#BC8F8F">&quot;banana&quot;</FONT></B>;
    SuffixArray sa(s.c_str());
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= sa.N; i++) {
        printf(<B><FONT COLOR="#BC8F8F">&quot;%d &quot;</FONT></B>, sa.SA[i]);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file39">
<H1>string/SuffixTree.cpp 39/39</H1>
[<A HREF="#top">top</A>][<A HREF="#file38">prev</A>][next]
<PRE>
<I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">//  Suffix Tree
</FONT></I><I><FONT COLOR="#B22222">//  by Ukkonen's algorithm in O(N * alphabetSize)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  There are 2 more methods added to solve this problem:
</FONT></I><I><FONT COLOR="#B22222">//  http://codeforces.com/contest/452/problem/E
</FONT></I><I><FONT COLOR="#B22222">//    - For each valid l, find the number of common substrings of lengh l
</FONT></I><I><FONT COLOR="#B22222">//      that are in all three given strings
</FONT></I><I><FONT COLOR="#B22222">/////////////////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> first
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> second
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SZ</FONT></B>(x) ((int)((x).size()))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PB</FONT></B>(x) push_back(x);
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INF</FONT> (0x3f3f3f3f)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MEMSET</FONT></B>(x,v) memset(x,v,sizeof(x));

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII; <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;PII, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII2;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI; <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;LL, LL&gt; PLL; <B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;PLL, LL&gt; PLL2;
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MOD</FONT> (1000000007)

<I><FONT COLOR="#B22222">// The number of delimiters the class will use is equal to the number of strings added
</FONT></I><I><FONT COLOR="#B22222">// Please make sure that all the delimiters won't appear in the input strings
</FONT></I><I><FONT COLOR="#B22222">// Example of delimiters
</FONT></I><I><FONT COLOR="#B22222">// '\1' -&gt; '\1', '\2', '\3', '\4', ... (these characters are invisible)
</FONT></I><I><FONT COLOR="#B22222">// '#'  -&gt; '#', '$', '%', '&amp;', ...
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">char</FONT></B> FIRST_DELIMITER&gt;
<B><FONT COLOR="#228B22">class</FONT></B> SuffixTree {
<B><FONT COLOR="#228B22">public</FONT></B>:
    <B><FONT COLOR="#228B22">class</FONT></B> Node {
    <B><FONT COLOR="#228B22">public</FONT></B>:
        <B><FONT COLOR="#228B22">int</FONT></B> begin, end; <I><FONT COLOR="#B22222">// s[begin...end-1]
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> depth; <I><FONT COLOR="#B22222">// depth by chars from the root to this node
</FONT></I>        Node *parent;
        vector&lt;Node*&gt; children;
        Node *suffix_link;
        Node(<B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> e, <B><FONT COLOR="#228B22">int</FONT></B> d, Node *p, <B><FONT COLOR="#228B22">int</FONT></B> alpha_size) : begin(b), end(e), depth(d) , parent(p) {
            children = vector&lt;Node*&gt;(alpha_size);
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; alpha_size; i++) children[i] = NULL;
            suffix_link = NULL;
        }
        <B><FONT COLOR="#228B22">bool</FONT></B> contains(<B><FONT COLOR="#228B22">int</FONT></B> d) { <B><FONT COLOR="#A020F0">return</FONT></B> depth &lt;= d &amp;&amp; d &lt; depth + (end - begin); }
    };
    Node *root;
    vector&lt;string&gt; strings;
    set&lt;<B><FONT COLOR="#228B22">char</FONT></B>&gt; alphabets;
    string concat_s;
    SuffixTree() { root = NULL; concat_s = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>; }
    <B><FONT COLOR="#228B22">void</FONT></B> add_string(string s) {
        strings.PB(s); concat_s += s;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">char</FONT></B> c : s) { alphabets.insert(c); }
        concat_s += FIRST_DELIMITER + (SZ(strings) - 1); <I><FONT COLOR="#B22222">// added a delimiter in between strings
</FONT></I>        alphabets.insert(FIRST_DELIMITER + (SZ(strings) - 1));
    }
    <B><FONT COLOR="#228B22">void</FONT></B> build_suffix_tree() {
        <B><FONT COLOR="#228B22">int</FONT></B> alphabet_size = SZ(alphabets);
        <B><FONT COLOR="#228B22">int</FONT></B> N = SZ(concat_s);
        VI a(N);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> j = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">char</FONT></B> c : alphabets) { <B><FONT COLOR="#A020F0">if</FONT></B> (concat_s[i] == c) { a[i] = j; <B><FONT COLOR="#A020F0">break</FONT></B>; } j++; }
        }
        root = <B><FONT COLOR="#A020F0">new</FONT></B> Node(0, 0, 0, NULL, alphabet_size);
        Node *cn = root; <I><FONT COLOR="#B22222">// root.suffixLink must be null, but that way it gets more convenient processing
</FONT></I>        root-&gt;suffix_link = root;
        Node *needs_suffix_link = NULL;
        <B><FONT COLOR="#228B22">int</FONT></B> last_rule = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> j = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = -1; i &lt; N - 1; i++) { <I><FONT COLOR="#B22222">// strings s[j..i] already in tree, add s[i+1] to it
</FONT></I>            <B><FONT COLOR="#228B22">int</FONT></B> cur = a[i + 1]; <I><FONT COLOR="#B22222">// last char of current string
</FONT></I>            <B><FONT COLOR="#A020F0">for</FONT></B> (; j &lt;= i + 1; j++) {
                <B><FONT COLOR="#228B22">int</FONT></B> cur_depth = i + 1 - j;
                <B><FONT COLOR="#A020F0">if</FONT></B> (last_rule != 3) {
                    cn = cn-&gt;suffix_link != NULL ? cn-&gt;suffix_link : cn-&gt;parent-&gt;suffix_link;
                    <B><FONT COLOR="#228B22">int</FONT></B> k = j + cn-&gt;depth;
                    <B><FONT COLOR="#A020F0">while</FONT></B> (cur_depth &gt; 0 &amp;&amp; !cn-&gt;contains(cur_depth - 1)) {
                        k += cn-&gt;end - cn-&gt;begin;
                        cn = cn-&gt;children[a[k]];
                    }
                }
                <B><FONT COLOR="#A020F0">if</FONT></B> (!cn-&gt;contains(cur_depth)) { <I><FONT COLOR="#B22222">// explicit node
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (needs_suffix_link != NULL) {
                        needs_suffix_link-&gt;suffix_link = cn;
                        needs_suffix_link = NULL;
                    }
                    <B><FONT COLOR="#A020F0">if</FONT></B> (cn-&gt;children[cur] == NULL) {
                        <I><FONT COLOR="#B22222">// no extension - add leaf
</FONT></I>                        cn-&gt;children[cur] = <B><FONT COLOR="#A020F0">new</FONT></B> Node(i + 1, N, cur_depth, cn, alphabet_size);
                        last_rule = 2;
                    } <B><FONT COLOR="#A020F0">else</FONT></B> {
                        cn = cn-&gt;children[cur];
                        last_rule = 3; <I><FONT COLOR="#B22222">// already exists
</FONT></I>                        <B><FONT COLOR="#A020F0">break</FONT></B>;
                    }
                } <B><FONT COLOR="#A020F0">else</FONT></B> { <I><FONT COLOR="#B22222">// implicit node
</FONT></I>                    <B><FONT COLOR="#228B22">int</FONT></B> end = cn-&gt;begin + cur_depth - cn-&gt;depth;
                    <B><FONT COLOR="#A020F0">if</FONT></B> (a[end] != cur) { <I><FONT COLOR="#B22222">// split implicit node here
</FONT></I>                        Node *newn = <B><FONT COLOR="#A020F0">new</FONT></B> Node(cn-&gt;begin, end, cn-&gt;depth, cn-&gt;parent, alphabet_size);
                        newn-&gt;children[cur] = <B><FONT COLOR="#A020F0">new</FONT></B> Node(i + 1, N, cur_depth, newn, alphabet_size);
                        newn-&gt;children[a[end]] = cn;
                        cn-&gt;parent-&gt;children[a[cn-&gt;begin]] = newn;
                        <B><FONT COLOR="#A020F0">if</FONT></B> (needs_suffix_link != NULL) {
                            needs_suffix_link-&gt;suffix_link = newn;
                        }
                        cn-&gt;begin = end;
                        cn-&gt;depth = cur_depth;
                        cn-&gt;parent = newn;
                        cn = needs_suffix_link = newn;
                        last_rule = 2;
                    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (cn-&gt;end != N || cn-&gt;begin - cn-&gt;depth &lt; j) {
                        last_rule = 3;
                        <B><FONT COLOR="#A020F0">break</FONT></B>;
                    } <B><FONT COLOR="#A020F0">else</FONT></B> {
                        last_rule = 1;
                    }
                }

            }
        }
        root-&gt;suffix_link = NULL;
    }
    
    <I><FONT COLOR="#B22222">////////////////////////////////////////////////
</FONT></I>    <I><FONT COLOR="#B22222">// Just examples of how to use the tree
</FONT></I>    <I><FONT COLOR="#B22222">////////////////////////////////////////////////
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> print_preorder() {
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Preorder Traversal: &quot;</FONT></B> &lt;&lt; endl;
        print_preorder(root);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> print_suffix_array() {
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Suffix Array: &quot;</FONT></B> &lt;&lt; endl;
        print_suffix_array(root);
    }

    <B><FONT COLOR="#228B22">int</FONT></B> max_common_len;
    <B><FONT COLOR="#228B22">int</FONT></B> max_common_begin;
    <I><FONT COLOR="#B22222">// Maximum Common Substring of the first two strings added
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> find_max_common_substring() {
        assert(SZ(strings) &gt;= 2);
        max_common_len = -1;
        <B><FONT COLOR="#228B22">int</FONT></B> len1 = SZ(strings[0]);
        <B><FONT COLOR="#228B22">int</FONT></B> len2 = SZ(strings[1]);
        find_max_common_substring(root, len1, len1 + len2 + 1);
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Max Common Substring Length: &quot;</FONT></B> &lt;&lt; max_common_len &lt;&lt; endl;
        <B><FONT COLOR="#A020F0">if</FONT></B> (max_common_len) {
            cout &lt;&lt; concat_s.substr(max_common_begin, max_common_len) &lt;&lt; endl;
        }
    }
<B><FONT COLOR="#228B22">private</FONT></B>:
    pair&lt;<B><FONT COLOR="#228B22">bool</FONT></B>, <B><FONT COLOR="#228B22">bool</FONT></B>&gt; find_max_common_substring(Node *cur, <B><FONT COLOR="#228B22">int</FONT></B> i1, <B><FONT COLOR="#228B22">int</FONT></B> i2) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;begin &lt;= i1 &amp;&amp; i1 &lt; cur-&gt;end) {
            <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(true, false); <I><FONT COLOR="#B22222">// found a suffix of the first string
</FONT></I>        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;begin &lt;= i2 &amp;&amp; i2 &lt; cur-&gt;end) {
            <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(false, true); <I><FONT COLOR="#B22222">// found a suffix of the second string
</FONT></I>        }
        pair&lt;<B><FONT COLOR="#228B22">bool</FONT></B>, <B><FONT COLOR="#228B22">bool</FONT></B>&gt; ret = make_pair(false, false);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(alphabets); i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;children[i]) {
                pair&lt;<B><FONT COLOR="#228B22">bool</FONT></B>, <B><FONT COLOR="#228B22">bool</FONT></B>&gt; temp = find_max_common_substring(cur-&gt;children[i], i1, i2);
                ret.x |= temp.x;
                ret.y |= temp.y;
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (ret.x &amp;&amp; ret.y) { <I><FONT COLOR="#B22222">// found a common substring
</FONT></I>            <B><FONT COLOR="#228B22">int</FONT></B> len = cur-&gt;depth + cur-&gt;end - cur-&gt;begin;
            <B><FONT COLOR="#A020F0">if</FONT></B> (len &gt; max_common_len) {
                max_common_len = len;
                max_common_begin = cur-&gt;begin - cur-&gt;depth; <I><FONT COLOR="#B22222">// give the starting position of the suffix
</FONT></I>            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> print_preorder(Node *cur) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur == root) cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;ROOT&quot;</FONT></B> &lt;&lt; endl;
        <B><FONT COLOR="#A020F0">else</FONT></B> cout &lt;&lt; concat_s.substr(cur-&gt;begin, cur-&gt;end - cur-&gt;begin) &lt;&lt; endl;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(alphabets); i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;children[i] != NULL) {
                print_preorder(cur-&gt;children[i]);
            }
        }
    }

    <B><FONT COLOR="#228B22">void</FONT></B> print_suffix_array(Node *cur) {
       <B><FONT COLOR="#228B22">bool</FONT></B> is_leaf = true;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(alphabets); i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;children[i] != NULL) {
                print_suffix_array(cur-&gt;children[i]);
                is_leaf = false;
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (is_leaf) {
            cout &lt;&lt; concat_s.substr(cur-&gt;begin - cur-&gt;depth, cur-&gt;end - (cur-&gt;begin - cur-&gt;depth)) &lt;&lt; endl;
        }
    }
<B><FONT COLOR="#228B22">public</FONT></B>:
    <I><FONT COLOR="#B22222">// Add more methods below
</FONT></I>    PII2 dfs(Node *cur, <B><FONT COLOR="#228B22">int</FONT></B> i1, <B><FONT COLOR="#228B22">int</FONT></B> i2, <B><FONT COLOR="#228B22">int</FONT></B> i3, vector&lt;LL&gt; &amp;ans) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;begin &lt;= i1 &amp;&amp; i1 &lt; cur-&gt;end) {
            <B><FONT COLOR="#A020F0">return</FONT></B> PLL2(PLL(1, 0), 0);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;begin &lt;= i2 &amp;&amp; i2 &lt; cur-&gt;end) {
            <B><FONT COLOR="#A020F0">return</FONT></B> PLL2(PLL(0, 1), 0);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;begin &lt;= i3 &amp;&amp; i3 &lt; cur-&gt;end) {
            <B><FONT COLOR="#A020F0">return</FONT></B> PLL2(PLL(0, 0), 1);
        }
        PLL2 ret = PLL2(PLL(0, 0), 0);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; SZ(alphabets); i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (cur-&gt;children[i]) {
                PLL2 temp = dfs(cur-&gt;children[i], i1, i2, i3, ans);
                ret.x.x += temp.x.x;
                ret.x.y += temp.x.y;
                ret.y += temp.y;
                ret.x.x %= MOD; ret.x.y %= MOD; ret.y %= MOD;
            }
        }
        LL x = (((ret.x.x * ret.x.y) % MOD) * ret.y) % MOD;
        <B><FONT COLOR="#228B22">int</FONT></B> len = cur-&gt;depth + cur-&gt;end - cur-&gt;begin;
        ans[cur-&gt;depth] += x; ans[cur-&gt;depth] %= MOD;
        ans[len] -= x; <B><FONT COLOR="#A020F0">if</FONT></B> (ans[len] &lt; 0) ans[len] += MOD;
        <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    }
    
    <B><FONT COLOR="#228B22">void</FONT></B> solve() {
        vector&lt;LL&gt; ans(SZ(concat_s), 0);
        <B><FONT COLOR="#228B22">int</FONT></B> len1 = SZ(strings[0]), len2 = SZ(strings[1]), len3 = SZ(strings[2]);
        dfs(root, len1, len1 + len2 + 1, len1 + len2 + len3 + 2, ans);
        <B><FONT COLOR="#228B22">int</FONT></B> min_len = min(len1, min(len2, len3));
        <B><FONT COLOR="#228B22">int</FONT></B> res = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; min_len; i++) {
            res += ans[i]; res %= MOD;
            printf(<B><FONT COLOR="#BC8F8F">&quot;%d &quot;</FONT></B>, (<B><FONT COLOR="#228B22">int</FONT></B>)res);
        }
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    string s1, s2, s3;
    SuffixTree&lt;<B><FONT COLOR="#BC8F8F">'#'</FONT></B>&gt; tree;
    cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;
    tree.add_string(s1);
    tree.add_string(s2);
    tree.add_string(s3);
    tree.build_suffix_tree();
    tree.solve();
    <I><FONT COLOR="#B22222">/*
    {
        SuffixTree&lt;'#'&gt; tree;
        tree.add_string(&quot;baab&quot;);
        tree.build_suffix_tree();
        tree.print_preorder();
        tree.print_suffix_array();
    }

    {
        SuffixTree&lt;'#'&gt; tree;
        tree.add_string(&quot;banana&quot;);
        tree.add_string(&quot;xana&quot;);
        tree.build_suffix_tree();
        tree.find_max_common_substring();
    }
    */</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.6</A>.</ADDRESS>
</BODY>
</HTML>
